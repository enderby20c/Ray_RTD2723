/********************************************************************************/
/*   Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.        */
/*                                                                              */
/*   SPDX-License-Identifier: LicenseRef-Realtek-Proprietary                    */
/*                                                                              */
/*   This software component is confidential and proprietary to Realtek         */
/*   Semiconductor Corp. Disclosure, reproduction, redistribution, in whole     */
/*   or in part, of this work and its derivatives without express permission    */
/*   is prohibited.                                                             */
/********************************************************************************/

//----------------------------------------------------------------------------------------------------
// ID Code      : SysUsb.c No.0000
// Update Note  :
//----------------------------------------------------------------------------------------------------

#define __SYSTEM_USB__

#include "SysInclude.h"
#include "Usb/SysUsb.h"

#if(_USB_SUPPORT == _ON)

#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
#if((_USB_VENDOR_ID_H == 0x0B) && (_USB_VENDOR_ID_L == 0xDA))
#warning "NOTE: Please Check Product ID (_USB_PRODUCT_ID_H/_USB_PRODUCT_ID_L) is set to RTD Number When VID = Realtek"
#endif

#if(_TYPE_C_EMB_CTS_FLOW == _ON)
#warning "NOTE: _TYPE_C_EMB_CTS_FLOW Is Only For TypeC CTS, Use CTS ON For MP should confirm with PM !!"
#endif
#endif


//****************************************************************************
// CODE TABLES
//****************************************************************************
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
EnumTypeCPcbPort g_penumUsbTypeCPcbPort[_TYPE_C_PORT_VALID] =
{
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _D0_TYPE_C_PORT,
#endif

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _D1_TYPE_C_PORT,
#endif

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _D2_TYPE_C_PORT,
#endif

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _P0_TYPE_C_PORT,
#endif

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _P1_TYPE_C_PORT,
#endif

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _P2_TYPE_C_PORT,
#endif

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _P3_TYPE_C_PORT,
#endif

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _P4_TYPE_C_PORT,
#endif

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    _ADAPTOR_TYPE_C_PORT,
#endif

    _VALUE_NO_TYPE_C_PORT,
};
#endif // End of #if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
//****************************************************************************
// VARIABLE DECLARATIONS
//****************************************************************************
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
WORD g_usUsbAdaptorPower;
StructUsbTypeCPowerInfo g_stUsbTypeCPowerInfo;
StructUsbTypeCStatus g_pstUsbTypeCStatus[_TYPE_C_PORT_VALID];
StructBillBoardStatus  g_pstUsbBillBoardStatus[_TYPE_C_PORT_VALID];
BYTE g_ucUsbBBEnableStatus;
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))
EnumBillboardProgramCtrl g_penumUsbBBUserProgramEnable[_TYPE_C_PORT_VALID];
#endif
#endif // End of #if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_USB_HUB_SUPPORT == _ON)
StructUsbHubStatus g_pstUsbHubStatus[_USB_PORT_VALID];
EnumUsbHubMode g_enumUsbHubSupportMode;
BYTE g_ucUsbHubEventTimeoutFlag = _TRUE;
EnumUsbHubOSDResult g_enumUsbHubOSDResult = _HUB_NONE_PORT;
EnumUsbHubSwitchOSDEvent g_enumUsbHubSwitchOSDEvent = _USB_HUB_SWITCH_NONE;
#endif // End of #if(_USB_HUB_SUPPORT == _ON)

#if(_USB2_HOST_SUPPORT == _ON)
StructUsbU2HostDevConnectInfo g_stUsbU2HostDevConnectInfo;
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
volatile BYTE g_ucUsbU2HostFWUpdateProcessRate = 0;
volatile BYTE g_ucUsbFwUpdateFlowStart = 0;
volatile EnumUSB2HostEventResult g_penumUsb2HostEventStatus[_U2HOST_EVENT_COUNT];
volatile BYTE g_pucUsb2HostEventChange[_U2HOST_EVENT_CHANGE_COUNT];
volatile BYTE g_pucUsb2HostEventChangeStatus[_U2HOST_EVENT_CHANGE_COUNT];
#endif

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_MAIN_LOOP)
bit g_bUsb2HostFlowReset = _FALSE;

bit g_bUsbU2HostExfatFileExtPreLoopFlag = _FALSE;
#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON)
BYTE g_ucUsbU2HostDMCtrlDummyReg;
bit g_bUsbU2HostDumpCurFrameFinish = _FALSE;
#endif
#endif

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
#if(_USB2_HOST_OHCI_COLOR_ANALYZER_SUPPORT == _ON)
bit g_bUsb2HostColorBulkWriteReq = _FALSE;
bit g_bUsb2HostColorBulkReadReq = _FALSE;
bit g_bUsb2HostColorIntWriteReq = _FALSE;
bit g_bUsb2HostColorIntReadReq = _FALSE;
bit g_bUsb2HostColorBulkWriteDone = _FALSE;
bit g_bUsb2HostColorBulkWriteProcessing = _FALSE;
bit g_bUsb2HostColorBulkReadDone = _FALSE;
bit g_bUsb2HostColorBulkReadProcessing = _FALSE;
bit g_bUsb2HostColorIntWriteDone = _FALSE;
bit g_bUsb2HostColorIntWriteProcessing = _FALSE;
bit g_bUsb2HostColorIntReadDone = _FALSE;
bit g_bUsb2HostColorIntReadProcessing = _FALSE;
bit g_bUsb2HostColorQueueBufferDone = _FALSE;
bit g_bUsb2HostColorDequeueBufferDone = _FALSE;
bit g_bUsb2HostColorStartReadData = _FALSE;
#endif
#endif // End of #if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
#endif // End of #if(_USB2_HOST_SUPPORT == _ON)
//****************************************************************************
// FUNCTION DEFINITIONS
//****************************************************************************
//--------------------------------------------------
// Description  : AC On USB Hub + Repaeter + TypeC + BB + U2Host Initial Setting
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbInitial(void)
{
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // TypeC Initial Setting
    SysUsbTypeCInitial();
#endif

#if(_USB_HUB_SUPPORT == _ON)
    // Hub & Repeater Initial Setting
    SysUsbHubInitial();
#endif

#if(_USB2_HOST_SUPPORT == _ON)
#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_MAIN_LOOP)
    // U2Host Related Function Initial Setting
    SysUsbU2HostAcOnInitial();
#endif
#endif

#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_BILLBOARD_SUPPORT == _ON)
    // BillBoard Initial Setting
    SysUsbBillboardInitial();
#endif
#endif
}

//--------------------------------------------------
// Description  : PD/CC Process
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbHandler(void)
{
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // Update Mode Status For Scaler Level Usage
    SysUsbTypeCUpdateSysModeStatus();

    // Check Power Status
    SysUsbTypeCSystemPowerManagement();
#endif

#if(_USB_HUB_SUPPORT == _ON)
    // Update USB Hub OSD Event : Inculde Hub Switch Status and USB U2U3 Capability
    SysUsbHubJudgeOSDEvent();

    // TypeB Processing Individually
    SysUsbHubTypeBProcess();
#endif

#if(_USB2_HOST_SUPPORT == _ON)
#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_MAIN_LOOP)
    // U2Host Related Function Handler
    SysUsbU2HostHandler();
#endif
#endif

#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_D0_TYPE_C_PORT);
#endif

#if(_D0_USB_HUB_SUPPORT == _ON)
    // 2. Run Hub Proc to Detect if Any Device Connect to Hub
    SysUsbHubHandler(_D0_TYPE_C_PORT);
#endif

#if(_D0_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // 3.Run Usb Billboard Prco to Determine if using BB Function or not
    SysUsbBillboardHandler(_D0_TYPE_C_PORT);
#endif

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_D1_TYPE_C_PORT);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
    // 2. Run Hub Proc to Detect if Any Device Connect to Hub
    SysUsbHubHandler(_D1_TYPE_C_PORT);
#endif

#if(_D1_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // 3.Run Usb Billboard Prco to Determine if using BB Function or not
    SysUsbBillboardHandler(_D1_TYPE_C_PORT);
#endif

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_D2_TYPE_C_PORT);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
    // 2. Run Hub Proc to Detect if Any Device Connect to Hub
    SysUsbHubHandler(_D2_TYPE_C_PORT);
#endif

#if(_D2_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // 3.Run Usb Billboard Prco to Determine if using BB Function or not
    SysUsbBillboardHandler(_D2_TYPE_C_PORT);
#endif

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_P0_TYPE_C_PORT);

    // 2. Output Port Not Support Hub Function So Far
#endif  // End Of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_P1_TYPE_C_PORT);

    // 2. Output Port Not Support Hub Function So Far
#endif  // End Of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_P2_TYPE_C_PORT);

    // 2. Output Port Not Support Hub Function So Far
#endif  // End Of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_P3_TYPE_C_PORT);

    // 2. Output Port Not Support Hub Function So Far
#endif  // End Of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_P4_TYPE_C_PORT);

    // 2. Output Port Not Support Hub Function So Far
#endif  // End Of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    // 1. Run Type-C Proc According to Port Controller Status (For All Type-C Ports)
    SysUsbTypeCHandler(_ADAPTOR_TYPE_C_PORT);

    // 2. Output Port Not Support Hub Function So Far
#endif  // End Of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
}

//--------------------------------------------------
// Description  : Set Capability Change Power Switch Proc
// Input Value  : enumSwitch
// Output Value : None
//--------------------------------------------------
void SysUsbPowerSwitch(EnumPowerAction enumSwitch)
{
    enumSwitch = enumSwitch;
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    SysUsbTypeCPowerSwitch(enumSwitch);
#endif

#if(_USB3_REPEATER_SUPPORT == _ON)
    SysUsbHubPowerSwitch(enumSwitch);
#endif
}

//--------------------------------------------------
// Description  : Translate PCB Port into Type-C Port Index For Macro Usage
// Input Value  : enumTypeCPcbPort
// Output Value : Type-C Port Index
//--------------------------------------------------
BYTE SysUsbGetTypeCIndex(EnumTypeCPcbPort enumTypeCPcbPort)
{
    BYTE ucIndex = 0x00;
    enumTypeCPcbPort = enumTypeCPcbPort;

#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _D0_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _D1_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _D2_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _P0_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _P1_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _P2_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _P3_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _P4_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }

#endif

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    if(enumTypeCPcbPort == _ADAPTOR_TYPE_C_PORT)
    {
        return ucIndex;
    }

#endif

    // enumInputPort Invalid : Show Warning Message
    DebugMessageTypeC("8. [TYPE C] ==========X Invalid TypeC PCB Port For TypeC Index", enumTypeCPcbPort);

    return ucIndex;
}

//--------------------------------------------------
// Description  : Convert enumInputPort to TypeCPort
// Input Value  : enumInputPort --> Inputput
// Output Value : EnumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
//--------------------------------------------------
EnumTypeCPcbPort SysUsbDxConvertToTypeCPort(EnumInputPort enumInputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = _NO_TYPE_C_PORT;

    switch(enumInputPort)
    {
#if(_D0_USB_SUPPORT == _ON)
        case _D0_INPUT_PORT:

            enumTypeCPcbPort = _D0_TYPE_C_PORT;

            break;
#endif

#if(_D1_USB_SUPPORT == _ON)
        case _D1_INPUT_PORT:

            enumTypeCPcbPort = _D1_TYPE_C_PORT;

            break;
#endif

#if(_D2_USB_SUPPORT == _ON)
        case _D2_INPUT_PORT:

            enumTypeCPcbPort = _D2_TYPE_C_PORT;

            break;
#endif

        default:

            break;
    }
    return enumTypeCPcbPort;
}

//--------------------------------------------------
// Description  : Convert enumInputPort to TypeCPort
// Input Value  : enumOutputPort --> Output
// Output Value : EnumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
//--------------------------------------------------
EnumTypeCPcbPort SysUsbPxConvertToTypeCPort(EnumOutputPort enumOutputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = _NO_TYPE_C_PORT;

    switch(enumOutputPort)
    {
#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_OUTPUT_PORT:

            enumTypeCPcbPort = _P0_TYPE_C_PORT;

            break;
#endif

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_OUTPUT_PORT:

            enumTypeCPcbPort = _P1_TYPE_C_PORT;

            break;
#endif

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_OUTPUT_PORT:

            enumTypeCPcbPort = _P2_TYPE_C_PORT;

            break;
#endif

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_OUTPUT_PORT:

            enumTypeCPcbPort = _P3_TYPE_C_PORT;

            break;
#endif

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_OUTPUT_PORT:

            enumTypeCPcbPort = _P4_TYPE_C_PORT;

            break;
#endif

        default:

            break;
    }
    return enumTypeCPcbPort;
}

//--------------------------------------------------
// Description  : Convert TypeCPort to enumInputPort
// Input Value  : enumTypeCPcbPort --> _P0_TYPE_C_PORT / _P1_TYPE_C_PORT...
// Output Value : enumOutputPort  --> _P0_OUTPUT_PORT / _P1_OUTPUT_PORT...
//--------------------------------------------------
EnumOutputPort SysUsbTypeCConvertToPxPort(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumOutputPort enumOutputPort = _NO_OUTPUT_PORT;

    switch(enumTypeCPcbPort)
    {
        case _P0_TYPE_C_PORT:

            enumOutputPort = _P0_OUTPUT_PORT;

            break;

        case _P1_TYPE_C_PORT:

            enumOutputPort = _P1_OUTPUT_PORT;

            break;

        case _P2_TYPE_C_PORT:

            enumOutputPort = _P2_OUTPUT_PORT;

            break;

        case _P3_TYPE_C_PORT:

            enumOutputPort = _P3_OUTPUT_PORT;

            break;

        case _P4_TYPE_C_PORT:

            enumOutputPort = _P4_OUTPUT_PORT;

            break;

        default:
            break;
    }
    return enumOutputPort;
}

//--------------------------------------------------
// Description  : Convert TypeCPort to enumInputPort
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
// Output Value : enumInputPort --> _D0_INPUT_PORT / _D1_INPUT_PORT...
//--------------------------------------------------
EnumInputPort SysUsbTypeCConvertToDxPort(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumInputPort enumInputPort = _NO_INPUT_PORT;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

            enumInputPort = _D0_INPUT_PORT;

            break;

        case _D1_TYPE_C_PORT:

            enumInputPort = _D1_INPUT_PORT;

            break;

        case _D2_TYPE_C_PORT:

            enumInputPort = _D2_INPUT_PORT;

            break;

        case _D3_TYPE_C_PORT:

            enumInputPort = _D3_INPUT_PORT;

            break;

        case _D4_TYPE_C_PORT:

            enumInputPort = _D4_INPUT_PORT;

            break;

        case _D5_TYPE_C_PORT:

            enumInputPort = _D5_INPUT_PORT;

            break;

        case _D6_TYPE_C_PORT:

            enumInputPort = _D6_INPUT_PORT;

            break;

        default:
            break;
    }
    return enumInputPort;
}

//--------------------------------------------------
// Description  : Set Rx Port Capability Change Flag For External Interface
// Input Value  : enumInputPort : _D0_INPUT_PORT / _D1_INPUT_PORT.., enumCapability
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCRxSetCapabilityChangeFlag(EnumInputPort enumInputPort, EnumTypeCCapChgStatus enumCapability)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbDxConvertToTypeCPort(enumInputPort);
    enumCapability = enumCapability;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_D0_TYPE_C_PORT, enumCapability);
#endif

#if(_D0_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_D0_TYPE_C_PORT);
            }
#endif
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_D1_TYPE_C_PORT, enumCapability);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_D1_TYPE_C_PORT);
            }
#endif
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_D2_TYPE_C_PORT, enumCapability);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_D2_TYPE_C_PORT);
            }
#endif
            break;

        default:
            break;
    }
}

//--------------------------------------------------
// Description  : Set Tx Port Capability Change Flag For External Interface
// Input Value  : enumOutputPort : _P0_OUTPUT_PORT / _P1_OUTPUT_PORT.., enumCapability
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCTxSetCapabilityChangeFlag(EnumOutputPort enumOutputPort, EnumTypeCCapChgStatus enumCapability)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbPxConvertToTypeCPort(enumOutputPort);
    enumCapability = enumCapability;

    switch(enumTypeCPcbPort)
    {
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_P0_TYPE_C_PORT, enumCapability);
#endif

#if(_P0_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_P0_TYPE_C_PORT);
            }
#endif
            break;

        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_P1_TYPE_C_PORT, enumCapability);
#endif

#if(_P1_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_P1_TYPE_C_PORT);
            }
#endif
            break;

        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_P2_TYPE_C_PORT, enumCapability);
#endif

#if(_P2_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_P2_TYPE_C_PORT);
            }
#endif
            break;

        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_P3_TYPE_C_PORT, enumCapability);
#endif

#if(_P3_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_P3_TYPE_C_PORT);
            }
#endif
            break;

        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_CAPABILITY_CHG(_P4_TYPE_C_PORT, enumCapability);
#endif

#if(_P4_USB_HUB_SUPPORT == _ON)
            if(enumCapability == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                SET_USB_HUB_OSD_CAPABILITY_CHG(_P4_TYPE_C_PORT);
            }
#endif
            break;

        default:
            break;
    }
}

#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
//--------------------------------------------------
// Description  : AC On TypeC Initial Setting
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCInitial(void)
{
    SET_USB_TYPE_C_LOCAL_POWER_DETECT();

#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
    // Initial ADC Function
    DebugMessageTypeC("[ADC] <Initial>", 0x00);
    ScalerTypeCAdcInitial();
#elif(_PORT_CTRL_TCPM_SUPPORT == _ON)
    ScalerTypeCTcpmInitial();
#endif

#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_D0_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_D0_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_D0_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_D0_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_D0_TYPE_C_PORT);
#endif

#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_D0_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_D0_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_D0_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_D0_TYPE_C_PORT));
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_D0_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_D0_TYPE_C_PORT);
    }
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_D0_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_D0_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_D0_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_D0_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_D0_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_D0_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_D0_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_D0_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_D0_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> D0 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_D1_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_D1_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_D1_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_D1_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_D1_TYPE_C_PORT);
#endif

#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_D1_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_D1_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_D1_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_D1_TYPE_C_PORT));
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_D1_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_D1_TYPE_C_PORT);
    }
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_D1_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_D1_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_D1_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_D1_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_D1_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_D1_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_D1_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_D1_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_D1_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> D1 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)


#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_D2_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_D2_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_D2_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_D2_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_D2_TYPE_C_PORT);
#endif

#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_D2_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_D2_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_D2_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_D2_TYPE_C_PORT));
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_D2_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_D2_TYPE_C_PORT);
    }
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_D2_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_D2_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_D2_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_D2_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_D2_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_D2_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_D2_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_D2_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_D2_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> D2 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_P0_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P0_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_P0_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P0_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_P0_TYPE_C_PORT);
#endif

#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_P0_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P0_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_P0_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P0_TYPE_C_PORT));
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_P0_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_P0_TYPE_C_PORT);
    }
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_P0_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_P0_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_P0_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_P0_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_P0_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_P0_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_P0_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P0_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_P0_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> P0 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_P1_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P1_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_P1_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P1_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_P1_TYPE_C_PORT);
#endif

#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_P1_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P1_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_P1_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P1_TYPE_C_PORT));
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_P1_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_P1_TYPE_C_PORT);
    }
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_P1_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_P1_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_P1_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_P1_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_P1_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_P1_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_P1_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P1_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_P1_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> P1 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_P2_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P2_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_P2_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P2_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_P2_TYPE_C_PORT);
#endif

#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_P2_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P2_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_P2_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P2_TYPE_C_PORT));
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_P2_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_P2_TYPE_C_PORT);
    }
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_P2_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_P2_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_P2_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_P2_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_P2_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_P2_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_P2_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P2_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_P2_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> P2 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_P3_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P3_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_P3_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P3_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_P3_TYPE_C_PORT);
#endif

#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_P3_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P3_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_P3_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P3_TYPE_C_PORT));
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_P3_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_P3_TYPE_C_PORT);
    }
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_P3_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_P3_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_P3_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_P3_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_P3_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_P3_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_P3_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P3_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_P3_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> P3 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_P4_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P4_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_P4_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P4_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_P4_TYPE_C_PORT);
#endif

#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_P4_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_P4_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_P4_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_P4_TYPE_C_PORT));
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_P4_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_P4_TYPE_C_PORT);
    }
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_P4_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_P4_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_P4_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_P4_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_P4_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_P4_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_P4_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P4_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_P4_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> P4 CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
    ScalerTypeCSetDischargeCount(_ADAPTOR_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_ADAPTOR_TYPE_C_PORT));
    ScalerTypeCSetOperationMode(_ADAPTOR_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_ADAPTOR_TYPE_C_PORT));

#if(_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY)
    // Vbus Powered Sink Initial Process
    ScalerTypeCVbusPoweredSnkInitial(_ADAPTOR_TYPE_C_PORT);
#endif

#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
    ScalerTypeCTcpmSetDischargeCount(_ADAPTOR_TYPE_C_PORT, UserCommonUsbTypeCEmbeddedGetVbusDischargeCount(_ADAPTOR_TYPE_C_PORT));
    ScalerTypeCTcpmSetOperationMode(_ADAPTOR_TYPE_C_PORT, SysUsbTypeCGetDefaultOperationMode(_ADAPTOR_TYPE_C_PORT));
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
    // RTS Port Ctrl : Enable Vender Command
    if(UserCommonUsbTypeCRtsInitializeI2CCommunication(_ADAPTOR_TYPE_C_PORT) == _SUCCESS)
    {
        // RTS Port Ctrl : Set I2C Communication Enabled Flag
        UserCommonUsbTypeCRtsSetI2CEnabledFlag(_ADAPTOR_TYPE_C_PORT);
    }
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
    // RTD Port Ctrl : Reset Status and Start Detection
    UserCommonUsbTypeCRtdInitial(_ADAPTOR_TYPE_C_PORT);
#endif

    // If SPM = Fix Default Power, then Update Src PDO to Port Ctrol
    // If SPM = Adjust Dynamic Power, then SysUsbTypeCUpdatePortCtrlSrcPdo will be Executed in SysUsbTypeCSystemPowerManagement.
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(_ADAPTOR_TYPE_C_PORT);
    }

    SysUsbTypeCClrCapabilityChangeFlag(_ADAPTOR_TYPE_C_PORT, _TYPE_C_ALL_STATUS_CHG);
    SysUsbTypeCClrUserEventFlag(_ADAPTOR_TYPE_C_PORT, _TYPE_C_USER_EVENT_ALL);
    SysUsbTypeCUpdatePortCtrlSnkPdo(_ADAPTOR_TYPE_C_PORT);
    SysUsbTypeCConnectionDetCtrl(_ADAPTOR_TYPE_C_PORT, _ENABLE);
    SysUsbTypeCUnattachReset(_ADAPTOR_TYPE_C_PORT);
    SET_USB_TYPE_C_POWER_CONTROL_STATUS(_ADAPTOR_TYPE_C_PORT, _TYPE_C_POWER_ON);
    SET_USB_TYPE_C_STATE(_ADAPTOR_TYPE_C_PORT, _USB_TYPE_C_UNATTACH_STATE);

    DebugMessageTypeC("8. [TYPE C] <Step 0/2> ADAPTOR CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
#endif  // End Of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

    // SPM Initial
    SysUsbTypeCSystemPowerManagement();
    DebugMessageTypeC("[SPM] <Initial>", 0x00);

#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
    // Enable interrupt of TYPEC
    SET_INTERRUPT_ENABLE_STATUS(_INT_TYPEC, _ENABLE);
#endif
}

//--------------------------------------------------
// Description  : Set Capability Change Power Switch Proc
// Input Value  : enumSwitch
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCPowerSwitch(EnumPowerAction enumSwitch)
{
    switch(enumSwitch)
    {
        case _POWER_ACTION_AC_ON_TO_NORMAL:
        case _POWER_ACTION_AC_ON_TO_OFF:
        case _POWER_ACTION_OFF_TO_NORMAL:
        case _POWER_ACTION_FAKE_OFF_TO_NORMAL:
        case _POWER_ACTION_PS_TO_NORMAL:
        case _POWER_ACTION_FAKE_PS_TO_NORMAL:
        case _POWER_ACTION_OFF_TO_FAKE_OFF:

#if((_PORT_CTRL_RTS_SUPPORT == _ON) || (_PORT_CTRL_RTD_SUPPORT == _ON) || (_PORT_CTRL_USER_SERIES_SUPPORT == _ON))
            // Ext Port Controller Power Control
            if(enumSwitch == _POWER_ACTION_FAKE_OFF_TO_NORMAL)
            {
                UserInterfaceUsbTypeCPowerControl(_POWER_ACTION_OFF_TO_NORMAL);
            }
            else if(enumSwitch == _POWER_ACTION_FAKE_PS_TO_NORMAL)
            {
                UserInterfaceUsbTypeCPowerControl(_POWER_ACTION_PS_TO_NORMAL);
            }
            else
            {
                UserInterfaceUsbTypeCPowerControl(enumSwitch);
            }
#endif

#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_D0_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D0_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_D0_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_D0_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_D0_TYPE_C_PORT));

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_D0_TYPE_C_PORT, enumSwitch);
#endif

#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_D0_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D0_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D0_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_D0_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_D0_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_D0_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D0_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_D0_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_D0_TYPE_C_PORT);
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D0_TYPE_C_PORT);
            }
#endif  // End of #if((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_D1_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D1_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_D1_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_D1_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_D1_TYPE_C_PORT));

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_D1_TYPE_C_PORT, enumSwitch);
#endif

#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_D1_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D1_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D1_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_D1_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_D1_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_D1_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D1_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_D1_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_D1_TYPE_C_PORT);
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D1_TYPE_C_PORT);
            }
#endif  // End of #if((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_D2_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D2_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_D2_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_D2_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_D2_TYPE_C_PORT));

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_D2_TYPE_C_PORT, enumSwitch);
#endif

#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_D2_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D2_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D2_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_D2_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_D2_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_D2_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_D2_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_D2_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_D2_TYPE_C_PORT);
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D2_TYPE_C_PORT);
            }
#endif  // End of #if((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_P0_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P0_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_P0_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P0_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_P0_TYPE_C_PORT));

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_P0_TYPE_C_PORT, enumSwitch);
#endif

#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_P0_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P0_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P0_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_P0_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P0_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_P0_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P0_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_P0_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_P0_TYPE_C_PORT);
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P0_TYPE_C_PORT);
            }
#endif  // End of #if((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_P1_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P1_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_P1_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P1_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_P1_TYPE_C_PORT));

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_P1_TYPE_C_PORT, enumSwitch);
#endif

#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_P1_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P1_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P1_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_P1_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P1_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_P1_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P1_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_P1_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_P1_TYPE_C_PORT);
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P1_TYPE_C_PORT);
            }
#endif  // End of #if((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_P2_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P2_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_P2_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P2_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_P2_TYPE_C_PORT));

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_P2_TYPE_C_PORT, enumSwitch);
#endif

#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_P2_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P2_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P2_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_P2_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P2_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_P2_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P2_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_P2_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_P2_TYPE_C_PORT);
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P2_TYPE_C_PORT);
            }
#endif  // End of #if((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_P3_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P3_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_P3_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P3_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_P3_TYPE_C_PORT));

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_P3_TYPE_C_PORT, enumSwitch);
#endif

#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_P3_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P3_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P3_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_P3_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P3_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_P3_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P3_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_P3_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_P3_TYPE_C_PORT);
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P3_TYPE_C_PORT);
            }
#endif  // End of #if((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Embedded Type-C : Update Port Ctrl. Pin Assignment
            if(SysUsbTypeCUpdatePortControllerConfig(_P4_TYPE_C_PORT) != _SUCCESS)
            {
                DebugMessageTypeC("8. [TYPE C] ==========x Power Switch, Update Embedded Type-C Config Fail ! ! !", enumSwitch);
            }

            // Emb Port Ctrl : Current Pin Assignment = Target Pin Assignment
            SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P4_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(_P4_TYPE_C_PORT));

            // Emb Port Ctrl : Current Multi-Function Status = Target Multi-Function Status
            SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P4_TYPE_C_PORT, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(_P4_TYPE_C_PORT));

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmPowerSwitch(_P4_TYPE_C_PORT, enumSwitch);
#endif

#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            if(UserCommonUsbTypeCGetPowerOnReconnectStatus(_P4_TYPE_C_PORT, enumSwitch) == _TYPE_C_PORT_CTRL_RECONNECT)
            {
                SET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P4_TYPE_C_PORT);

                // RTS/User Port Ctrl : Set Current Pin Assignment Cap From User
                SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P4_TYPE_C_PORT, UserCommonUsbTypeCGetPinAssignmentConfig(_P4_TYPE_C_PORT));

                // RTS/User Port Ctrl : Set Current Multi-Function Status From User
                SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(_P4_TYPE_C_PORT, UserCommonUsbTypeCGetMultiFuncConfig(_P4_TYPE_C_PORT, GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(_P4_TYPE_C_PORT)));

                SET_USB_TYPE_C_CAPABILITY_CHG(_P4_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
                UserCommonUsbTypeCRtsClrI2CEnabledFlag(_P4_TYPE_C_PORT);
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

                CLR_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P4_TYPE_C_PORT);
            }
#endif  // End of #if((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // RTS Port Ctrl  : Clr I2C Communication Enabled Flag
            UserCommonUsbTypeCRtsClrI2CEnabledFlag(_ADAPTOR_TYPE_C_PORT);
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
            ScalerTypeCPowerSwitch(enumSwitch);
#endif

            DebugMessageTypeC("8. [TYPE C] ==========> Power Switch, Set Cap Change ! ! !", enumSwitch);

            break;

        case _POWER_ACTION_PS_TO_OFF:
        case _POWER_ACTION_NORMAL_TO_OFF:
        case _POWER_ACTION_NORMAL_TO_PS:

#if((_PORT_CTRL_RTS_SUPPORT == _ON) || (_PORT_CTRL_RTD_SUPPORT == _ON) || (_PORT_CTRL_USER_SERIES_SUPPORT == _ON))
            // Ext Port Controller Power Control
            UserInterfaceUsbTypeCPowerControl(enumSwitch);
#elif(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
            ScalerTypeCPowerSwitch(enumSwitch);
#endif

            break;

        case _POWER_ACTION_NORMAL_TO_FAKE_OFF:

#if((_PORT_CTRL_RTS_SUPPORT == _ON) || (_PORT_CTRL_RTD_SUPPORT == _ON) || (_PORT_CTRL_USER_SERIES_SUPPORT == _ON))
            // Ext Port Controller Power Control
            UserInterfaceUsbTypeCPowerControl(_POWER_ACTION_NORMAL_TO_OFF);
#elif(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
            ScalerTypeCPowerSwitch(enumSwitch);
#endif

            break;

        case _POWER_ACTION_NORMAL_TO_FAKE_PS:

#if((_PORT_CTRL_RTS_SUPPORT == _ON) || (_PORT_CTRL_RTD_SUPPORT == _ON) || (_PORT_CTRL_USER_SERIES_SUPPORT == _ON))
            // Ext Port Controller Power Control
            UserInterfaceUsbTypeCPowerControl(_POWER_ACTION_NORMAL_TO_PS);
#elif(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
            ScalerTypeCPowerSwitch(enumSwitch);
#endif

            break;

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type-C Handler Used to Sync Port Controller and Scaler
// Input Value  : enumTypeCPcbPort --> TypeC Port on PCB
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCHandler(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Execute Port Controller Proc
    SysUsbTypeCPortCtrlProc(enumTypeCPcbPort);

    switch(GET_USB_TYPE_C_STATE(enumTypeCPcbPort))
    {
        case _USB_TYPE_C_UNATTACH_STATE:

            // Check if CC Attached
            if((GET_USB_TYPE_C_CONNECTION_DET(enumTypeCPcbPort) == _TRUE) && (SysUsbTypeCGetPortControllerCcAttach(enumTypeCPcbPort) == _TYPE_C_ATTACH))
            {
                DebugMessageTypeC("8. [TYPE C] <Step 1/2> CC Attach, Alt Mode Not Ready", _USB_TYPE_C_UNATTACH_STATE);

                // 1. Set Scaler Level Attach Status Macro
                ScalerTypeCSetCcAttach(enumTypeCPcbPort, _TYPE_C_ATTACH);

                // 2. Get TypeC Orientation and Set to Macro
                SysUsbTypeCSetOrientation(enumTypeCPcbPort, SysUsbTypeCGetPortControllerOrientation(enumTypeCPcbPort));

                // 3. Switch to ATTACH State
                SET_USB_TYPE_C_STATE(enumTypeCPcbPort, _USB_TYPE_C_ATTACHED_STATE);
            }
            else
            {
                // Specific Capability Change Proc
                SysUsbTypeCCapabilityChangeProc(enumTypeCPcbPort, (_TYPE_C_POWER_CHG_TO_OFF | _TYPE_C_POWER_CHG_TO_ON | _TYPE_C_CC_FUNC_CHG_ENABLE | _TYPE_C_CC_FUNC_CHG_DISABLE | _TYPE_C_POWER_DIRECTION_CHG_TO_SRC | _TYPE_C_POWER_DIRECTION_CHG_TO_SNK | _TYPE_C_STATUS_EVENT_CHG | _TYPE_C_UPDATE_SRC_CAP));
            }

            break;

        case _USB_TYPE_C_ATTACHED_STATE:

            // Check if CC Attached
            if(SysUsbTypeCGetPortControllerCcAttach(enumTypeCPcbPort) == _TYPE_C_ATTACH)
            {
                // Get TypeC Explicit Contract and Set to Macro
                SysUsbTypeCSetExplicitContract(enumTypeCPcbPort, SysUsbTypeCGetPortControllerExplicitContract(enumTypeCPcbPort));

                // Check if PD Has Entered DP Alt. Mode (Wait For PD Power Contract / Swap / Alt Mode Flow)
                if(SysUsbTypeCGetPortControllerAltModeReady(enumTypeCPcbPort) == _TYPE_C_ALT_MODE_READY)
                {
                    // Set Explicit Contract = True to Scaler Layer Macro
                    SysUsbTypeCSetExplicitContract(enumTypeCPcbPort, _TRUE);

                    if(GET_USB_TYPE_C_ORIENTATION(enumTypeCPcbPort) == _TYPE_C_ORIENTATION_NONE)
                    {
                        // 1. Get TypeC Orientation and Set to Macro
                        SysUsbTypeCSetOrientation(enumTypeCPcbPort, SysUsbTypeCGetPortControllerOrientation(enumTypeCPcbPort));
                    }

                    // 2. Get Alt. Mode Pin Assignment and Proc Related Setting (Lane Mapping or Swap)
                    if((GET_USB_TYPE_C_ORIENTATION(enumTypeCPcbPort) != _TYPE_C_ORIENTATION_NONE) && (SysUsbTypeCGetPortControllerPinAssignment(enumTypeCPcbPort) == _SUCCESS))
                    {
                        SysUsbTypeCUpdateDisplayConfig(enumTypeCPcbPort);

                        DebugMessageTypeC("8. [TYPE C] <Step 2/2> Alt Mode Ready", _USB_TYPE_C_ATTACHED_STATE);

                        SET_USB_TYPE_C_STATE(enumTypeCPcbPort, _USB_TYPE_C_DP_ALT_MODE_READY_STATE);
                    }

                    // Get Cable Info For DPCD and Set to Macro
                    ScalerTypeCSetCableInfoForDpcd(enumTypeCPcbPort, SysUsbTypeCGetPortControllerCableInfoForDpcd(enumTypeCPcbPort));
                }
                else
                {
                    // Specific Capability Change Proc
                    SysUsbTypeCCapabilityChangeProc(enumTypeCPcbPort, (_TYPE_C_POWER_CHG_TO_OFF | _TYPE_C_CC_FUNC_CHG_ENABLE | _TYPE_C_CC_FUNC_CHG_DISABLE | _TYPE_C_POWER_DIRECTION_CHG_TO_SRC | _TYPE_C_POWER_DIRECTION_CHG_TO_SNK | _TYPE_C_SEND_SRC_CAP | _TYPE_C_ALERT_EVENT_CHG | _TYPE_C_STATUS_EVENT_CHG | _TYPE_C_UPDATE_SRC_CAP | _TYPE_C_SEND_GET_STATUS_MSG));

                    // Specific User Event Proc
                    SysUsbTypeCUserEventProc(enumTypeCPcbPort, _TYPE_C_USER_EVENT_SEND_HARD_RESET);
                }
            }
            else
            {
                // Swtich State to Unattach
                SysUsbTypeCUnattachReset(enumTypeCPcbPort);
                SET_USB_TYPE_C_STATE(enumTypeCPcbPort, _USB_TYPE_C_UNATTACH_STATE);

                DebugMessageTypeC("8. [TYPE C] <Step 0/2> CC Unattach", _USB_TYPE_C_ATTACHED_STATE);
            }

            break;

        case _USB_TYPE_C_DP_ALT_MODE_READY_STATE:

            // Check if CC Attached
            if(SysUsbTypeCGetPortControllerCcAttach(enumTypeCPcbPort) == _TYPE_C_ATTACH)
            {
                // Check Whether Pin Assignment Capability Has Been Changeed or Not
                if(SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG) == _TRUE)
                {
                    DebugMessageTypeC("8. [TYPE C] ==========> Check Pin Assignment Capablity Change. . .", _USB_TYPE_C_DP_ALT_MODE_READY_STATE);
                    SysUsbTypeCPinAssignmentCapabilityChangeProc(enumTypeCPcbPort);
                }
                else
                {
                    // 1. Check if Still in DP Alt Mode or Whether Multi-Function Bit Change Done
                    if((SysUsbTypeCGetPortControllerAltModeReady(enumTypeCPcbPort) != _TYPE_C_ALT_MODE_READY) || (SysUsbTypeCGetPortControllerMultiFunctionChangeDone(enumTypeCPcbPort) == _TRUE))
                    {
                        StructTypeCCableInfoForDpcd stTypeCCableInfoForDpcd = {_PD_CBL_COMPONENT_PASSIVE, _PD_CBL_MAX_DP_RATE_UNCONFIRMED, _FALSE};

                        // Reset Cable Info / Pin Assignment and Update Display Config
                        ScalerTypeCSetCableInfoForDpcd(enumTypeCPcbPort, stTypeCCableInfoForDpcd);
                        SysUsbTypeCSetPinAssignment(enumTypeCPcbPort, _TYPE_C_PIN_ASSIGNMENT_NONE);
                        SysUsbTypeCUpdateDisplayConfig(enumTypeCPcbPort);

                        DebugMessageTypeC("8. [TYPE C] <Step 1/2> CC Attach, Alt Mode Not Ready", _USB_TYPE_C_DP_ALT_MODE_READY_STATE);

                        // Case1: Config Lane Mapping to USB + DP Mode, and Back to Attached State to Wait for Alt. Mode Ready
                        // Case2: if Multi-Function Bit Change, Pin Assignment C <=> Pin Assignment D Occurs, Creating DPAM Not Ready State(One Loop) for DP/USB Reset Flow
                        SET_USB_TYPE_C_STATE(enumTypeCPcbPort, _USB_TYPE_C_ATTACHED_STATE);
                    }

                    // 2. Specific Capability Change Proc
                    SysUsbTypeCCapabilityChangeProc(enumTypeCPcbPort, (_TYPE_C_POWER_CHG_TO_OFF | _TYPE_C_CC_FUNC_CHG_ENABLE | _TYPE_C_CC_FUNC_CHG_DISABLE | _TYPE_C_POWER_DIRECTION_CHG_TO_SRC | _TYPE_C_POWER_DIRECTION_CHG_TO_SNK | _TYPE_C_SEND_SRC_CAP | _TYPE_C_ALERT_EVENT_CHG | _TYPE_C_STATUS_EVENT_CHG | _TYPE_C_UPDATE_SRC_CAP | _TYPE_C_SEND_GET_STATUS_MSG));

                    // Specific User Event Proc
                    SysUsbTypeCUserEventProc(enumTypeCPcbPort, _TYPE_C_USER_EVENT_SEND_HARD_RESET);
                }
            }
            else
            {
                // Swtich State to Unattach
                SysUsbTypeCUnattachReset(enumTypeCPcbPort);
                SET_USB_TYPE_C_STATE(enumTypeCPcbPort, _USB_TYPE_C_UNATTACH_STATE);

                DebugMessageTypeC("8. [TYPE C] <Step 0/2> CC Unattach", _USB_TYPE_C_DP_ALT_MODE_READY_STATE);
            }

            break;

        default:

            // Error Handling ?????

            break;
    }

    if(GET_USB_TYPE_C_STATE(enumTypeCPcbPort) > _USB_TYPE_C_UNATTACH_STATE)
    {
        // Check Reconnect Flag
        if(GET_USB_TYPE_C_RECONNECT(enumTypeCPcbPort) == _TRUE)
        {
            if(SysUsbTypeCReconnect(enumTypeCPcbPort) == _SUCCESS)
            {
                // State Transition After Reconnect
                SysUsbTypeCRestartConnectionDet(enumTypeCPcbPort);

                // Swtich State to Unattach
                SysUsbTypeCUnattachReset(enumTypeCPcbPort);
                SET_USB_TYPE_C_STATE(enumTypeCPcbPort, _USB_TYPE_C_UNATTACH_STATE);

                DebugMessageTypeC("8. [TYPE C] <RECONNECT> Reconnect Event Triggered", enumTypeCPcbPort);
            }
        }
#if(_TYPE_C_MODAL_OPERATION_SUPPORT == _ON)
        else
        {
            SysUsbTypeCAltModeHandler(enumTypeCPcbPort);
        }
#endif
    }

    // Update CC Attach Status Change
    SysUsbTypeCCheckAttachStatusChange(enumTypeCPcbPort);

    // Update ALT Mode Ready Status Change
    SysUsbTypeCCheckAltModeReadyStatusChange(enumTypeCPcbPort);
}

//--------------------------------------------------
// Description  : Get System Mode Status For Scaler Level Usage
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUpdateSysModeStatus(void)
{
    switch(GET_MODE_STATE())
    {
        case _MODE_STATUS_INITIAL:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_INITIAL);

            break;

        case _MODE_STATUS_DISPLAY_INITIAL:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_DISPLAY_INITIAL);

            break;

        case _MODE_STATUS_DISPLAY_SETTING:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_DISPLAY_SETTING);

            break;

        case _MODE_STATUS_DISPLAY_CHECK:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_DISPLAY_CHECK);

            break;

        case _MODE_STATUS_POWER_SAVING:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_POWER_SAVING);

            break;

        case _MODE_STATUS_POWER_OFF:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_POWER_OFF);

            break;

        case _MODE_STATUS_FACTORY:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_FACTORY);

            break;

        default:

            ScalerTypeCSetSysModeStatus(_USB_SYS_MODE_STATUS_NONE);

            break;
    }
}

//--------------------------------------------------
// Description  : Return CC Attached Status to Rx Input Port
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCCheckAttachStatusChange(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Get Current Attach Status : UNATTACH_STATE => _TYPE_C_UNATTACH / _TYPE_C_ATTACHED/ALT_MODE_READY_STATE => _TYPE_C_ATTACH
    EnumTypeCAttachStatus enumCurrentAttachStatus = (GET_USB_TYPE_C_STATE(enumTypeCPcbPort) == _USB_TYPE_C_UNATTACH_STATE) ? _TYPE_C_UNATTACH : _TYPE_C_ATTACH;

    if(GET_USB_TYPE_C_ATTACH_STATUS(enumTypeCPcbPort) != enumCurrentAttachStatus)
    {
        // Set Attach Status Change
        SET_USB_TYPE_C_ATTACH_STATUS_CHG(enumTypeCPcbPort);
        SET_USB_TYPE_C_ATTACH_STATUS(enumTypeCPcbPort, enumCurrentAttachStatus);
    }
    else
    {
        // Clear Attach Status Change
        CLR_USB_TYPE_C_ATTACH_STATUS_CHG(enumTypeCPcbPort);
    }
}

//--------------------------------------------------
// Description  : Return ALT Mode Ready Status to Rx Input Port
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCCheckAltModeReadyStatusChange(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Get Current ALT Mode Status : ALT_MODE_READY_STATE => _TYPE_C_ALT_MODE_READY / _TYPE_C_UNATTACH/ATTACHED_STATE => _TYPE_C_ALT_MODE_NOT_READY
    EnumTypeCAltModeStatus enumCurrentAltModeStatus = (EnumTypeCAltModeStatus) SysUsbTypeCGetAltModeReady(enumTypeCPcbPort);

    // Set Scaler Level Alt Mode Ready Macro
    ScalerTypeCSetAltModeReady(enumTypeCPcbPort, enumCurrentAltModeStatus);

    if(GET_USB_TYPE_C_ALT_MODE_STATUS(enumTypeCPcbPort) != enumCurrentAltModeStatus)
    {
        // Set Attach Status Change
        SET_USB_TYPE_C_ALT_MODE_STATUS_CHG(enumTypeCPcbPort);
        SET_USB_TYPE_C_ALT_MODE_STATUS(enumTypeCPcbPort, enumCurrentAltModeStatus);
    }
    else
    {
        // Clear Attach Status Change
        CLR_USB_TYPE_C_ALT_MODE_STATUS_CHG(enumTypeCPcbPort);
    }
}

#if(_TYPE_C_CABLE_STATUS_CHANGE_BY_ALT_MODE_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Get ALT Mode Status Change
// Input Value  : enumTypeCPcbPort
// Output Value : _TRUE / _FALSE
//--------------------------------------------------
bit SysUsbTypeCGetAltModeStatusChange(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return GET_USB_TYPE_C_ALT_MODE_STATUS_CHG(enumTypeCPcbPort);
}
#endif

//--------------------------------------------------
// Description  : Type-C Handler Used to Check Whether the Power Status Change
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
// Output Value : _TRUE / _FALSE
//--------------------------------------------------
bit SysUsbTypeCCheckPowerStatusChange(EnumTypeCPcbPort enumTypeCPcbPort)
{
    WORD usVoltage = 0;
    WORD usCurrent = 0;
    EnumTypeCPowerRole enumTypeCPowerRole = _TYPE_C_POWER_SNK;

    // Get Port's Power Role
    enumTypeCPowerRole = SysUsbTypeCGetPowerRole(enumTypeCPcbPort);

    // Get Port's PDO Status
    SysUsbTypeCGetPdoStatus(enumTypeCPcbPort, &usVoltage, &usCurrent);

    // If any status changes
    if((GET_USB_TYPE_C_POWER_ROLE(enumTypeCPcbPort) != enumTypeCPowerRole) ||
       (GET_USB_TYPE_C_PDO_VOLTAGE(enumTypeCPcbPort) != usVoltage) ||
       (GET_USB_TYPE_C_PDO_CURRENT(enumTypeCPcbPort) != usCurrent))
    {
        // Update Status
        SET_USB_TYPE_C_POWER_ROLE(enumTypeCPcbPort, enumTypeCPowerRole);
        SET_USB_TYPE_C_PDO_VOLTAGE(enumTypeCPcbPort, usVoltage);
        SET_USB_TYPE_C_PDO_CURRENT(enumTypeCPcbPort, usCurrent);

        return _TRUE;
    }

    return _FALSE;
}

//--------------------------------------------------
// Description  : Get Local Power (Adaptor or Power Board) Status
// Input Value  : None
// Output Value : EnumTypeCLocalPowerExist (_TYPE_C_LOCAL_POWER_NOT_EXIST / _TYPE_C_LOCAL_POWER_EXIST)
//--------------------------------------------------
EnumTypeCLocalPowerExist SysUsbTypeCGetLocPowExist(void)
{
    EnumTypeCLocalPowerExist enumTypeCLocalPowerExist = _TYPE_C_LOCAL_POWER_EXIST;

#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
    // Get Local Power Status
    enumTypeCLocalPowerExist = ScalerTypeCAdcGetLocPowExist();
#endif

    return enumTypeCLocalPowerExist;
}

//--------------------------------------------------
// Description  : Get Adaptor Power Value
// Input Value  : None
// Output Value : return Local Power Value (Unit = 0.1W)
//--------------------------------------------------
WORD SysUsbTypeCGetAdaptorPower(void)
{
    EnumTypeCLocalPowerExist enumTypeCLocalPowerExist = _TYPE_C_LOCAL_POWER_EXIST;

#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
    // Get Local Power Status
    enumTypeCLocalPowerExist = ScalerTypeCAdcGetLocPowExist();
#endif

    if(enumTypeCLocalPowerExist == _TYPE_C_LOCAL_POWER_EXIST)
    {
        return UserCommonUsbTypeCGetAdaptorPower();
    }
    else
    {
        return 0;
    }
}

//--------------------------------------------------
// Description  : Set Local Power Detection Flag
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetLocalPowerDetection(void)
{
    SET_USB_TYPE_C_LOCAL_POWER_DETECT();
}

//--------------------------------------------------
// Description  : Check if Local Power (Adaptor or Power Board) Exists
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCCheckAdaptorPowerExist(void)
{
    if(GET_USB_TYPE_C_LOCAL_POWER_DETECT() == _TRUE)
    {
        // Update Local Power Status Every _TYPE_C_PORT_CTRL_LOC_PWR_DEBOUNCE_TIME (100ms / 200ms / 500ms)
        CLR_USB_TYPE_C_LOCAL_POWER_DETECT();
        ScalerTimerActiveTimerEvent(_TYPE_C_PORT_CTRL_LOC_PWR_DEBOUNCE_TIME, _SYSTEM_TIMER_EVENT_LOCAL_POWER_DETECT);
#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
#if(_LOCAL_POWER_VBUS_ADC_CHANNEL != _TYPE_C_PMIC_ADC_MAPPING_NONE)
        // Check Local Power Status
        ScalerTypeCAdcCheckLocPowExist();
#else
        ScalerTypeCAdcSetLocPowExist(UserCommonUsbTypeCGetLocalPow());
#endif
#endif
    }
}

//--------------------------------------------------
// Description  : Check Adaptor Power Changes or Not
// Input Value  : None
// Output Value : None
//--------------------------------------------------
bit SysUsbTypeCCheckAdaptorPowerChange(void)
{
    WORD usAdaptorPower = SysUsbTypeCGetAdaptorPower();

    // ========================================================
    // Check Local Power Status
    // ========================================================
    if(GET_USB_TYPE_C_ADAPTOR_POWER() != usAdaptorPower)
    {
        DebugMessageTypeC("[SPM] <Adaptor Power Changes>", 0x20);

        SET_USB_TYPE_C_ADAPTOR_POWER(usAdaptorPower);

        return _TRUE;
    }

    return _FALSE;
}

//--------------------------------------------------
// Description  : System Power Management
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSystemPowerManagement(void)
{
    bit bStatusChange = _FALSE;
    BYTE ucIndex = 0;

    // ========================================================
    // Update Local Power Status
    // ========================================================
    SysUsbTypeCCheckAdaptorPowerExist();

    // ========================================================
    // Update all ports' Unconstrained Power Status
    // ========================================================
    for(ucIndex = 0; ucIndex < (_TYPE_C_PORT_VALID - 1); ++ucIndex)
    {
        SysUsbTypeCUpdatePortCtrlUnconstrainedPow(g_penumUsbTypeCPcbPort[ucIndex]);
    }

    // ========================================================
    // Check System Power Management Operation Type
    // ========================================================
    if(UserCommonUsbTypeCSpmOperation() == _TYPE_C_SPM_FIX_DEFAULT_POWER)
    {
        return;
    }

    // ========================================================
    // Check Adaptor Status
    // ========================================================
    bStatusChange |= SysUsbTypeCCheckAdaptorPowerChange();

    // ========================================================
    // Check all ports' information: SNK/SRC, Voltage, Current
    // ========================================================
    for(ucIndex = 0; ucIndex < (_TYPE_C_PORT_VALID - 1); ++ucIndex)
    {
        bStatusChange |= SysUsbTypeCCheckPowerStatusChange(g_penumUsbTypeCPcbPort[ucIndex]);
    }

    // ========================================================
    // Check all ports' SPM Status Change Set By User
    // ========================================================
    for(ucIndex = 0; ucIndex < (_TYPE_C_PORT_VALID - 1); ++ucIndex)
    {
        bStatusChange |= SysUsbTypeCCheckCapabilityChange(g_penumUsbTypeCPcbPort[ucIndex], _TYPE_C_SPM_CAP_CHG);

        SysUsbTypeCClrCapabilityChangeFlag(g_penumUsbTypeCPcbPort[ucIndex], _TYPE_C_SPM_CAP_CHG);
    }

    // ===============================
    // Update all ports' information
    // ===============================
    if(bStatusChange == _TRUE)
    {
        // Start System Power Management
        UserCommonUsbTypeCSystemPowerManagement();

        // Allocate Power to each port
        for(ucIndex = 0; ucIndex < (_TYPE_C_PORT_VALID - 1); ++ucIndex)
        {
            // 1. Check if PDO changes or not
            if(SysUsbTypeCUpdatePortCtrlSrcPdo(g_penumUsbTypeCPcbPort[ucIndex]) == _TYPE_C_PDO_CHANGE)
            {
                DebugMessageTypeC("[SPM] <PDO Changes>", g_penumUsbTypeCPcbPort[ucIndex]);

                // 2. Request Port Ctrl to Re-Send Source Capability Message
                SysUsbTypeCSendSrcCapability(g_penumUsbTypeCPcbPort[ucIndex]);
            }
        }
    }
}

//--------------------------------------------------
// Description  : Check Source PDO Change
// Input Value  : enumTypeCPcbPort, ucPdoIndex, stTypeCUserPdo
// Output Value : EnumPdoCheck
//--------------------------------------------------
void SysUsbTypeCCheckSrcPdoChange(EnumTypeCPcbPort enumTypeCPcbPort, BYTE ucPdoIndex, StructTypeCUserPDO stTypeCUserPdo)
{
    StructTypeCUserPDO stTypeCSrcPdo = {_PD_FIX_SUPPLY_PDO , _PD_PEAK_CUR_NONE , 0x00 , 0x00 , 0x00};

    if(GET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort) == _TRUE)
    {
        return;
    }

    // Get Current Src PDO Info
    stTypeCSrcPdo = SysUsbTypeCGetPortControllerPdo(enumTypeCPcbPort, _TYPE_C_POWER_SRC, ucPdoIndex);

    // Check if PDO Content Change
    if(stTypeCSrcPdo.enumPdoType != stTypeCUserPdo.enumPdoType)
    {
        SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
        return;
    }

    if(stTypeCSrcPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
    {
        if(stTypeCSrcPdo.enumPeakCurrent != stTypeCUserPdo.enumPeakCurrent)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }

        if(stTypeCSrcPdo.usMaxVoltage != stTypeCUserPdo.usMaxVoltage)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }

        if(stTypeCSrcPdo.usMaxCurrent != stTypeCUserPdo.usMaxCurrent)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }
    }
    else if(stTypeCSrcPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
    {
        if(stTypeCSrcPdo.usMaxVoltage != stTypeCUserPdo.usMaxVoltage)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }

        if(stTypeCSrcPdo.usMinVoltage != stTypeCUserPdo.usMinVoltage)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }

        if(stTypeCSrcPdo.usMaxCurrent != stTypeCUserPdo.usMaxCurrent)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }
    }
    else if(stTypeCSrcPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
    {
        if(stTypeCSrcPdo.enumPeakCurrent != stTypeCUserPdo.enumPeakCurrent)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }

        if(stTypeCSrcPdo.usMaxVoltage != stTypeCUserPdo.usMaxVoltage)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }

        if(stTypeCSrcPdo.usMinVoltage != stTypeCUserPdo.usMinVoltage)
        {
            SET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
            return;
        }
    }
}

//--------------------------------------------------
// Description  : Initial State Set Up Port Ctrl Source Capability
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
EnumPdoCheck SysUsbTypeCUpdatePortCtrlSrcPdo(EnumTypeCPcbPort enumTypeCPcbPort)
{
    BYTE ucSPRPdoCount = 0;
    BYTE ucEPRPdoCount = 0;
    BYTE ucPdoIndex = 0;
    StructTypeCUserPDO stTypeCUserPdo = {_PD_FIX_SUPPLY_PDO , _PD_PEAK_CUR_NONE , 0x00 , 0x00 , 0x00};
    StructTypeCVbusProtectInfo stTypeCVbusProtectInfo = {0x00};

    ucSPRPdoCount = ucSPRPdoCount;
    ucEPRPdoCount = ucEPRPdoCount;
    ucPdoIndex = ucPdoIndex;
    stTypeCUserPdo = stTypeCUserPdo;
    stTypeCVbusProtectInfo = stTypeCVbusProtectInfo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_D0_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_D0_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_D0_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D0_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D0_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D0_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_D0_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D0_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_D0_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_D0_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_D0_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_D0_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_D0_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_D0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_D1_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_D1_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_D1_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D1_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D1_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D1_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_D1_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D1_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_D1_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_D1_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_D1_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_D1_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_D1_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_D1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_D2_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_D2_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_D2_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D2_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D2_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D2_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_D2_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_D2_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_D2_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_D2_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_D2_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_D2_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_D2_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_D2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_P0_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_P0_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_P0_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P0_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P0_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P0_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_P0_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P0_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_P0_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_P0_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P0_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_P0_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P0_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P0_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_P1_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_P1_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_P1_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P1_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P1_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P1_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_P1_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P1_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_P1_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_P1_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P1_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_P1_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P1_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P1_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_P2_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_P2_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_P2_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P2_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P2_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P2_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_P2_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P2_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_P2_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_P2_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P2_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_P2_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P2_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P2_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_P3_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_P3_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_P3_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P3_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P3_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P3_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_P3_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P3_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_P3_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_P3_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P3_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_P3_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P3_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P3_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC) == _TYPE_C_PDO_FROM_USER)
            {
                // Clear PDO Change Status Macro
                CLR_USB_TYPE_C_PDO_CHG_STATUS(_P4_TYPE_C_PORT);

                // 2. Get Max Power [Unit = 0.1 W]
                SysUsbTypeCSetPortControllerMaxPower(_P4_TYPE_C_PORT, UserCommonUsbTypeCGetMaxPower(_P4_TYPE_C_PORT));

                // 3 Get Total Number of SPR PDO (Enumeration Range 1 ~ 7) and EPR PDO (Enumeration Range 0 ~ 4)
                UserCommonUsbTypeCGetPdoCount(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P4_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P4_TYPE_C_PORT, ucSPRPdoCount);
                }

                if(GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P4_TYPE_C_PORT) != SysUsbTypeCGetPortControllerPdoCnt(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC))
                {
                    SET_USB_TYPE_C_PDO_CHG_STATUS(_P4_TYPE_C_PORT);
                }

                // Update Total Number of PDO to Port Controller
                SysUsbTypeCSetPortControllerPdoCnt(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucSPRPdoCount, ucEPRPdoCount);

                // 4. Get SPR and EPR PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SRC_PDO_CNT(_P4_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 11th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, &stTypeCUserPdo);

                    SysUsbTypeCCheckSrcPdoChange(_P4_TYPE_C_PORT, ucPdoIndex, stTypeCUserPdo);

                    if(GET_USB_TYPE_C_PDO_CHG_STATUS(_P4_TYPE_C_PORT) == _TRUE)
                    {
                        SysUsbTypeCSetPortControllerPdo(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC, ucPdoIndex, stTypeCUserPdo);
                    }

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (PDP = 27W / 5V@3A + 9V@3A)
                SysUsbTypeCSetPortControllerPdoByKernel(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC);
            }

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCGetPdoCnt(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P4_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCSetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Get Vbus Protect Info, and Update to Kernel
            ScalerTypeCTcpmGetPdoCnt(_P4_TYPE_C_PORT, _TYPE_C_POWER_SRC, &ucSPRPdoCount, &ucEPRPdoCount);

            for(ucPdoIndex = 1; ucPdoIndex <= ucSPRPdoCount; ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }

#if(_P4_TYPE_C_EMB_PD3_1_EPR_SUPPORT == _ON)
            for(ucPdoIndex = 8; ucPdoIndex <= (7 + ucEPRPdoCount); ucPdoIndex++)
            {
                UserCommonUsbTypeCEmbeddedGetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, &stTypeCVbusProtectInfo);
                ScalerTypeCTcpmSetVbusProtectInfo(_P4_TYPE_C_PORT, ucPdoIndex, stTypeCVbusProtectInfo);
            }
#endif
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    // Clear Update Source Capability Flag
    SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_UPDATE_SRC_CAP);

    return (EnumPdoCheck) GET_USB_TYPE_C_PDO_CHG_STATUS(enumTypeCPcbPort);
}

//--------------------------------------------------
// Description  : Initial State Set Up Port Ctrl Sink Capability
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUpdatePortCtrlSnkPdo(EnumTypeCPcbPort enumTypeCPcbPort)
{
    BYTE ucSPRPdoCount = 0;
    BYTE ucEPRPdoCount = 0;
    BYTE ucPdoIndex = 0;
    StructTypeCUserPDO stTypeCUserPdo = {_PD_FIX_SUPPLY_PDO , _PD_PEAK_CUR_NONE , 0x00 , 0x00 , 0x00};
    StructTypeCSnkInfo stTypeCSnkInfo = {0x00 , 0x00 , 0x00};

    ucSPRPdoCount = ucSPRPdoCount;
    ucEPRPdoCount = ucEPRPdoCount;
    ucPdoIndex = ucPdoIndex;
    stTypeCUserPdo = stTypeCUserPdo;
    stTypeCSnkInfo = stTypeCSnkInfo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_D0_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_D0_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_D0_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_D0_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_D0_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D0_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D0_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D0_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_D0_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_D0_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== SNK PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Sink  PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_D0_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_D1_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_D1_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_D1_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_D1_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_D1_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D1_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D1_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D1_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_D1_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_D1_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_D1_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_D2_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_D2_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_D2_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_D2_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_D2_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D2_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D2_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_D2_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_D2_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_D2_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_D2_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P0_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_P0_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_P0_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_P0_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_P0_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P0_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P0_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P0_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P0_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_P0_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_P0_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P1_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_P1_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_P1_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_P1_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_P1_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P1_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P1_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P1_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P1_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_P1_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_P1_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P2_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_P2_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_P2_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_P2_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_P2_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P2_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P2_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P2_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P2_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_P2_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_P2_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P3_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_P3_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_P3_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_P3_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_P3_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P3_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P3_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P3_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P3_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_P3_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_P3_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_P4_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_P4_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_P4_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_P4_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_P4_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P4_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P4_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_P4_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_P4_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_P4_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_P4_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCPdoReference(_ADAPTOR_TYPE_C_PORT, _TYPE_C_POWER_SNK) == _TYPE_C_PDO_FROM_USER)
            {
                // 2. Get Sink Info from User
                UserCommonUsbTypeCGetSnkInfo(_ADAPTOR_TYPE_C_PORT, &stTypeCSnkInfo);
                SysUsbTypeCSetPortControllerSnkInfo(_ADAPTOR_TYPE_C_PORT, stTypeCSnkInfo);

                // 3. Get Sink PDO Count from User
                UserCommonUsbTypeCGetPdoCount(_ADAPTOR_TYPE_C_PORT, _TYPE_C_POWER_SNK, &ucSPRPdoCount, &ucEPRPdoCount);
                SysUsbTypeCSetPortControllerPdoCnt(_ADAPTOR_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucSPRPdoCount, ucEPRPdoCount);

                if(ucEPRPdoCount != 0)
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_ADAPTOR_TYPE_C_PORT, (7 + ucEPRPdoCount));
                }
                else
                {
                    SET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_ADAPTOR_TYPE_C_PORT, ucSPRPdoCount);
                }

                // 4. Get PDO Info and Write to Port Controller
                for(ucPdoIndex = 1; ucPdoIndex <= GET_USB_TYPE_C_TOTAL_SNK_PDO_CNT(_ADAPTOR_TYPE_C_PORT); ucPdoIndex++)
                {
                    // Get User 1st - 7th PDO Info, and Update to Port Controller
                    UserCommonUsbTypeCGetPdoInfo(_ADAPTOR_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, &stTypeCUserPdo);
                    SysUsbTypeCSetPortControllerPdo(_ADAPTOR_TYPE_C_PORT, _TYPE_C_POWER_SNK, ucPdoIndex, stTypeCUserPdo);

                    // Debug Message
                    DebugMessageTypeC("8. [TYPE C] <PDO> ======== Sink PDO Num ========", ucPdoIndex);
                    DebugMessageTypeC("8. [TYPE C] <PDO> Voltage (1V)", (stTypeCUserPdo.usMaxVoltage / 10));
                    DebugMessageTypeC("8. [TYPE C] <PDO> Current (0.01A)", stTypeCUserPdo.usMaxCurrent);
                }
            }
            else
            {
                // Source PDO Defined By Kernel (5V @ 500mA)
                SysUsbTypeCSetPortControllerPdoByKernel(_ADAPTOR_TYPE_C_PORT, _TYPE_C_POWER_SNK);
            }

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set Content of Port Ctrl Initial Request When There is No Contract
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUpdatePortCtrlInitRdo(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Default Initial Request
    StructTypeCUserInitRDO stTypeCInitUserRdo = {_TYPE_C_REQ_CUSTOMIZED_RDO, _TYPE_C_RDO_NO_TARGET};

    // Default Request 5V @ 500mA
    StructTypeCUserRDO stTypeCUserRdo = {_TYPE_C_PDO_NUM_1, 50, 50, _FALSE, _FALSE};

    stTypeCInitUserRdo = stTypeCInitUserRdo;
    stTypeCUserRdo = stTypeCUserRdo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_D0_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_D0_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_D0_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_D0_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_D1_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_D1_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_D1_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_D1_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_D2_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_D2_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_D2_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_D2_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P0_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_P0_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_P0_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_P0_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P1_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_P1_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_P1_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_P1_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P2_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_P2_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_P2_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_P2_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P3_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_P3_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_P3_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_P3_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P4_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_P4_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_P4_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_P4_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)) && (_TYPE_C_POWER_SOURCE == _TYPE_C_VBUS_POWER_ONLY))
            // Default Initial Request for Vbus Powered Sink
            stTypeCInitUserRdo.enumReqType = _TYPE_C_REQ_TARGET_VOL;
            stTypeCInitUserRdo.enumTargetVolRDO = _TYPE_C_RDO_5_1V;
#endif

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_ADAPTOR_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Initial Request Info
                UserCommonUsbTypeCGetInitRdoInfo(_ADAPTOR_TYPE_C_PORT, &stTypeCInitUserRdo);
            }

            if(stTypeCInitUserRdo.enumReqType == _TYPE_C_REQ_CUSTOMIZED_RDO)
            {
                // Set Default Request Info to Port Ctrl, 5V @ 500mA
                SysUsbTypeCSetPortControllerRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserRdo);
            }
            else
            {
                // Set Initial Request Info to Port Ctrl
                SysUsbTypeCSetPortControllerInitRdo(_ADAPTOR_TYPE_C_PORT, stTypeCInitUserRdo);
            }

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:
            break;
    }

    // Debug Message
    DebugMessageTypeC("8. [TYPE C] <Initial RDO> Set Initial RDO For TypeC Port : ", enumTypeCPcbPort);
    DebugMessageTypeC("8. [TYPE C] <Initial RDO> Request Type =", stTypeCInitUserRdo.enumReqType);
    DebugMessageTypeC("8. [TYPE C] <Initial RDO> Target Voltage for Type-C RDO =", stTypeCInitUserRdo.enumTargetVolRDO);
}

//--------------------------------------------------
// Description  : Set Content of Port Ctrl Request When Receive Src Cap
// Input Value  : ucInputPort --> Inputput
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUpdatePortCtrlRdo(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Default Request 5V @ 500mA
    StructTypeCUserRDO stTypeCUserRdo = {_TYPE_C_PDO_NUM_1, 50, 50, _FALSE, _FALSE};
    stTypeCUserRdo = stTypeCUserRdo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_D0_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_D0_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_D0_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_D1_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_D1_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_D1_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_D2_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_D2_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_D2_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P0_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_P0_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_P0_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P1_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_P1_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_P1_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P2_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_P2_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_P2_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P3_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_P3_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_P3_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_P4_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_P4_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_P4_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // 1. Get PDO Info From User / Kernel
            if(UserCommonUsbTypeCRdoReference(_ADAPTOR_TYPE_C_PORT) == _TYPE_C_RDO_FROM_USER)
            {
                // Get User Request Info
                UserCommonUsbTypeCGetRdoInfo(_ADAPTOR_TYPE_C_PORT, &stTypeCUserRdo);
            }

            // Set Request Info to Port Ctrl
            SysUsbTypeCSetPortControllerRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserRdo);

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:
            break;
    }

    // Debug Message
    DebugMessageTypeC("8. [TYPE C] <RDO> Set RDO For TypeC Port : ", enumTypeCPcbPort);
    DebugMessageTypeC("8. [TYPE C] <RDO> Object Position =", stTypeCUserRdo.enumObjPos);
    DebugMessageTypeC("8. [TYPE C] <RDO> Info1 (Fix PDO = Op Cur in 10mA / PPS PDO = Vol in 20mV)", stTypeCUserRdo.usReqInfo1);
    DebugMessageTypeC("8. [TYPE C] <RDO> Info2 (Fix PDO = Max Cur in 10mA / PPS PDO = Op. Cur in 50mA)", stTypeCUserRdo.usReqInfo2);
}

//--------------------------------------------------
// Description  : Type C Update Unconstrainted Power Status
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUpdatePortCtrlUnconstrainedPow(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_D0_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_D0_TYPE_C_PORT));
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_D0_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_D0_TYPE_C_PORT));
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_D1_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_D1_TYPE_C_PORT));
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_D1_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_D1_TYPE_C_PORT));
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_D2_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_D2_TYPE_C_PORT));
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_D2_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_D2_TYPE_C_PORT));
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_P0_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P0_TYPE_C_PORT));
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_P0_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P0_TYPE_C_PORT));
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_P1_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P1_TYPE_C_PORT));
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_P1_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P1_TYPE_C_PORT));
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_P2_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P2_TYPE_C_PORT));
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_P2_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P2_TYPE_C_PORT));
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_P3_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P3_TYPE_C_PORT));
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_P3_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P3_TYPE_C_PORT));
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_P4_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P4_TYPE_C_PORT));
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_P4_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_P4_TYPE_C_PORT));
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetUnconstrainedPow(_ADAPTOR_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_ADAPTOR_TYPE_C_PORT));
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetUnconstrainedPow(_ADAPTOR_TYPE_C_PORT, UserCommonUsbTypeCGetUnconstrainedPow(_ADAPTOR_TYPE_C_PORT));
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetUnconstrainedPow(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetUnconstrainedPow(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Get Default Type-C Operation Mode From PCB Define
// Input Value  : enumTypeCPcbPort
// Output Value : Type-C Operation Mode (_TYPE_C_SRC_ONLY_MODE / _TYPE_C_SNK_ONLY_MODE / _TYPE_C_DRP_NO_PREFERENCE_MODE...)
//--------------------------------------------------
EnumTypeCOperationMode SysUsbTypeCGetDefaultOperationMode(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCOperationMode enumOperationMode = _TYPE_C_DEFAULT_OPERATION_MODE;
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_D0_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_D0_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_D0_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_D0_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_D1_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_D1_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_D1_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_D1_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_D2_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_D2_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_D2_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_D2_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_P0_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_P0_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_P0_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_P0_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_P1_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_P1_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_P1_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_P1_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_P2_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_P2_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_P2_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_P2_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_P3_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_P3_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_P3_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_P3_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_P4_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_P4_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_P4_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_P4_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
#if(_ADAPTOR_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SRC_ONLY)
            enumOperationMode = _TYPE_C_SRC_ONLY_MODE;
#elif(_ADAPTOR_TYPE_C_EMB_PORT_ROLE == _TYPE_C_PORT_SNK_ONLY)
            enumOperationMode = _TYPE_C_SNK_ONLY_MODE;
#else
#if(_ADAPTOR_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_NO_PREFERENCE)
            enumOperationMode = _TYPE_C_DRP_NO_PREFERENCE_MODE;
#elif(_ADAPTOR_TYPE_C_EMB_DRP_PREFER == _TYPE_C_DRP_TRY_SNK)
            enumOperationMode = _TYPE_C_DRP_TRY_SNK_MODE;
#else
            enumOperationMode = _TYPE_C_DRP_TRY_SRC_MODE;
#endif
#endif
#endif  // End of #if((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumOperationMode;
}

//--------------------------------------------------
// Description  : Run Port Controller Proc
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCPortCtrlProc(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_D0_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_D0_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_D1_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_D1_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_D2_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_D2_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_P0_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_P0_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_P1_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_P1_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_P2_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_P2_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_P3_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_P3_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_P4_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_P4_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_D4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)


#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // For Embedded Type-C, Run PD/CC Proc
            ScalerTypeCHandler(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // For TCPM, Run PD/CC Port Manager Flow
            ScalerTypeCTcpmHandler(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // For RTS, Update Status (Including Power Role, Data Role and PDO Info)
            UserCommonUsbTypeCRtsUpdateStatus(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // For RTD, Update Status when Connection Det is TRUE
            if(GET_USB_TYPE_C_CONNECTION_DET(_ADAPTOR_TYPE_C_PORT) == _TRUE)
            {
                UserCommonUsbTypeCRtdUpdateStatus(_ADAPTOR_TYPE_C_PORT);
            }
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Get Port Controller CC Attached Info
// Input Value  : enumTypeCPcbPort
// Output Value : CC Attach Status (_TYPE_C_ATTACH / _TYPE_C_UNATTACH)
//--------------------------------------------------
EnumTypeCAttachStatus SysUsbTypeCGetPortControllerCcAttach(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCAttachStatus enumAttachStatus = _TYPE_C_UNATTACH;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAttachStatus = ScalerTypeCGetCcAttach(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAttachStatus = ScalerTypeCTcpmGetCcAttach(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAttachStatus = UserCommonUsbTypeCGetCcAttach(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumAttachStatus = _TYPE_C_UNATTACH;

            break;
    }
    return enumAttachStatus;
}

//--------------------------------------------------
// Description  : Get Port Controller Orientation Info and Store in Macro
// Input Value  : enumTypeCPcbPort
// Output Value : EnumTypeCOrientation
//--------------------------------------------------
EnumTypeCOrientation SysUsbTypeCGetPortControllerOrientation(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCOrientation enumOrientation = _TYPE_C_ORIENTATION_NONE;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // Get Orientation Info
#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_D0_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_D0_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_D0_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_D0_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // Get Orientation Info
#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_D1_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_D1_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_D1_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_D1_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // Get Orientation Info
#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_D2_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_D2_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_D2_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_D2_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // Get Orientation Info
#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_P0_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_P0_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_P0_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_P0_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // Get Orientation Info
#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_P1_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_P1_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_P1_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_P1_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // Get Orientation Info
#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_P2_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_P2_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_P2_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_P2_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // Get Orientation Info
#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_P3_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_P3_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_P3_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_P3_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // Get Orientation Info
#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_P4_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_P4_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_P4_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_P4_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Get Orientation Info
#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumOrientation = ScalerTypeCGetOrientation(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumOrientation = ScalerTypeCTcpmGetOrientation(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_ADAPTOR_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtsGetOrientation(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) && (_ADAPTOR_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCRtdGetOrientation(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER) && (_ADAPTOR_TYPE_C_EXT_LANE_SWAP_FOR_ORIENTATION == _SWAP_BY_SCALER))
            enumOrientation = UserCommonUsbTypeCUserGetOrientation(_ADAPTOR_TYPE_C_PORT);
#else
            enumOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumOrientation;
}

//--------------------------------------------------
// Description  : Get Port Controller DP Alt. Mode Ready Info
// Input Value  : enumTypeCPcbPort
// Output Value : DP Alt Mode Ready Status (_TYPE_C_ALT_MODE_READY / _TYPE_C_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCAltModeStatus SysUsbTypeCGetPortControllerAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCAltModeStatus enumAltModeStatus = _TYPE_C_ALT_MODE_NOT_READY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAltModeStatus = ScalerTypeCGetAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumAltModeStatus = ScalerTypeCTcpmGetAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            enumAltModeStatus = UserCommonUsbTypeCGetAltModeReady(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumAltModeStatus = _TYPE_C_ALT_MODE_NOT_READY;

            break;
    }
    return enumAltModeStatus;
}

//--------------------------------------------------
// Description  : Get Port Controller Pin Assignment
// Input Value  : enumTypeCPcbPort
// Output Value : Get Pin Assignment Result (_SUCCESS / _FAIL)
//--------------------------------------------------
bit SysUsbTypeCGetPortControllerPinAssignment(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCPinCfgType enumPinAssignment = _TYPE_C_PIN_ASSIGNMENT_NONE;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_D0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_D0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_D0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_D0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_D0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb D0 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_D0_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_D0_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_D1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_D1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_D1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_D1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_D1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb D1 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_D1_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_D1_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_D2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_D2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_D2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_D2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_D2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb D2 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_D2_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_D2_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_P0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_P0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_P0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_P0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_P0_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb P0 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_P0_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_P0_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_P1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_P1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_P1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_P1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_P1_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb P1 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_P1_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_P1_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_P2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_P2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_P2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_P2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_P2_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb P2 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_P2_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_P2_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_P3_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_P3_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_P3_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_P3_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_P3_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb P3 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_P3_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_P3_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_P4_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_P4_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_P4_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_P4_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_P4_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb P4 Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_P4_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_P4_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(ScalerTypeCGetPinAssignment(_ADAPTOR_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(ScalerTypeCTcpmGetPinAssignment(_ADAPTOR_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            if(UserCommonUsbTypeCRtsGetPinAssignment(_ADAPTOR_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            if(UserCommonUsbTypeCRtdGetPinAssignment(_ADAPTOR_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            if(UserCommonUsbTypeCUserGetPinAssignment(_ADAPTOR_TYPE_C_PORT, &enumPinAssignment) == _SUCCESS)
#endif
            {
                DebugMessageTypeC("8. SysUsb Adaptor Get Port Controller Pin Assignment Type :", enumPinAssignment);

                SysUsbTypeCSetPinAssignment(_ADAPTOR_TYPE_C_PORT, enumPinAssignment);

                return _SUCCESS;
            }
            else
            {
                SysUsbTypeCSetPinAssignment(_ADAPTOR_TYPE_C_PORT, _TYPE_C_PIN_ASSIGNMENT_NONE);

                return _FAIL;
            }

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            DebugMessageTypeC("8. SysUsb Get Port Controller with Invalid Port :", enumTypeCPcbPort);

            SysUsbTypeCSetPinAssignment(enumTypeCPcbPort, _TYPE_C_PIN_ASSIGNMENT_NONE);

            return _FAIL;

            break;
    }
    return _FAIL;
}

//--------------------------------------------------
// Description  : Get Port Controller Explicit Contract Info
// Input Value  : enumTypeCPcbPort
// Output Value : Get Port Controller Explicit Contract Info (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCGetPortControllerExplicitContract(EnumTypeCPcbPort enumTypeCPcbPort)
{
    bit bGetExplicitContract = _FALSE;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_P2_TYPE_C_PORT);
#endif


            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetExplicitContract = ScalerTypeCGetExplicitContract(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetExplicitContract = ScalerTypeCTcpmGetExplicitContract(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            bGetExplicitContract = UserCommonUsbTypeCRtsGetExplicitContract(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetExplicitContract = UserCommonUsbTypeCUserGetExplicitContract(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return bGetExplicitContract;
}

//--------------------------------------------------
// Description  : Get Port Ctrl FW Version
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
//                *pstTypeCFwVersion --> TypeC FW Version
// Output Value : Get FW Version Result (_SUCCESS / _FAIL)
//--------------------------------------------------
bit SysUsbTypeCGetPortControllerFwVersion(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCPortCtrlFwVersion *pstTypeCFwVersion)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    pstTypeCFwVersion = pstTypeCFwVersion;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_D0_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_D0_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_D1_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_D1_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_D2_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_D2_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_P0_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_P0_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_P1_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_P1_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_P2_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_P2_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_P3_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_P3_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_P4_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_P4_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            return _FAIL;
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsGetFwVersion(_ADAPTOR_TYPE_C_PORT, pstTypeCFwVersion);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserGetFwVersion(_ADAPTOR_TYPE_C_PORT, pstTypeCFwVersion);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            return _FAIL;

            break;
    }
    return _FAIL;
}

//--------------------------------------------------
// Description  : Get Port Controller Multi Function Change Process Done Result(Pin Assignment C <=> Pin Assignment D)
// Input Value  : enumTypeCPcbPort
// Output Value : _TRUE / _FALSE
//--------------------------------------------------
bit SysUsbTypeCGetPortControllerMultiFunctionChangeDone(EnumTypeCPcbPort enumTypeCPcbPort)
{
    bit bGetChangeResult = _FALSE;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bGetChangeResult = ScalerTypeCGetMultiFunctionChangeDone(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bGetChangeResult = ScalerTypeCTcpmGetMultiFunctionChangeDone(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bGetChangeResult = UserCommonUsbTypeCRtsGetMultiFunctionChangeDone(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bGetChangeResult = UserCommonUsbTypeCUserGetMultiFunctionChangeDone(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
    return bGetChangeResult;
}

//--------------------------------------------------
// Description  : Get Port Controller TypeC Cable Info For DPCD
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCCableInfoForDpcd
//--------------------------------------------------
StructTypeCCableInfoForDpcd SysUsbTypeCGetPortControllerCableInfoForDpcd(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCCableInfoForDpcd stTypeCCableInfoForDpcd = {_PD_CBL_COMPONENT_PASSIVE, _PD_CBL_MAX_DP_RATE_UNCONFIRMED, _FALSE};
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCCableInfoForDpcd = ScalerTypeCGetCableInfoForDpcd(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCCableInfoForDpcd = ScalerTypeCTcpmGetCableInfoForDpcd(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtsGetCableInfoForDpcd(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCRtdGetCableInfoForDpcd(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCCableInfoForDpcd = UserCommonUsbTypeCUserGetCableInfoForDpcd(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stTypeCCableInfoForDpcd;
}

//--------------------------------------------------
// Description  : Get Port Controller TypeC Number of Src/Snk PDOs
// Input Value  : enumTypeCPcbPort, enumPowerRole (Src/Snk SPR PDO)
// Output Value : Number of PDO Counts (1 ~ 11)
//--------------------------------------------------
BYTE SysUsbTypeCGetPortControllerPdoCnt(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole)
{
    BYTE ucPdoCnt = 0;
    BYTE ucSPRPdoCnt = 0;
    BYTE ucEPRPdoCnt = 0;

    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPowerRole = enumPowerRole;
    ucSPRPdoCnt = ucSPRPdoCnt;
    ucEPRPdoCnt = ucEPRPdoCnt;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCGetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmGetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return ucPdoCnt;
}

//--------------------------------------------------
// Description  : Get Port Controller TypeC Source/Sink PDO Info
// Input Value  : enumTypeCPcbPort, enumPowerRole (Src/Snk PDO), ucPdoIndex : 1~7
// Output Value : StructTypeCUserPDO (Voltage Unit = 100mV / Current = 10mA)
//--------------------------------------------------
StructTypeCUserPDO SysUsbTypeCGetPortControllerPdo(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole, BYTE ucPdoIndex)
{
    StructTypeCUserPDO stTypeCPdo = {_PD_FIX_SUPPLY_PDO, _PD_PEAK_CUR_NONE, 0x00, 0x00, 0x00};

    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPowerRole = enumPowerRole;
    ucPdoIndex = ucPdoIndex;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPdo = ScalerTypeCGetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPdo = ScalerTypeCTcpmGetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPdo = UserCommonUsbTypeCRtsGetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPdo = UserCommonUsbTypeCRtdGetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPdo = UserCommonUsbTypeCUserGetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stTypeCPdo;
}

//--------------------------------------------------
// Description  : Setting Up Other Interface According to Pin Assignment & DP Lane Count
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUpdateDisplayConfig(EnumTypeCPcbPort enumTypeCPcbPort)
{
#if(_DP_SUPPORT == _ON)
    // 1. Set DP lANE Mapping According to Pin Assignment and Orientation
    SysUsbTypeCSetDpLaneMapping(enumTypeCPcbPort, GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort), GET_USB_TYPE_C_ORIENTATION(enumTypeCPcbPort));
#endif

    // 2. Update OSD Lane Count
    SysUsbTypeCSetSysDataLaneCount(enumTypeCPcbPort, SysUsbTypeCGetAltModeLaneCnt(enumTypeCPcbPort, GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort)));

    // 3. For User to Update Config When DP Alt Mode Ready Status Changes
    UserCommonUsbTypeCUpdateDisplayConfig(enumTypeCPcbPort, GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort));

#if(_DP_SUPPORT == _ON)
    // 4. Switch DP Lane Count (DPCD Table)
    SysUsbTypeCDpLaneCountSwitch(enumTypeCPcbPort, SysUsbTypeCGetAltModeLaneCnt(enumTypeCPcbPort, GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort)));
#endif

    DebugMessageTypeC("8. [TYPE C] ==========> Alt Mode Ready Status Change, Update Display Lane Count", SysUsbTypeCGetAltModeLaneCnt(enumTypeCPcbPort, GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort)));
}

//--------------------------------------------------
// Description  : Set User-Defined Source Max Power to PD Port Ctrl
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerMaxPower(EnumTypeCPcbPort enumTypeCPcbPort, WORD usMaxPower)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    usMaxPower = usMaxPower;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_D0_TYPE_C_PORT, usMaxPower);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_D0_TYPE_C_PORT, usMaxPower);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_D0_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_D0_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_D0_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_D0_TYPE_C_PORT, usMaxPower);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_D0_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_D1_TYPE_C_PORT, usMaxPower);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_D1_TYPE_C_PORT, usMaxPower);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_D1_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_D1_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_D1_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_D1_TYPE_C_PORT, usMaxPower);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_D1_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_D2_TYPE_C_PORT, usMaxPower);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_D2_TYPE_C_PORT, usMaxPower);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_D2_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_D2_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_D2_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_D2_TYPE_C_PORT, usMaxPower);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_D2_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_P0_TYPE_C_PORT, usMaxPower);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_P0_TYPE_C_PORT, usMaxPower);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_P0_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_P0_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_P0_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_P0_TYPE_C_PORT, usMaxPower);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_P0_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_P1_TYPE_C_PORT, usMaxPower);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_P1_TYPE_C_PORT, usMaxPower);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_P1_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_P1_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_P1_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_P1_TYPE_C_PORT, usMaxPower);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_P1_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_P2_TYPE_C_PORT, usMaxPower);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_P2_TYPE_C_PORT, usMaxPower);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_P2_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_P2_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_P2_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_P2_TYPE_C_PORT, usMaxPower);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_P2_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_P3_TYPE_C_PORT, usMaxPower);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_P3_TYPE_C_PORT, usMaxPower);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_P3_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_P3_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_P3_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_P3_TYPE_C_PORT, usMaxPower);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_P3_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetMaxPower(_P4_TYPE_C_PORT, usMaxPower);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetMaxPower(_P4_TYPE_C_PORT, usMaxPower);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
#if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
            if(UserCommonUsbTypeCRtsGetMaxPower(_P4_TYPE_C_PORT) != usMaxPower)
            {
                SET_USB_TYPE_C_PDO_CHG_STATUS(_P4_TYPE_C_PORT);
                UserCommonUsbTypeCRtsSetMaxPower(_P4_TYPE_C_PORT, usMaxPower);
            }
#endif  // End of #if(_PORT_CTRL_PD3_1_EPR_SUPPORT == _ON)
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetMaxPower(_P4_TYPE_C_PORT, usMaxPower);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetMaxPower(_P4_TYPE_C_PORT, usMaxPower);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Sink Information to PD Port Ctrl
// Input Value  : enumTypeCPcbPort , stTypeCSnkInfo
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerSnkInfo(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCSnkInfo stTypeCSnkInfo)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    stTypeCSnkInfo = stTypeCSnkInfo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_D0_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_D0_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_D0_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_D0_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_D1_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_D1_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_D1_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_D1_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_D2_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_D2_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_D2_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_D2_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_P0_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_P0_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_P0_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_P0_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_P1_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_P1_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_P1_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_P1_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_P2_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_P2_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_P2_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_P2_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_P3_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_P3_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_P3_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_P3_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetSnkInfo(_P4_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetSnkInfo(_P4_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetSnkInfo(_P4_TYPE_C_PORT, stTypeCSnkInfo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetSnkInfo(_P4_TYPE_C_PORT, stTypeCSnkInfo);
#endif
            break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Number of PDOs to PD Port Ctrl
// Input Value  : enumTypeCPcbPort, enumPowerRole(Src/Snk PDO), ucSPRPdoCnt, ucEPRPdoCnt
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerPdoCnt(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole, BYTE ucSPRPdoCnt, BYTE ucEPRPdoCnt)
{
    BYTE ucPdoCnt = 0;

    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPowerRole = enumPowerRole;
    ucPdoCnt = ucPdoCnt;

    if(ucEPRPdoCnt != 0)
    {
        ucPdoCnt = 7 + ucEPRPdoCnt;
    }
    else
    {
        ucPdoCnt = ucSPRPdoCnt;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucSPRPdoCnt, ucEPRPdoCnt);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoCnt);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Fix Supply/ PPS PDOs to PD Port Ctrl
// Input Value  : enumTypeCPcbPort, enumPowerRole(Src/Snk PDO), ucPdoIndex, stTypeCUserPdo
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerPdo(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole, BYTE ucPdoIndex, StructTypeCUserPDO stTypeCUserPdo)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPowerRole = enumPowerRole;
    ucPdoIndex = ucPdoIndex;
    stTypeCUserPdo = stTypeCUserPdo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_D0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_D0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_D0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_D0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_D1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_D1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_D1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_D1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_D2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_D2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_D2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_D2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P0_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P1_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P2_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P3_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P3_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P3_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P3_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P4_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P4_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_P4_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_P4_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCSetFixPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_ADAPTOR_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCSetPpsPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_ADAPTOR_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCSetAvsPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            if(stTypeCUserPdo.enumPdoType == _PD_FIX_SUPPLY_PDO)
            {
                ScalerTypeCTcpmSetFixPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.usMaxCurrent, stTypeCUserPdo.enumPeakCurrent);
            }
#if(_ADAPTOR_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_PROGRAMMABLE_PDO)
            {
                ScalerTypeCTcpmSetPpsPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, (BYTE)(stTypeCUserPdo.usMaxCurrent / 5));
            }
#endif  // End of #if(_ADAPTOR_TYPE_C_EMB_PD3_PPS_SUPPORT == _ON)
            else if(stTypeCUserPdo.enumPdoType == _PD_3_1_ADJUSTABLE_PDO)
            {
                ScalerTypeCTcpmSetAvsPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo.usMinVoltage, stTypeCUserPdo.usMaxVoltage, stTypeCUserPdo.enumPeakCurrent);
            }

#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex, stTypeCUserPdo);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Fix Supply/ PPS Initial RDO to PD Port Ctrl
// Input Value  : enumTypeCPcbPort, stTypeCUserInitRdo
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerInitRdo(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCUserInitRDO stTypeCUserInitRdo)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    stTypeCUserInitRdo = stTypeCUserInitRdo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_D0_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_D0_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_D0_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_D0_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_D1_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_D1_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_D1_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_D1_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_D2_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_D2_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_D2_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_D2_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_P0_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_P0_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_P0_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_P0_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_P1_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_P1_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_P1_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_P1_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_P2_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_P2_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_P2_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_P2_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_P3_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_P3_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_P3_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_P3_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_P4_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_P4_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_P4_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_P4_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetInitRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetInitRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserInitRdo);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // UserCommonUsbTypeCRtsSetInitRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserInitRdo);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetInitRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserInitRdo);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Fix Supply/ PPS RDO to PD Port Ctrl
// Input Value  : enumTypeCPcbPort, stTypeCUserRdo
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerRdo(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCUserRDO stTypeCUserRdo)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    stTypeCUserRdo = stTypeCUserRdo;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_D0_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_D0_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_D0_TYPE_C_PORT, stTypeCUserRdo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_D0_TYPE_C_PORT, stTypeCUserRdo);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_D0_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_D1_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_D1_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_D1_TYPE_C_PORT, stTypeCUserRdo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_D1_TYPE_C_PORT, stTypeCUserRdo);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_D1_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_D2_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_D2_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_D2_TYPE_C_PORT, stTypeCUserRdo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_D2_TYPE_C_PORT, stTypeCUserRdo);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_D2_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_P0_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_P0_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_P0_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_P0_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_P0_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_P1_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_P1_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_P1_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_P1_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_P1_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_P2_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_P2_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_P2_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_P2_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_P2_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_P3_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_P3_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_P3_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_P3_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_P3_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_P4_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_P4_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_P4_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_P4_TYPE_C_PORT, stTypeCUserRdo);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_P4_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set Request Info to Embedded Port Ctrl
            ScalerTypeCSetRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserRdo);

            // Request Embedded TypeC to Send Request
            ScalerTypeCSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set Request Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserRdo);

            // Request TCPM to Send Request
            ScalerTypeCTcpmSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_SEND_REQUEST);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsSetRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserRdo);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserRdo);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetRdo(_ADAPTOR_TYPE_C_PORT, stTypeCUserRdo);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set Source/Sink Capability By Kernel
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
//                enumPowerRole --> _TYPE_C_POWER_SRC / _TYPE_C_POWER_SNK
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerPdoByKernel(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPowerRole = enumPowerRole;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_D0_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_D1_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_D2_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_P0_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_P1_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_P2_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_P3_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_P4_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdoByKernel(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdoByKernel(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdoByKernel(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // UserCommonUsbTypeCRtdSetPdoByKernel(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdoByKernel(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Type-C Function Support Option to Port Ctrl
// Input Value  : enumTypeCPcbPort, enumFunctionSupport
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerFunctionSupport(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCFunctionSupport enumFunctionSupport)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    enumFunctionSupport = enumFunctionSupport;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_D0_TYPE_C_PORT, enumFunctionSupport);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_D0_TYPE_C_PORT, enumFunctionSupport);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_D0_TYPE_C_PORT, enumFunctionSupport);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_D0_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_D1_TYPE_C_PORT, enumFunctionSupport);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_D1_TYPE_C_PORT, enumFunctionSupport);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_D1_TYPE_C_PORT, enumFunctionSupport);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_D1_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_D2_TYPE_C_PORT, enumFunctionSupport);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_D2_TYPE_C_PORT, enumFunctionSupport);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_D2_TYPE_C_PORT, enumFunctionSupport);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_D2_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_P0_TYPE_C_PORT, enumFunctionSupport);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_P0_TYPE_C_PORT, enumFunctionSupport);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_P0_TYPE_C_PORT, enumFunctionSupport);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_P0_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_P1_TYPE_C_PORT, enumFunctionSupport);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_P1_TYPE_C_PORT, enumFunctionSupport);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_P1_TYPE_C_PORT, enumFunctionSupport);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_P1_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_P2_TYPE_C_PORT, enumFunctionSupport);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_P2_TYPE_C_PORT, enumFunctionSupport);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_P2_TYPE_C_PORT, enumFunctionSupport);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_P2_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_P3_TYPE_C_PORT, enumFunctionSupport);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_P3_TYPE_C_PORT, enumFunctionSupport);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_P3_TYPE_C_PORT, enumFunctionSupport);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_P3_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_P4_TYPE_C_PORT, enumFunctionSupport);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_P4_TYPE_C_PORT, enumFunctionSupport);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_P4_TYPE_C_PORT, enumFunctionSupport);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_P4_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetFunctionSupport(_ADAPTOR_TYPE_C_PORT, enumFunctionSupport);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetFunctionSupport(_ADAPTOR_TYPE_C_PORT, enumFunctionSupport);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetFunctionSupport(_ADAPTOR_TYPE_C_PORT, enumFunctionSupport);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetFunctionSupport(_ADAPTOR_TYPE_C_PORT, enumFunctionSupport);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Type-C Operation Mode to Port Ctrl
// Input Value  : enumTypeCPcbPort, enumOperationMode
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerOperationMode(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCOperationMode enumOperationMode)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    enumOperationMode = enumOperationMode;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_D0_TYPE_C_PORT, enumOperationMode);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_D0_TYPE_C_PORT, enumOperationMode);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_D0_TYPE_C_PORT, enumOperationMode);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_D0_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_D1_TYPE_C_PORT, enumOperationMode);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_D1_TYPE_C_PORT, enumOperationMode);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_D1_TYPE_C_PORT, enumOperationMode);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_D1_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_D2_TYPE_C_PORT, enumOperationMode);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_D2_TYPE_C_PORT, enumOperationMode);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_D2_TYPE_C_PORT, enumOperationMode);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_D2_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_P0_TYPE_C_PORT, enumOperationMode);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_P0_TYPE_C_PORT, enumOperationMode);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_P0_TYPE_C_PORT, enumOperationMode);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_P0_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_P1_TYPE_C_PORT, enumOperationMode);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_P1_TYPE_C_PORT, enumOperationMode);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_P1_TYPE_C_PORT, enumOperationMode);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_P1_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_P2_TYPE_C_PORT, enumOperationMode);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_P2_TYPE_C_PORT, enumOperationMode);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_P2_TYPE_C_PORT, enumOperationMode);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_P2_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_P3_TYPE_C_PORT, enumOperationMode);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_P3_TYPE_C_PORT, enumOperationMode);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_P3_TYPE_C_PORT, enumOperationMode);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_P3_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_P4_TYPE_C_PORT, enumOperationMode);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_P4_TYPE_C_PORT, enumOperationMode);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_P4_TYPE_C_PORT, enumOperationMode);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_P4_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetOperationMode(_ADAPTOR_TYPE_C_PORT, enumOperationMode);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetOperationMode(_ADAPTOR_TYPE_C_PORT, enumOperationMode);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetOperationMode(_ADAPTOR_TYPE_C_PORT, enumOperationMode);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetOperationMode(_ADAPTOR_TYPE_C_PORT, enumOperationMode);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User-Defined Type-C Status Event to Port Ctrl
// Input Value  : enumTypeCPcbPort, stTypeCStatusEvent
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerStatusEvent(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCStatusEvent stTypeCStatusEvent)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    stTypeCStatusEvent = stTypeCStatusEvent;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_D0_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_D0_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_D0_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_D0_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_D1_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_D1_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_D1_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_D1_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_D2_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_D2_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_D2_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_D2_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_P0_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_P0_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_P0_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_P0_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_P1_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_P1_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_P1_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_P1_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_P2_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_P2_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_P2_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_P2_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_P3_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_P3_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_P3_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_P3_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_P4_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_P4_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_P4_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_P4_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Status Message
            ScalerTypeCSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to Embedded Port Ctrl
            ScalerTypeCSetStatusEvent(_ADAPTOR_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_STATUS_EVENT);

            // Set Status Info to TCPM Port Ctrl
            ScalerTypeCTcpmSetStatusEvent(_ADAPTOR_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetStatusEvent(_ADAPTOR_TYPE_C_PORT, stTypeCStatusEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetStatusEvent(_ADAPTOR_TYPE_C_PORT, stTypeCStatusEvent);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    // Clear Status Event Change Flag
    SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_STATUS_EVENT_CHG);
}

//--------------------------------------------------
// Description  : Set User-Defined Type-C Alert Event to Port Ctrl
// Input Value  : enumTypeCPcbPort, stTypeCAlertEvent
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerAlertEvent(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCAlertEvent stTypeCAlertEvent)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    stTypeCAlertEvent = stTypeCAlertEvent;

    if(SysUsbTypeCGetPortControllerCcAttach(enumTypeCPcbPort) == _TYPE_C_ATTACH)
    {
        switch(enumTypeCPcbPort)
        {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_D0_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_D0_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_D0_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_D0_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_D1_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_D1_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_D1_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_D1_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_D2_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_D2_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_D2_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_D2_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_P0_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_P0_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_P0_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_P0_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_P1_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_P1_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_P1_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_P1_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_P2_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_P2_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_P2_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_P2_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_P3_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_P3_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_P3_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_P3_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_P4_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_P4_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_P4_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_P4_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                // Request Embedded TypeC to Send Alert Message
                ScalerTypeCSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to Embedded Port Ctrl
                ScalerTypeCSetAlertEvent(_ADAPTOR_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
                // Request TCPM to Send Alert Message
                ScalerTypeCTcpmSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_ALERT_EVENT);

                // Set Alert Info to TCPM Port Ctrl
                ScalerTypeCTcpmSetAlertEvent(_ADAPTOR_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
                // UserCommonUsbTypeCRtsSetAlertEvent(_ADAPTOR_TYPE_C_PORT, stTypeCAlertEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
                // UserCommonUsbTypeCUserSetAlertEvent(_ADAPTOR_TYPE_C_PORT, stTypeCAlertEvent);
#endif
                break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

            default:

                break;
        }
    }
    else
    {
        DebugMessageTypeC("[TYPE C] Alert Message Can't be Send without CC Attach", 0);
    }

    // Clear Alert Event Change Flag
    SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_ALERT_EVENT_CHG);
}

//--------------------------------------------------
// Description  : Return TypeC Port Partner Status Info
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCStatusEvent
//--------------------------------------------------
StructTypeCStatusEvent SysUsbTypeCGetPartnerStatusInfo(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCStatusEvent stTypeCPartnerStatusEvent = {0x00, 0x00};
    enumTypeCPcbPort = enumTypeCPcbPort;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return stTypeCPartnerStatusEvent;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerStatusEvent = ScalerTypeCGetPartnerStatusInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerStatusEvent = ScalerTypeCTcpmGetPartnerStatusInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCRtsGetPartnerStatusInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerStatusEvent = UserCommonUsbTypeCUserGetPartnerStatusInfo(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stTypeCPartnerStatusEvent;
}

//--------------------------------------------------
// Description  : Return TypeC Port Partner Alert Info
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCAlertEvent
//--------------------------------------------------
StructTypeCAlertEvent SysUsbTypeCGetPartnerAlertInfo(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCAlertEvent stTypeCPartnerAlertEvent = {_TYPE_C_TYPE_OF_ALERT_NONE, _TYPE_C_BAT_NONE, _TYPE_C_EXT_ALERT_EVENT_NONE};
    enumTypeCPcbPort = enumTypeCPcbPort;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return stTypeCPartnerAlertEvent;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerAlertEvent = ScalerTypeCGetPartnerAlertInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerAlertEvent = ScalerTypeCTcpmGetPartnerAlertInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCRtsGetPartnerAlertInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stTypeCPartnerAlertEvent = UserCommonUsbTypeCUserGetPartnerAlertInfo(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stTypeCPartnerAlertEvent;
}

#if(_DP_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Set DP Lane Mapping According to RTS/User Pin Assignment and Orientation
// Input Value  : enumTypeCPcbPort, enumPinAssignment, enumOrientation
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetDpLaneMapping(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPinCfgType enumPinAssignment, EnumTypeCOrientation enumOrientation)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPinAssignment = enumPinAssignment;
    enumOrientation = enumOrientation;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // Adjust Lane Mapping According to Extern Port Controller Pin Assignment and Orientation
            ScalerDpAuxRxSetLaneMapping(SysUsbTypeCConvertToDxPort(_D0_TYPE_C_PORT), enumPinAssignment, enumOrientation);

            DebugMessageTypeC("8. [TYPE C] ==========> TYPEC 0 Set Lane Mapping with Pin Assignment ", enumPinAssignment);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // Adjust Lane Mapping According to Extern Port Controller Pin Assignment and Orientation
            ScalerDpAuxRxSetLaneMapping(SysUsbTypeCConvertToDxPort(_D1_TYPE_C_PORT), enumPinAssignment, enumOrientation);

            DebugMessageTypeC("8. [TYPE C] ==========> TYPEC 1 Set Lane Mapping with Pin Assignment ", enumPinAssignment);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // Adjust Lane Mapping According to Extern Port Controller Pin Assignment and Orientation
            ScalerDpAuxRxSetLaneMapping(SysUsbTypeCConvertToDxPort(_D2_TYPE_C_PORT), enumPinAssignment, enumOrientation);

            DebugMessageTypeC("8. [TYPE C] ==========> TYPEC 2 Set Lane Mapping with Pin Assignment ", enumPinAssignment);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        case _P0_TYPE_C_PORT:
        case _P1_TYPE_C_PORT:
        case _P2_TYPE_C_PORT:
        case _P3_TYPE_C_PORT:
        case _P4_TYPE_C_PORT:
        case _ADAPTOR_TYPE_C_PORT:
        default:

            DebugMessageTypeC("8. [TYPE C] ==========X SysUsb Set Lane Mapping with Invalid Port :", enumTypeCPcbPort);

            break;
    }
}

//--------------------------------------------------
// Description  : Switch DP Lane Count (DPCD Table)
// Input Value  : enumTypeCPcbPort, enumDpLaneCount
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCDpLaneCountSwitch(EnumTypeCPcbPort enumTypeCPcbPort, EnumDpLaneCount enumDpLaneCount)
{
    enumDpLaneCount = enumDpLaneCount;
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            ScalerDpRxLaneCountSwitch(_D0_INPUT_PORT, enumDpLaneCount);

            break;
#endif

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            ScalerDpRxLaneCountSwitch(_D1_INPUT_PORT, enumDpLaneCount);

            break;
#endif

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            ScalerDpRxLaneCountSwitch(_D2_INPUT_PORT, enumDpLaneCount);

            break;
#endif

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // ScalerDpTxLaneCountSwitch(_P0_OUTPUT_PORT, enumDpLaneCount);

            break;
#endif

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // ScalerDpTxLaneCountSwitch(_P1_OUTPUT_PORT, enumDpLaneCount);

            break;
#endif

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // ScalerDpTxLaneCountSwitch(_P2_OUTPUT_PORT, enumDpLaneCount);

            break;
#endif

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // ScalerDpTxLaneCountSwitch(_P3_OUTPUT_PORT, enumDpLaneCount);

            break;
#endif

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // ScalerDpTxLaneCountSwitch(_P4_OUTPUT_PORT, enumDpLaneCount);

            break;
#endif

        // Adaptor Port Does Not Support Alt Mode
        case _ADAPTOR_TYPE_C_PORT:
        default:
            break;
    }
}
#endif  // End of #if(_DP_SUPPORT == _ON)

//--------------------------------------------------
// Description  : Check if Specific Capability Has Been Changed
// Input Value  : enumTypeCPcbPort, enumCapability
// Output Value : Capability Change TRUE/FALSE
//--------------------------------------------------
bit SysUsbTypeCCheckCapabilityChange(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCCapChgStatus enumCapability)
{
    switch(enumCapability)
    {
        case _TYPE_C_PIN_ASSIGNMENT_CAP_CHG:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_PIN_ASSIGNMENT_CAP_CHG) == _TYPE_C_PIN_ASSIGNMENT_CAP_CHG)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_SEND_SRC_CAP:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_SEND_SRC_CAP) == _TYPE_C_SEND_SRC_CAP)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_SPM_CAP_CHG:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_SPM_CAP_CHG) == _TYPE_C_SPM_CAP_CHG)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_CC_FUNC_CHG_DISABLE:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_CC_FUNC_CHG_DISABLE) == _TYPE_C_CC_FUNC_CHG_DISABLE)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_CC_FUNC_CHG_ENABLE:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_CC_FUNC_CHG_ENABLE) == _TYPE_C_CC_FUNC_CHG_ENABLE)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_POWER_DIRECTION_CHG_TO_SRC:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_POWER_DIRECTION_CHG_TO_SRC) == _TYPE_C_POWER_DIRECTION_CHG_TO_SRC)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_POWER_DIRECTION_CHG_TO_SNK:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_POWER_DIRECTION_CHG_TO_SNK) == _TYPE_C_POWER_DIRECTION_CHG_TO_SNK)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_POWER_CHG_TO_OFF:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_POWER_CHG_TO_OFF) == _TYPE_C_POWER_CHG_TO_OFF)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_POWER_CHG_TO_ON:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_POWER_CHG_TO_ON) == _TYPE_C_POWER_CHG_TO_ON)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_ALERT_EVENT_CHG:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_ALERT_EVENT_CHG) == _TYPE_C_ALERT_EVENT_CHG)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_STATUS_EVENT_CHG:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_STATUS_EVENT_CHG) == _TYPE_C_STATUS_EVENT_CHG)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_UPDATE_SRC_CAP:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_UPDATE_SRC_CAP) == _TYPE_C_UPDATE_SRC_CAP)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _TYPE_C_SEND_GET_STATUS_MSG:

            if((GET_USB_TYPE_C_CAPABILITY_CHG(enumTypeCPcbPort) & _TYPE_C_SEND_GET_STATUS_MSG) == _TYPE_C_SEND_GET_STATUS_MSG)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        default:

            return _FALSE;

            break;
    }

    return _FALSE;
}

//--------------------------------------------------
// Description  : Reconfig, and Set Reconnect Flag if Current Config does not Match the Latest Requirement
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCPinAssignmentCapabilityChangeProc(EnumTypeCPcbPort enumTypeCPcbPort)
{
    bit bPinAssignmentMismatch = _FALSE;
    EnumTypeCPinMismatchAction enumMismatchAction = _TYPE_C_PIN_ASSIGNMENT_MISMATCH_NO_ACTION;

    // 1. Update Prot Controller (5400/User/Embedded/TCPM) Config
    if(SysUsbTypeCUpdatePortControllerConfig(enumTypeCPcbPort) == _SUCCESS)
    {
        // If Negotiated Pin Assignment != E, Check Following Step(For Pin E C-DP Cable, There is No Need to Reconnect)
        if(GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort) != _TYPE_C_PIN_ASSIGNMENT_E)
        {
            // 2. Check if Current Config does not Match the Latest Requirement
            if(GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort) == _TYPE_C_PIN_ASSIGNMENT_CAP_NONE)
            {
                // 2-1. Current Pin Assignment Cap = NONE (for Ext Port Ctrl Power On 1st Time)
                // Check Negotiated Pin Assignment != D & Target Pin Assignment Has D
                if((GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort) != _TYPE_C_PIN_ASSIGNMENT_D) &&
                   (((BYTE)GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort) & (BYTE)_TYPE_C_PIN_ASSIGNMENT_D) == (BYTE)_TYPE_C_PIN_ASSIGNMENT_D))
                {
                    bPinAssignmentMismatch = _TRUE;
                }

                // Check Negotiated Pin Assignment Not Part of Target Pin Assignment
                if((((BYTE)GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort)) & ((BYTE)GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort))) == 0x00)
                {
                    bPinAssignmentMismatch = _TRUE;
                }
            }
            else
            {
                // 2-2. Current Pin Assignment Cap != NONE (for General Case)
                // Check Pin Assignment Cap Supported in Target but Not in Current
                pData[0] = (BYTE)(GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort) & (~(GET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort))));

                if(pData[0] != (BYTE)_TYPE_C_PIN_ASSIGNMENT_NONE)
                {
                    // Target Pin Assignment Support More Cap than Current (Not Pin E)
                    if(pData[0] != (BYTE)_TYPE_C_PIN_ASSIGNMENT_E)
                    {
                        bPinAssignmentMismatch = _TRUE;
                    }
                }
                else
                {
                    // Target Pin Assignment Support Less Cap than Current, Check Negotiated Pin Assignment Valid
                    if((((BYTE)GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort)) & ((BYTE)GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort))) == 0x00)
                    {
                        bPinAssignmentMismatch = _TRUE;
                    }
                }
            }
        }

        // 3. Check if (Current Multi-Function Status does not Match the Latest Requirement) && (Target Multi-Function Status does not Match Negotiated Pin Assignment)
        if((GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(enumTypeCPcbPort) != GET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(enumTypeCPcbPort)) &&
           (((GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort) == _TYPE_C_PIN_ASSIGNMENT_C) && (GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(enumTypeCPcbPort) == _TYPE_C_MULTI_FUNC_PREFER)) ||
            ((GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort) == _TYPE_C_PIN_ASSIGNMENT_D) && (GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(enumTypeCPcbPort) == _TYPE_C_MULTI_FUNC_NOT_PREFER))))
        {
            bPinAssignmentMismatch = _TRUE;
        }

        // 4. Ask User for Pin Assignment Mismatch Action
        if(bPinAssignmentMismatch == _TRUE)
        {
            enumMismatchAction = UserCommonUsbTypeCGetPinAssignmentMismatchAction(enumTypeCPcbPort);

            // 4-1. Pin Assignment Mismatch Reconnect
            if(enumMismatchAction == _TYPE_C_PIN_ASSIGNMENT_MISMATCH_RECONNECT)
            {
                SET_USB_TYPE_C_RECONNECT(enumTypeCPcbPort);
                DebugMessageTypeC("8. [TYPE C] ==========> U3 Mode Mismatch, Set RECONNECT Flag", GET_USB_TYPE_C_RECONNECT(enumTypeCPcbPort));
            }

            // 4-2. Pin Assignment Mismatch Wait Config
            if(enumMismatchAction == _TYPE_C_PIN_ASSIGNMENT_MISMATCH_WAIT_CONFIG)
            {
                // Ask PD Controller to Wait DP Config
                SysUsbTypeCWaitDpConfigUpdate(enumTypeCPcbPort);
                DebugMessageTypeC("8. [TYPE C] ==========> U3 Mode Mismatch, Ask Port Controller to Wait New Config", enumTypeCPcbPort);
            }
        }

        // Update Current Pin Assignment Cap
        SET_USB_TYPE_C_CURRENT_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort, GET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort));

        // Update Current Multi-Function Status
        SET_USB_TYPE_C_CURRENT_MULTI_FUNCTION(enumTypeCPcbPort, GET_USB_TYPE_C_TARGET_MULTI_FUNCTION(enumTypeCPcbPort));

        // 5. Clear Pin Assignment Capability Change Flag
        SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_PIN_ASSIGNMENT_CAP_CHG);
        DebugMessageTypeC("8. [TYPE C] ==========> Update Config Successfully, Clear Pin Assignment Cap Change", 1);
    }
}

//--------------------------------------------------
// Description  : Specific Capability Change Proc
// Input Value  : enumTypeCPcbPort, usCapability
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCCapabilityChangeProc(EnumTypeCPcbPort enumTypeCPcbPort, WORD usCapability)
{
    StructTypeCStatusEvent stStatusEvent = {0x00, 0x00};
    StructTypeCAlertEvent stAlertEvent = {_TYPE_C_TYPE_OF_ALERT_NONE, _TYPE_C_BAT_NONE, _TYPE_C_EXT_ALERT_EVENT_NONE};

    // Check Whether Specific Capability Has Been Changed or Not
    if(((usCapability & _TYPE_C_POWER_CHG_TO_OFF) == _TYPE_C_POWER_CHG_TO_OFF) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_POWER_CHG_TO_OFF) == _TRUE))
    {
        SysUsbTypeCPowerControlChangeProc(enumTypeCPcbPort, _TYPE_C_POWER_OFF);
    }

    if(((usCapability & _TYPE_C_POWER_CHG_TO_ON) == _TYPE_C_POWER_CHG_TO_ON) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_POWER_CHG_TO_ON) == _TRUE))
    {
        SysUsbTypeCPowerControlChangeProc(enumTypeCPcbPort, _TYPE_C_POWER_ON);
    }

    if(((usCapability & _TYPE_C_CC_FUNC_CHG_DISABLE) == _TYPE_C_CC_FUNC_CHG_DISABLE) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_CC_FUNC_CHG_DISABLE) == _TRUE))
    {
        SysUsbTypeCCcFunctionChangeProc(enumTypeCPcbPort, _TYPE_C_CC_FUNCTION_DISABLE);
    }

    if(((usCapability & _TYPE_C_CC_FUNC_CHG_ENABLE) == _TYPE_C_CC_FUNC_CHG_ENABLE) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_CC_FUNC_CHG_ENABLE) == _TRUE))
    {
        SysUsbTypeCCcFunctionChangeProc(enumTypeCPcbPort, _TYPE_C_CC_FUNCTION_ENABLE);

        // Get Type-C Function Support Option From User, and Update to Port Controller
        SysUsbTypeCSetPortControllerFunctionSupport(enumTypeCPcbPort, UserCommonUsbTypeCGetFunctionSupport(enumTypeCPcbPort));

        // Get Type-C Operation Mode From User, and Update to Port Controller
        SysUsbTypeCSetPortControllerOperationMode(enumTypeCPcbPort, UserCommonUsbTypeCGetOperationMode(enumTypeCPcbPort));
    }

    if(((usCapability & _TYPE_C_POWER_DIRECTION_CHG_TO_SRC) == _TYPE_C_POWER_DIRECTION_CHG_TO_SRC) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_POWER_DIRECTION_CHG_TO_SRC) == _TRUE))
    {
        SysUsbTypeCPowerDirectionChangeProc(enumTypeCPcbPort, _TYPE_C_POWER_SRC);
    }

    if(((usCapability & _TYPE_C_POWER_DIRECTION_CHG_TO_SNK) == _TYPE_C_POWER_DIRECTION_CHG_TO_SNK) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_POWER_DIRECTION_CHG_TO_SNK) == _TRUE))
    {
        SysUsbTypeCPowerDirectionChangeProc(enumTypeCPcbPort, _TYPE_C_POWER_SNK);
    }

    if(((usCapability & _TYPE_C_UPDATE_SRC_CAP) == _TYPE_C_UPDATE_SRC_CAP) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_UPDATE_SRC_CAP) == _TRUE))
    {
        SysUsbTypeCUpdatePortCtrlSrcPdo(enumTypeCPcbPort);
    }

    if(((usCapability & _TYPE_C_SEND_SRC_CAP) == _TYPE_C_SEND_SRC_CAP) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_SEND_SRC_CAP) == _TRUE))
    {
        // Request Port Controller to Re-Send Src Capability Message
        SysUsbTypeCSendSrcCapability(enumTypeCPcbPort);
    }

    if(((usCapability & _TYPE_C_SEND_GET_STATUS_MSG) == _TYPE_C_SEND_GET_STATUS_MSG) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_SEND_GET_STATUS_MSG) == _TRUE))
    {
        // Request Port Controller to Send Get_Status Message
        SysUsbTypeCSendGetStatusMsg(enumTypeCPcbPort);
    }

    if(((usCapability & _TYPE_C_STATUS_EVENT_CHG) == _TYPE_C_STATUS_EVENT_CHG) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_STATUS_EVENT_CHG) == _TRUE))
    {
        // Get Type-C Status Event From User, and Update to Port Controller
        UserCommonUsbTypeCGetStatusEvent(enumTypeCPcbPort, &stStatusEvent);
        SysUsbTypeCSetPortControllerStatusEvent(enumTypeCPcbPort, stStatusEvent);
    }

    if(((usCapability & _TYPE_C_ALERT_EVENT_CHG) == _TYPE_C_ALERT_EVENT_CHG) && (SysUsbTypeCCheckCapabilityChange(enumTypeCPcbPort, _TYPE_C_ALERT_EVENT_CHG) == _TRUE))
    {
        // Get Type-C Alert Event From User, and Update to Port Controller
        UserCommonUsbTypeCGetAlertEvent(enumTypeCPcbPort, &stAlertEvent);

        if((stAlertEvent.enumTypeOfAlert & _TYPE_C_TYPE_OF_ALERT_ALL) != _TYPE_C_TYPE_OF_ALERT_NONE)
        {
            SysUsbTypeCSetPortControllerAlertEvent(enumTypeCPcbPort, stAlertEvent);
        }
        else
        {
            // Clear Alert Event Change Flag
            SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_ALERT_EVENT_CHG);
        }
    }
}

//--------------------------------------------------
// Description  : TypeC Power Control Change Process
// Input Value  : enumTypeCPcbPort, enumPowerControlStatus
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCPowerControlChangeProc(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerControlStatus enumPowerControlStatus)
{
    if(enumPowerControlStatus == _TYPE_C_POWER_OFF)
    {
        if(GET_USB_TYPE_C_POWER_CONTROL_STATUS(enumTypeCPcbPort) == _TYPE_C_POWER_ON)
        {
            if(SysUsbTypeCPowerControl(enumTypeCPcbPort, _TYPE_C_POWER_OFF) == _SUCCESS)
            {
                SysUsbTypeCSetPowerControlStatus(enumTypeCPcbPort, _TYPE_C_POWER_OFF);

                SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_POWER_CHG_TO_OFF);
            }
        }
        else
        {
            SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_POWER_CHG_TO_OFF);
        }
    }
    else if(enumPowerControlStatus == _TYPE_C_POWER_ON)
    {
        if(GET_USB_TYPE_C_POWER_CONTROL_STATUS(enumTypeCPcbPort) == _TYPE_C_POWER_OFF)
        {
            if(SysUsbTypeCPowerControl(enumTypeCPcbPort, _TYPE_C_POWER_ON) == _SUCCESS)
            {
                SysUsbTypeCSetPowerControlStatus(enumTypeCPcbPort, _TYPE_C_POWER_ON);

                SysUsbTypeCPortCtrlPowerOnProc(enumTypeCPcbPort);

                SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_POWER_CHG_TO_ON);
            }
        }
        else
        {
            SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_POWER_CHG_TO_ON);
        }
    }
}

//--------------------------------------------------
// Description  : Control Type-C Power Off/On
// Input Value  : enumTypeCPcbPort, enumPowerControlStatus
// Output Value : Control Power Result (_SUCCESS / _FAIL)
//--------------------------------------------------
bit SysUsbTypeCPowerControl(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerControlStatus enumPowerControlStatus)
{
    bit bControlResult = _FAIL;
    enumPowerControlStatus = enumPowerControlStatus;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_D0_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_D0_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_D0_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_D0_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_D1_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_D1_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_D1_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_D1_TYPE_C_PORT, enumPowerControlStatus);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_D2_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_D2_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_D2_TYPE_C_PORT, enumPowerControlStatus);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_D2_TYPE_C_PORT, enumPowerControlStatus);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_P0_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_P0_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_P0_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_P0_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_P1_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_P1_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_P1_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_P1_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_P2_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_P2_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_P2_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_P2_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_P3_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_P3_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_P3_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_P3_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_P4_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_P4_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_P4_TYPE_C_PORT, enumPowerControlStatus);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_P4_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            bControlResult = ScalerTypeCPowerControl(_ADAPTOR_TYPE_C_PORT, enumPowerControlStatus);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            bControlResult = ScalerTypeCTcpmPowerControl(_ADAPTOR_TYPE_C_PORT, enumPowerControlStatus);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // bControlResult = UserCommonUsbTypeCRtsPowerControl(_ADAPTOR_TYPE_C_PORT, enumPowerControlStatus);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // bControlResult = UserCommonUsbTypeCUserPowerControl(_ADAPTOR_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return bControlResult;
}

//--------------------------------------------------
// Description  : Set Type-C Power Control Status
// Input Value  : enumTypeCPcbPort, enumPowerControlStatus
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPowerControlStatus(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerControlStatus enumPowerControlStatus)
{
    BYTE ucIndex = 0;
    enumPowerControlStatus = enumPowerControlStatus;
    ucIndex = ucIndex;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_D0_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_D1_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_D2_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P0_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P1_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P2_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P3_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_P4_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Set All Embbeded TypeC Ports Power Control Status
            for(ucIndex = 0; ucIndex < (_EMB_TYPE_C_PORT_VALID - 1); ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCEmbeddedPort[ucIndex], enumPowerControlStatus);
            }
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Set All TCPM Ports Power Control Status
            for(ucIndex = 0; ucIndex < _TCPM_PORT_VALID; ++ucIndex)
            {
                SET_USB_TYPE_C_POWER_CONTROL_STATUS(g_penumTypeCTcpmPort[ucIndex], enumPowerControlStatus);
            }
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            // SET_USB_TYPE_C_POWER_CONTROL_STATUS(_ADAPTOR_TYPE_C_PORT, enumPowerControlStatus);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Run Type-C Port Controller Power On Process
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCPortCtrlPowerOnProc(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_D0_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_D1_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_D2_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_P0_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_P1_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_P2_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_P3_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_P4_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Type-C Select to Internal Crystal
            ScalerTypeCClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCPowerSwitch(_POWER_ACTION_AC_ON_TO_NORMAL);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // TCPM Select to Internal Crystal
            ScalerTypeCTcpmClockSetting(_IOSC_CLK);

            // Start From Initial State After Power On
            ScalerTypeCTcpmPowerSwitch(_ADAPTOR_TYPE_C_PORT, _POWER_ACTION_AC_ON_TO_NORMAL);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Request Port Controller to Re-Send Src Capability Message
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSendSrcCapability(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Src Cap
            ScalerTypeCSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Src Cap
            ScalerTypeCTcpmSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_SEND_SRC_CAP);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    // Clear Source Capability Change Flag
    SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_SEND_SRC_CAP);
}

//--------------------------------------------------
// Description  : Request Port Controller to Send Get_Status Message
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSendGetStatusMsg(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_D0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_D1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_D2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P0_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P1_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P2_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P3_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_P4_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // Request Embedded TypeC to Send Get_Status Message
            ScalerTypeCSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // Request TCPM to Send Get_Status Message
            ScalerTypeCTcpmSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, _PD_SYS_EVENT_SEND_GET_STATUS_MSG);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    // Clear Send_Get_Status_Message Flag
    SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_SEND_GET_STATUS_MSG);
}

//--------------------------------------------------
// Description  : Update CC Function Control (Connect / Disconnect)
// Input Value  : enumTypeCPcbPort, enumCcFunction
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCCcFunctionChangeProc(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCCcFunction enumCcFunction)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_D0_TYPE_C_PORT, enumCcFunction);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_D0_TYPE_C_PORT, enumCcFunction);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_D0_TYPE_C_PORT, enumCcFunction);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_D0_TYPE_C_PORT, enumCcFunction);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_D0_TYPE_C_PORT, enumCcFunction);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_D1_TYPE_C_PORT, enumCcFunction);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_D1_TYPE_C_PORT, enumCcFunction);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_D1_TYPE_C_PORT, enumCcFunction);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_D1_TYPE_C_PORT, enumCcFunction);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_D1_TYPE_C_PORT, enumCcFunction);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_D2_TYPE_C_PORT, enumCcFunction);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_D2_TYPE_C_PORT, enumCcFunction);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_D2_TYPE_C_PORT, enumCcFunction);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_D2_TYPE_C_PORT, enumCcFunction);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_D2_TYPE_C_PORT, enumCcFunction);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_P0_TYPE_C_PORT, enumCcFunction);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_P0_TYPE_C_PORT, enumCcFunction);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_P0_TYPE_C_PORT, enumCcFunction);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_P0_TYPE_C_PORT, enumCcFunction);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_P0_TYPE_C_PORT, enumCcFunction);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_P1_TYPE_C_PORT, enumCcFunction);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_P1_TYPE_C_PORT, enumCcFunction);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_P1_TYPE_C_PORT, enumCcFunction);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_P1_TYPE_C_PORT, enumCcFunction);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_P1_TYPE_C_PORT, enumCcFunction);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_P2_TYPE_C_PORT, enumCcFunction);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_P2_TYPE_C_PORT, enumCcFunction);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_P2_TYPE_C_PORT, enumCcFunction);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_P2_TYPE_C_PORT, enumCcFunction);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_P2_TYPE_C_PORT, enumCcFunction);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_P3_TYPE_C_PORT, enumCcFunction);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_P3_TYPE_C_PORT, enumCcFunction);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_P3_TYPE_C_PORT, enumCcFunction);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_P3_TYPE_C_PORT, enumCcFunction);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_P3_TYPE_C_PORT, enumCcFunction);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_P4_TYPE_C_PORT, enumCcFunction);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_P4_TYPE_C_PORT, enumCcFunction);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_P4_TYPE_C_PORT, enumCcFunction);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_P4_TYPE_C_PORT, enumCcFunction);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_P4_TYPE_C_PORT, enumCcFunction);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCCcFunctionControl(_ADAPTOR_TYPE_C_PORT, enumCcFunction);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmCcFunctionControl(_ADAPTOR_TYPE_C_PORT, enumCcFunction);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsCcFunctionControl(_ADAPTOR_TYPE_C_PORT, enumCcFunction);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdCcFunctionControl(_ADAPTOR_TYPE_C_PORT, enumCcFunction);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserCcFunctionControl(_ADAPTOR_TYPE_C_PORT, enumCcFunction);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    // Clear CC Function Change Flag
    if(enumCcFunction == _TYPE_C_CC_FUNCTION_ENABLE)
    {
        SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_CC_FUNC_CHG_ENABLE);
    }
    else if(enumCcFunction == _TYPE_C_CC_FUNCTION_DISABLE)
    {
        SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_CC_FUNC_CHG_DISABLE);
    }
}

//--------------------------------------------------
// Description  : Set Target Power Role to Control Power Direction
// Input Value  : enumTypeCPcbPort, enumPowerRole
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCPowerDirectionChangeProc(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_D0_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_D1_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_D2_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_P0_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_P1_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_P2_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_P3_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_P4_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ScalerTypeCSetTargetPowerMode(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ScalerTypeCTcpmSetTargetPowerMode(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetTargetPowerMode(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdSetTargetPowerMode(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetTargetPowerMode(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    // Clear Power Direction Change Flag
    if(enumPowerRole == _TYPE_C_POWER_SRC)
    {
        SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_POWER_DIRECTION_CHG_TO_SRC);
    }
    else if(enumPowerRole == _TYPE_C_POWER_SNK)
    {
        SysUsbTypeCClrCapabilityChangeFlag(enumTypeCPcbPort, _TYPE_C_POWER_DIRECTION_CHG_TO_SNK);
    }
}

//--------------------------------------------------
// Description  : Clear Capability Change Flag
// Input Value  : enumTypeCPcbPort, enumCapability --> Target Capability
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCClrCapabilityChangeFlag(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCCapChgStatus enumCapability)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_D0_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_D1_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_D2_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_P0_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_P1_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_P2_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_P3_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_P4_TYPE_C_PORT, enumCapability);

            break;
#endif

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            CLR_USB_TYPE_C_CAPABILITY_CHG(_ADAPTOR_TYPE_C_PORT, enumCapability);

            break;
#endif

        default:
            break;
    }
}

//--------------------------------------------------
// Description  : Check if Specific User Event Has Been Set
// Input Value  : enumTypeCPcbPort, enumUserEvent
// Output Value : _TRUE / _FALSE
//--------------------------------------------------
bit SysUsbTypeCCheckUserEvent(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCUserEvent enumUserEvent)
{
    switch(enumUserEvent)
    {
        case _TYPE_C_USER_EVENT_SEND_HARD_RESET:

            if((GET_USB_TYPE_C_USER_EVENT(enumTypeCPcbPort) & _TYPE_C_USER_EVENT_SEND_HARD_RESET) == _TYPE_C_USER_EVENT_SEND_HARD_RESET)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        default:

            return _FALSE;

            break;
    }

    return _FALSE;
}

//--------------------------------------------------
// Description  : Specific User Event Proc
// Input Value  : enumTypeCPcbPort, usUserEvent
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUserEventProc(EnumTypeCPcbPort enumTypeCPcbPort, WORD usUserEvent)
{
    // Check Whether Specific User Event Has Been Set or Not
    if(((usUserEvent & _TYPE_C_USER_EVENT_SEND_HARD_RESET) == _TYPE_C_USER_EVENT_SEND_HARD_RESET) && (SysUsbTypeCCheckUserEvent(enumTypeCPcbPort, _TYPE_C_USER_EVENT_SEND_HARD_RESET) == _TRUE))
    {
        // Set Send Hard Reset System Event Macro
        SysUsbTypeCSetPdSystemEvent(enumTypeCPcbPort, _PD_SYS_EVENT_SEND_HARD_RESET);

        // Clear Send Hard Reset Flag
        SysUsbTypeCClrUserEventFlag(enumTypeCPcbPort, _TYPE_C_USER_EVENT_SEND_HARD_RESET);
    }
}

//--------------------------------------------------
// Description  : Clear User Event Flag
// Input Value  : enumTypeCPcbPort, enumUserEvent --> Target User Event
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCClrUserEventFlag(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCUserEvent enumUserEvent)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_D0_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_D1_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_D2_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_P0_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_P1_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_P2_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_P3_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_P4_TYPE_C_PORT, enumUserEvent);

            break;
#endif

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            CLR_USB_TYPE_C_USER_EVENT(_ADAPTOR_TYPE_C_PORT, enumUserEvent);

            break;
#endif

        default:
            break;
    }
}

//--------------------------------------------------
// Description  : Set Type-C System Event Request to PD/CC FW
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPdSystemEvent(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPDSysEvent enumPdSysEvent)
{
    enumPdSysEvent = enumPdSysEvent;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_D0_TYPE_C_PORT, enumPdSysEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_D0_TYPE_C_PORT, enumPdSysEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_D0_TYPE_C_PORT, enumPdSysEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_D0_TYPE_C_PORT, enumPdSysEvent);
#endif
            break;
#endif  // End of #if(_D0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_D1_TYPE_C_PORT, enumPdSysEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_D1_TYPE_C_PORT, enumPdSysEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_D1_TYPE_C_PORT, enumPdSysEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_D1_TYPE_C_PORT, enumPdSysEvent);
#endif

            break;
#endif  // End of #if(_D1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_D2_TYPE_C_PORT, enumPdSysEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_D2_TYPE_C_PORT, enumPdSysEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_D2_TYPE_C_PORT, enumPdSysEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_D2_TYPE_C_PORT, enumPdSysEvent);
#endif

            break;
#endif  // End of #if(_D2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_P0_TYPE_C_PORT, enumPdSysEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_P0_TYPE_C_PORT, enumPdSysEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_P0_TYPE_C_PORT, enumPdSysEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_P0_TYPE_C_PORT, enumPdSysEvent);
#endif
            break;
#endif  // End of #if(_P0_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_P1_TYPE_C_PORT, enumPdSysEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_P1_TYPE_C_PORT, enumPdSysEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_P1_TYPE_C_PORT, enumPdSysEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_P1_TYPE_C_PORT, enumPdSysEvent);
#endif
            break;
#endif  // End of #if(_P1_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_P2_TYPE_C_PORT, enumPdSysEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_P2_TYPE_C_PORT, enumPdSysEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_P2_TYPE_C_PORT, enumPdSysEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_P2_TYPE_C_PORT, enumPdSysEvent);
#endif
            break;
#endif  // End of #if(_P2_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_P3_TYPE_C_PORT, enumPdSysEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_P3_TYPE_C_PORT, enumPdSysEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_P3_TYPE_C_PORT, enumPdSysEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_P3_TYPE_C_PORT, enumPdSysEvent);
#endif
            break;
#endif  // End of #if(_P3_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_P4_TYPE_C_PORT, enumPdSysEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_P4_TYPE_C_PORT, enumPdSysEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_P4_TYPE_C_PORT, enumPdSysEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_P4_TYPE_C_PORT, enumPdSysEvent);
#endif
            break;
#endif  // End of #if(_P4_DP_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, enumPdSysEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, enumPdSysEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, enumPdSysEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetPdSystemEvent(_ADAPTOR_TYPE_C_PORT, enumPdSysEvent);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : USB TypeC System Layer Unattach Reset Process
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCUnattachReset(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCCableInfoForDpcd stTypeCCableInfoForDpcd = {_PD_CBL_COMPONENT_PASSIVE, _PD_CBL_MAX_DP_RATE_UNCONFIRMED, _FALSE};

    // RTS Port Ctrl does not Support Initial RDO Flow
    if(ScalerTypeCGetPortCtrlType(enumTypeCPcbPort) != _TYPE_C_PORT_CTRL_RTS)
    {
        // Update Initial RDO
        SysUsbTypeCUpdatePortCtrlInitRdo(enumTypeCPcbPort);
    }

    // Clear Pin Assignment Info & Reconnect Flag
    CLR_USB_TYPE_C_RECONNECT(enumTypeCPcbPort);

    // Reset Cable Info / Attach Status / Orientation / Explicit Contract / Pin Assignment and Update Display Config
    ScalerTypeCSetCableInfoForDpcd(enumTypeCPcbPort, stTypeCCableInfoForDpcd);
    ScalerTypeCSetCcAttach(enumTypeCPcbPort, _TYPE_C_UNATTACH);
    SysUsbTypeCSetOrientation(enumTypeCPcbPort, _TYPE_C_ORIENTATION_NONE);
    SysUsbTypeCSetExplicitContract(enumTypeCPcbPort, _FALSE);
    SysUsbTypeCSetPinAssignment(enumTypeCPcbPort, _TYPE_C_PIN_ASSIGNMENT_NONE);
    SysUsbTypeCUpdateDisplayConfig(enumTypeCPcbPort);

#if((_TYPE_C_MODAL_OPERATION_SUPPORT == _ON) && (_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_LENOVO_ALT_MODE))
    SET_USB_TYPE_C_LENOVO_ALT_MODE_STATUS(enumTypeCPcbPort, _TYPE_C_LENOVO_ALT_MODE_NOT_READY);
    SET_USB_TYPE_C_LENOVO_DEVICE_TYPE(enumTypeCPcbPort, _TYPE_C_LENOVO_DEVICE_TYPE_NONE);
    CLR_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(enumTypeCPcbPort);
#endif

#if(_PORT_CTRL_RTS_SUPPORT == _ON)
    UserCommonUsbTypeCRtsReset(enumTypeCPcbPort);
#endif
}

//--------------------------------------------------
// Description  : Request Port Controller to Reconnect
// Input Value  : enumTypeCPcbPort
// Output Value : Reconnect Status (_SUCCESS / _FAIL)
//--------------------------------------------------
bit SysUsbTypeCReconnect(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_TYPE == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCReconnect(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmReconnect(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            return UserCommonUsbTypeCRtsReconnect(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            return UserCommonUsbTypeCRtdReconnect(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            return UserCommonUsbTypeCUserReconnect(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            return _FAIL;

            break;
    }
    return _FAIL;
}

//--------------------------------------------------
// Description  : Ask Port Controller to Wait for New DP Config
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCWaitDpConfigUpdate(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_TYPE == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCWaitDpConfigUpdate(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmWaitDpConfigUpdate(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Control Connection Detect Flag
// Input Value  : enumTypeCPcbPort, bEn = _ENABLE/_DISABLE
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCConnectionDetCtrl(EnumTypeCPcbPort enumTypeCPcbPort, bit bEn)
{
    // 1. Control SYS CONNECTION_DET Flag
    if(bEn == _ENABLE)
    {
        SET_USB_TYPE_C_CONNECTION_DET(enumTypeCPcbPort);
    }
    else
    {
        CLR_USB_TYPE_C_CONNECTION_DET(enumTypeCPcbPort);
    }

    // 2. Control Det Flag for Ext Port Controller when Detect By SMBUS
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_D0_TYPE_C_PORT, bEn);
#endif

#if(_D0_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_D0_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_D1_TYPE_C_PORT, bEn);
#endif

#if(_D1_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_D1_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_D2_TYPE_C_PORT, bEn);
#endif

#if(_D2_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_D2_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_P0_TYPE_C_PORT, bEn);
#endif

#if(_P0_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_P0_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_P1_TYPE_C_PORT, bEn);
#endif

#if(_P1_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_P1_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_P2_TYPE_C_PORT, bEn);
#endif

#if(_P2_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_P2_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_P3_TYPE_C_PORT, bEn);
#endif

#if(_P3_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_P3_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_P4_TYPE_C_PORT, bEn);
#endif

#if(_P4_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_P4_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetCCAttachCtrl(_ADAPTOR_TYPE_C_PORT, bEn);
#endif

#if(_ADAPTOR_TYPE_C_EXT_ALT_MODE_READY_DETECT == _EXT_PORT_CTRL_DETECT_BY_SMBUS)
            UserCommonUsbTypeCRtsI2CDetAltModeReadyCtrl(_ADAPTOR_TYPE_C_PORT, bEn);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Transit Type C State After Reconnect Success
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCRestartConnectionDet(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Default Set Restart Connection Det Time = 100ms (tCcDebounce = 100 ~ 200ms)
    WORD usRestartDetTime = 100;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_D0_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_D0_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl Rts/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl Rts/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_D0_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_D1_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_D1_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl Rts/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl Rts/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_D1_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_D2_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_D2_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl Rts/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl Rts/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_D2_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_P0_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_P0_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl RTS/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl RTS/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_P0_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_P1_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_P1_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl RTS/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl RTS/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_P1_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_P2_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_P2_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl RTS/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl RTS/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_P2_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_P3_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_P3_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl RTS/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl RTS/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_P3_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_P4_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_P4_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl RTS/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl RTS/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_P4_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // 1. Disable Connection Detect
            SysUsbTypeCConnectionDetCtrl(_ADAPTOR_TYPE_C_PORT, _DISABLE);

            // 2. Setting Restart Detection Timing
#if((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))
            // Setting Port Ctrl Embedded Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_EMB_CONNECTION_DET_TIME;
#elif(_ADAPTOR_TYPE_C_EXT_CC_ATTACH_DETECT == _EXT_PORT_CTRL_DETECT_BY_PCB_MACRO)
            // Setting Port Ctrl RTS/User with GPIO Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_PCB_CONNECTION_DET_TIME;
#else
            // Setting Port Ctrl RTS/User with I2C Link Restart Detection Time
            usRestartDetTime = _USB_TYPE_C_RESTART_I2C_CONNECTION_DET_TIME;
#endif  // End of ((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED) || (_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM))

            // 3. Re-ActiveTimerEvent to Re-Start Port Ctrl CC Attach/Alt Mode Ready Detecttion
            ScalerTimerReactiveTimerEvent(usRestartDetTime, _SYSTEM_TIMER_EVENT_ADAPTOR_TYPE_C_CONNECTION_DET);

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Update Port Controller Configuration
// Input Value  : enumTypeCPcbPort
// Output Value : Reconnect Status (_SUCCESS / _FAIL)
//--------------------------------------------------
bit SysUsbTypeCUpdatePortControllerConfig(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCMultiFuncStatus enumMultiFunc = _TYPE_C_MULTI_FUNC_NOT_PREFER;
    EnumTypeCPinCfgCapType enumPinAssignmentCap = _TYPE_C_PIN_ASSIGNMENT_CAP_NONE;

    // Update Pin Assignment Capability (From User)
    enumPinAssignmentCap = UserCommonUsbTypeCGetPinAssignmentConfig(enumTypeCPcbPort);
    SET_USB_TYPE_C_TARGET_PIN_ASSIGNMENT_CAP(enumTypeCPcbPort, enumPinAssignmentCap);

    // Update Multi-Function Status (From User)
    enumMultiFunc = UserCommonUsbTypeCGetMultiFuncConfig(enumTypeCPcbPort, enumPinAssignmentCap);
    SET_USB_TYPE_C_TARGET_MULTI_FUNCTION(enumTypeCPcbPort, enumMultiFunc);

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config D0 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_D0_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_D0_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_D0_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config D1 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_D1_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_D1_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_D1_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config D2 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_D2_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_D2_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_D2_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config P0 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_P0_TYPE_C_PORT, _TYPE_C_MULTI_FUNC_NOT_PREFER, _TYPE_C_PIN_ASSIGNMENT_CAP_CE);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_P0_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_P0_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config P1 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_P1_TYPE_C_PORT, _TYPE_C_MULTI_FUNC_NOT_PREFER, _TYPE_C_PIN_ASSIGNMENT_CAP_CE);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_P1_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_P1_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config P2 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_P2_TYPE_C_PORT, _TYPE_C_MULTI_FUNC_NOT_PREFER, _TYPE_C_PIN_ASSIGNMENT_CAP_CE);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_P2_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_P2_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config P3 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_P3_TYPE_C_PORT, _TYPE_C_MULTI_FUNC_NOT_PREFER, _TYPE_C_PIN_ASSIGNMENT_CAP_CE);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_P3_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_P3_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            DebugMessageTypeC("8. ======== Config P4 Port Controller Pin Assignment ======== ", enumPinAssignmentCap);
#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            return ScalerTypeCUpdateConfig(_P4_TYPE_C_PORT, _TYPE_C_MULTI_FUNC_NOT_PREFER, _TYPE_C_PIN_ASSIGNMENT_CAP_CE);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            return ScalerTypeCTcpmUpdateConfig(_P4_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD) || (_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER))
            return UserCommonUsbTypeCUpdateConfig(_P4_TYPE_C_PORT, enumMultiFunc, enumPinAssignmentCap);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:
            // Adaptor Cannot Update Config Since No USB & Alt Mode
            return _FAIL;

            break;
    }
    return _FAIL;
}

//--------------------------------------------------
// Description  : Return TypeC Port CC Attached Status According to TypeC State
// Input Value  : enumTypeCPcbPort --> PCB TypeC Port Converted from PCB Port
// Output Value : CC Attach Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCGetCcAttach(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(GET_USB_TYPE_C_STATE(enumTypeCPcbPort))
    {
        case _USB_TYPE_C_ATTACHED_STATE:
        case _USB_TYPE_C_DP_ALT_MODE_READY_STATE:

            return _TRUE;

            break;

        case _USB_TYPE_C_UNATTACH_STATE:
        default:

            return _FALSE;

            break;
    }
    return _FALSE;
}

//--------------------------------------------------
// Description  : Return TypeC Port Alt Mode Ready Status According to TypeC State
// Input Value  : enumTypeCPcbPort --> PCB TypeC Port Converted from PCB Port
// Output Value : CC Attach Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCGetAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(GET_USB_TYPE_C_STATE(enumTypeCPcbPort))
    {
        case _USB_TYPE_C_DP_ALT_MODE_READY_STATE:

            if(UserCommonUsbTypeCGetDpAltModeWaitStatus(enumTypeCPcbPort) == _TYPE_C_ALT_MODE_NOT_WAIT)
            {
                return _TRUE;
            }
            else
            {
                return _FALSE;
            }

            break;

        case _USB_TYPE_C_UNATTACH_STATE:
        case _USB_TYPE_C_ATTACHED_STATE:
        default:

            return _FALSE;

            break;
    }
    return _FALSE;
}

//--------------------------------------------------
// Description  : Return TypeC Port Data Role
// Input Value  : enumTypeCPcbPort
// Output Value : EnumTypeCDataRole (_TYPE_C_DATA_ROLE_NONE / _TYPE_C_UFP_U / _TYPE_C_DFP_U)
//--------------------------------------------------
EnumTypeCDataRole SysUsbTypeCGetDataRole(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCDataRole enumTypeCDataRole = _TYPE_C_DATA_ROLE_NONE;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return enumTypeCDataRole;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDataRole = ScalerTypeCGetDataRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDataRole = ScalerTypeCTcpmGetDataRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCDataRole = UserCommonUsbTypeCRtsGetDataRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCDataRole = UserCommonUsbTypeCRtdGetDataRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCDataRole = UserCommonUsbTypeCUserGetDataRole(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumTypeCDataRole;
}

//--------------------------------------------------
// Description  : Return TypeC Port Power Role
// Input Value  : enumTypeCPcbPort
// Output Value : EnumTypeCPowerRole (_TYPE_C_POWER_ROLE_NONE / _TYPE_C_POWER_SNK / _TYPE_C_POWER_SRC)
//--------------------------------------------------
EnumTypeCPowerRole SysUsbTypeCGetPowerRole(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCPowerRole enumTypeCPowerRole = _TYPE_C_POWER_ROLE_NONE;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return enumTypeCPowerRole;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPowerRole = ScalerTypeCGetPowerRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPowerRole = ScalerTypeCTcpmGetPowerRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumTypeCPowerRole = UserCommonUsbTypeCRtsGetPowerRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            enumTypeCPowerRole = UserCommonUsbTypeCRtdGetPowerRole(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumTypeCPowerRole = UserCommonUsbTypeCUserGetPowerRole(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumTypeCPowerRole;
}

//--------------------------------------------------
// Description  : Return TypeC Port Partner Flag (Current Operating Mode)
// Input Value  : enumTypeCPcbPort
// Output Value : Port Partner Flag (BIT0 : USB / BIT1 : Alt Mode)
//--------------------------------------------------
BYTE SysUsbTypeCGetPortPartnerFlag(EnumTypeCPcbPort enumTypeCPcbPort)
{
    BYTE ucPortPartnerFlag = 0x00;

    // Only For RTS Port Ctrl
    // BIT0 : Port Controller is Operating in USB Mode
    // BIT1 : Port Controller is operating in Alt Mode
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortPartnerFlag = ScalerTypeCGetPortPartnerFlag(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortPartnerFlag = ScalerTypeCTcpmGetPortPartnerFlag(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            ucPortPartnerFlag = UserCommonUsbTypeCRtsGetPortPartnerFlag(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            // ucPortPartnerFlag = UserCommonUsbTypeCRtdGetPortPartnerFlag(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortPartnerFlag = UserCommonUsbTypeCUserGetPortPartnerFlag(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return ucPortPartnerFlag;
}

//--------------------------------------------------
// Description  : Return TypeC Port Number of Src/Snk PDOs
// Input Value  : enumTypeCPcbPort, enumPowerRole (Src/Snk SPR PDO)
// Output Value : Number of PDO Counts (1 ~ 11)
//--------------------------------------------------
BYTE SysUsbTypeCGetPdoCnt(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole)
{
    BYTE ucPdoCnt = 0;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return ucPdoCnt;
    }
    else
    {
        return SysUsbTypeCGetPortControllerPdoCnt(enumTypeCPcbPort, enumPowerRole);
    }
}

//--------------------------------------------------
// Description  : Return TypeC Port Source/Sink PDO Info
// Input Value  : enumTypeCPcbPort, enumPowerRole (Src/Snk PDO), ucPdoIndex : 1~7
// Output Value : StructTypeCUserPDO (Voltage Unit = 100mV / Current = 10mA)
//--------------------------------------------------
StructTypeCUserPDO SysUsbTypeCGetPdo(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole, BYTE ucPdoIndex)
{
    StructTypeCUserPDO stTypeCPdo = {_PD_FIX_SUPPLY_PDO, _PD_PEAK_CUR_NONE, 0x00, 0x00, 0x00};

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return stTypeCPdo;
    }
    else
    {
        return SysUsbTypeCGetPortControllerPdo(enumTypeCPcbPort, enumPowerRole, ucPdoIndex);
    }
}

//--------------------------------------------------
// Description  : Return TypeC Port Number of Partner Src/Snk PDOs
// Input Value  : enumTypeCPcbPort, enumPowerRole (Src/Snk PDO)
// Output Value : Number of PDO Counts (1~7)
//--------------------------------------------------
BYTE SysUsbTypeCGetPartnerPdoCnt(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole)
{
    BYTE ucPdoCnt = 0;
    BYTE ucSPRPdoCnt = 0;
    BYTE ucEPRPdoCnt = 0;

    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPowerRole = enumPowerRole;
    ucSPRPdoCnt = ucSPRPdoCnt;
    ucEPRPdoCnt = ucEPRPdoCnt;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return ucPdoCnt;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_D0_TYPE_C_PORT, enumPowerRole);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_D0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_D0_TYPE_C_PORT, enumPowerRole);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_D0_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_D1_TYPE_C_PORT, enumPowerRole);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_D1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_D1_TYPE_C_PORT, enumPowerRole);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_D1_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_D2_TYPE_C_PORT, enumPowerRole);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_D2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_D2_TYPE_C_PORT, enumPowerRole);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_D2_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_P0_TYPE_C_PORT, enumPowerRole);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_P0_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_P0_TYPE_C_PORT, enumPowerRole);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_P0_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_P1_TYPE_C_PORT, enumPowerRole);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_P1_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_P1_TYPE_C_PORT, enumPowerRole);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_P1_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_P2_TYPE_C_PORT, enumPowerRole);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_P2_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_P2_TYPE_C_PORT, enumPowerRole);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_P2_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_P3_TYPE_C_PORT, enumPowerRole);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_P3_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_P3_TYPE_C_PORT, enumPowerRole);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_P3_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_P4_TYPE_C_PORT, enumPowerRole);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_P4_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_P4_TYPE_C_PORT, enumPowerRole);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_P4_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ucPdoCnt = ScalerTypeCGetPartnerPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ucPdoCnt = ScalerTypeCTcpmGetPartnerPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            UserCommonUsbTypeCRtsGetPartnerPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole, &ucSPRPdoCnt, &ucEPRPdoCnt);

            if(ucEPRPdoCnt != 0)
            {
                ucPdoCnt = 7 + ucEPRPdoCnt;
            }
            else
            {
                ucPdoCnt = ucSPRPdoCnt;
            }
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            ucPdoCnt = UserCommonUsbTypeCRtdGetPartnerPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            ucPdoCnt = UserCommonUsbTypeCUserGetPartnerPdoCnt(_ADAPTOR_TYPE_C_PORT, enumPowerRole);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
    return ucPdoCnt;
}

//--------------------------------------------------
// Description  : Return TypeC Port Partner Source/Sink PDO Info
// Input Value  : enumTypeCPcbPort, enumPowerRole (Src/Snk PDO), ucPdoIndex : 1~7
// Output Value : StructTypeCUserPDO (Voltage Unit = 100mV / Current = 10mA)
//--------------------------------------------------
StructTypeCUserPDO SysUsbTypeCGetPartnerPdo(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPowerRole enumPowerRole, BYTE ucPdoIndex)
{
    StructTypeCUserPDO stTypeCPartnerPdo = {_PD_FIX_SUPPLY_PDO, _PD_PEAK_CUR_NONE, 0x00, 0x00, 0x00};

    enumTypeCPcbPort = enumTypeCPcbPort;
    enumPowerRole = enumPowerRole;
    ucPdoIndex = ucPdoIndex;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return stTypeCPartnerPdo;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_D0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_D1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_D2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_P0_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_P1_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_P2_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_P3_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_P4_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCPartnerPdo = ScalerTypeCGetPartnerPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCPartnerPdo = ScalerTypeCTcpmGetPartnerPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCPartnerPdo = UserCommonUsbTypeCRtsGetPartnerPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCPartnerPdo = UserCommonUsbTypeCRtdGetPartnerPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCPartnerPdo = UserCommonUsbTypeCUserGetPartnerPdo(_ADAPTOR_TYPE_C_PORT, enumPowerRole, ucPdoIndex);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
    return stTypeCPartnerPdo;
}

//--------------------------------------------------
// Description  : Return TypeC Port PDO Status
// Input Value  : enumTypeCPcbPort, *pusVoltage (Unit: 10mV), *pusCurrent (Unit: 10mA)
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCGetPdoStatus(EnumTypeCPcbPort enumTypeCPcbPort, WORD *pusVoltage, WORD *pusCurrent)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    *pusVoltage = 0;
    *pusCurrent = 0;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_D0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_D0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_D0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_D0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_D0_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_D1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_D1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_D1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_D1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_D1_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_D2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_D2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_D2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_D2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_D2_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_P0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_P0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_P0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_P0_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_P0_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_P1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_P1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_P1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_P1_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_P1_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_P2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_P2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_P2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_P2_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_P2_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_P3_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_P3_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_P3_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_P3_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_P3_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_P4_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_P4_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_P4_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_P4_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_P4_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCGetPdoStatus(_ADAPTOR_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return 5V / Current According to Rp Value
            // CC Unattached: Return Voltage & Current = 0
            ScalerTypeCTcpmGetPdoStatus(_ADAPTOR_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            // CC Attached, Power Contract Established: Return Negotiated Voltage & Current
            // CC Attached, No Power Contract: Return Voltage & Current = 0
            // CC Unattached: Return Voltage & Current = 0
            UserCommonUsbTypeCRtsGetPdoStatus(_ADAPTOR_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            UserCommonUsbTypeCRtdGetPdoStatus(_ADAPTOR_TYPE_C_PORT, pusVoltage, pusCurrent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserGetPdoStatus(_ADAPTOR_TYPE_C_PORT, pusVoltage, pusCurrent);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Return TypeC Port Current Source PDO that Sink Request
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCUserPDO (Voltage Unit = 100mV / Current = 10mA)
//--------------------------------------------------
StructTypeCUserPDO SysUsbTypeCGetRequestedSrcPdo(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCUserPDO stTypeCSrcPdo = {_PD_FIX_SUPPLY_PDO, _PD_PEAK_CUR_NONE, 0x00, 0x00, 0x00};

    enumTypeCPcbPort = enumTypeCPcbPort;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return stTypeCSrcPdo;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stTypeCSrcPdo = ScalerTypeCGetRequestedSrcPdo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stTypeCSrcPdo = ScalerTypeCTcpmGetRequestedSrcPdo(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            stTypeCSrcPdo = UserCommonUsbTypeCRtsGetRequestedSrcPdo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTD)
            stTypeCSrcPdo = UserCommonUsbTypeCRtdGetRequestedSrcPdo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stTypeCSrcPdo = UserCommonUsbTypeCUserGetRequestedSrcPdo(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
    return stTypeCSrcPdo;
}

//--------------------------------------------------
// Description  : Return TypeC Cable PD Capability
// Input Value  : enumTypeCPcbPort
// Output Value : TypeC Cable PD Capability (_TYPE_C_CABLE_PD_CAP_UNCONFIRMED / _TYPE_C_CABLE_NON_PD_CAPABLE / _TYPE_C_CABLE_DISCOVER_ID_ACK_RECEIVED)
//--------------------------------------------------
EnumTypeCCablePdCapability SysUsbTypeCGetCablePdCapability(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCCablePdCapability enumTypeCCablePdCap = _TYPE_C_CABLE_PD_CAP_UNCONFIRMED;
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCCablePdCap = ScalerTypeCGetCablePdCapability(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCCablePdCap = ScalerTypeCTcpmGetCablePdCapability(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCCablePdCap = UserCommonUsbTypeCRtsGetCablePdCapability(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCCablePdCap = UserCommonUsbTypeCUserGetCablePdCapability(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumTypeCCablePdCap;
}

//--------------------------------------------------
// Description  : Return TypeC Product Type when in UFP Data Role
// Input Value  : enumTypeCPcbPort
// Output Value : TypeC Product Type UFP (_TYPE_C_UFP_PRODUCT_TYPE_UNDEFINED / _TYPE_C_UFP_PRODUCT_TYPE_HUB / _TYPE_C_UFP_PRODUCT_TYPE_PERIPHERAL)
//--------------------------------------------------
EnumTypeCUFPProductType SysUsbTypeCGetUFPProductType(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCUFPProductType enumTypeCUFPProductType = _TYPE_C_UFP_PRODUCT_TYPE_UNDEFINED;
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCUFPProductType = ScalerTypeCGetUFPProductType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCUFPProductType = ScalerTypeCTcpmGetUFPProductType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCUFPProductType = UserCommonUsbTypeCRtsGetUFPProductType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCUFPProductType = UserCommonUsbTypeCUserGetUFPProductType(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumTypeCUFPProductType;
}

//--------------------------------------------------
// Description  : Return TypeC Product Type when in DFP Data Role
// Input Value  : enumTypeCPcbPort
// Output Value : TypeC Product Type DFP (_TYPE_C_DFP_PRODUCT_TYPE_UNDEFINED / _TYPE_C_DFP_PRODUCT_TYPE_HUB / _TYPE_C_DFP_PRODUCT_TYPE_HOST / _TYPE_C_DFP_PRODUCT_TYPE_BRICK)
//--------------------------------------------------
EnumTypeCDFPProductType SysUsbTypeCGetDFPProductType(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCDFPProductType enumTypeCDFPProductType = _TYPE_C_DFP_PRODUCT_TYPE_UNDEFINED;
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCDFPProductType = ScalerTypeCGetDFPProductType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCDFPProductType = ScalerTypeCTcpmGetDFPProductType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCDFPProductType = UserCommonUsbTypeCRtsGetDFPProductType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCDFPProductType = UserCommonUsbTypeCUserGetDFPProductType(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumTypeCDFPProductType;
}

//--------------------------------------------------
// Description  : Return TypeC Cable Max Current
// Input Value  : enumTypeCPcbPort
// Output Value : TypeC Cable Max Current (Unit: 10mA)
//--------------------------------------------------
WORD SysUsbTypeCGetCableMaxCurrent(EnumTypeCPcbPort enumTypeCPcbPort)
{
    WORD usCableMaxCurrent = 0;
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            usCableMaxCurrent = ScalerTypeCGetCableMaxCurrent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            usCableMaxCurrent = ScalerTypeCTcpmGetCableMaxCurrent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // usCableMaxCurrent = UserCommonUsbTypeCRtsGetCableMaxCurrent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // usCableMaxCurrent = UserCommonUsbTypeCUserGetCableMaxCurrent(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return usCableMaxCurrent;
}

//--------------------------------------------------
// Description  : Return TypeC Port Controller Event
// Input Value  : enumTypeCPcbPort
// Output Value : TypeC Port Controller Event (_PD_PORT_CTRL_EVENT_POWER_OCP / _PD_PORT_CTRL_EVENT_POWER_OVP...)
//--------------------------------------------------
EnumTypeCPDPortCtrlEvent SysUsbTypeCGetPortCtrlEvent(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCPDPortCtrlEvent enumTypeCPortCtrlEvent = _PD_PORT_CTRL_EVENT_NONE;
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumTypeCPortCtrlEvent = ScalerTypeCGetPortCtrlEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            enumTypeCPortCtrlEvent = ScalerTypeCTcpmGetPortCtrlEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCRtsGetPortCtrlEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumTypeCPortCtrlEvent = UserCommonUsbTypeCUserGetPortCtrlEvent(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return enumTypeCPortCtrlEvent;
}

//--------------------------------------------------
// Description  : Clear TypeC Port Controller Event
// Input Value  : enumTypeCPcbPort, enumTypeCPortCtrlEvent (_PD_PORT_CTRL_EVENT_POWER_OCP / _PD_PORT_CTRL_EVENT_POWER_OVP...)
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCClrPortCtrlEvent(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPDPortCtrlEvent enumTypeCPortCtrlEvent)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    enumTypeCPortCtrlEvent = enumTypeCPortCtrlEvent;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_D0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_D0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_D0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_D0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_D1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_D1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_D1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_D1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_D2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_D2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_D2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_D2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_P0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_P0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_P0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_P0_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_P1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_P1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_P1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_P1_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_P2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_P2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_P2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_P2_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_P3_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_P3_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_P3_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_P3_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCClrPortCtrlEvent(_P4_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            ScalerTypeCTcpmClrPortCtrlEvent(_P4_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsClrPortCtrlEvent(_P4_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserClrPortCtrlEvent(_P4_TYPE_C_PORT, enumTypeCPortCtrlEvent);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set User Event Flag
// Input Value  : enumTypeCPcbPort, enumUserEvent
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCSetUserEventFlag(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCUserEvent enumUserEvent)
{
    enumUserEvent = enumUserEvent;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_D0_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_D1_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_D2_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_P0_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_P1_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_P2_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_P3_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_P4_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            SET_USB_TYPE_C_USER_EVENT(_ADAPTOR_TYPE_C_PORT, enumUserEvent);
#endif
            break;

        default:
            break;
    }
}

//--------------------------------------------------
// Description  : Get Port Ctrl FW Version
// Input Value  : enumTypeCPcbPort --> _D0_TYPE_C_PORT / _D1_TYPE_C_PORT...
//                *pstTypeCFwVersion --> TypeC FW Version
// Output Value : Get FW Version Result (_SUCCESS / _FAIL)
//--------------------------------------------------
bit SysUsbTypeCGetFwVersion(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCPortCtrlFwVersion *pstTypeCFwVersion)
{
    enumTypeCPcbPort = enumTypeCPcbPort;
    pstTypeCFwVersion = pstTypeCFwVersion;

    return SysUsbTypeCGetPortControllerFwVersion(enumTypeCPcbPort, pstTypeCFwVersion);
}

//--------------------------------------------------
// Description  : Return TypeC Port Operation Mode
// Input Value  : enumTypeCPcbPort
// Output Value : Port Operation Mode Result
//--------------------------------------------------
BYTE SysUsbTypeCGetPortOperationMode(EnumTypeCPcbPort enumTypeCPcbPort)
{
    BYTE ucPortOpMode = 0x00;

    enumTypeCPcbPort = enumTypeCPcbPort;

    if(SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _FALSE)
    {
        return ucPortOpMode;
    }

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_D0_TYPE_C_PORT);
#elif((_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_D1_TYPE_C_PORT);
#elif((_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_D2_TYPE_C_PORT);
#elif((_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_P0_TYPE_C_PORT);
#elif((_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_P1_TYPE_C_PORT);
#elif((_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_P2_TYPE_C_PORT);
#elif((_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_P3_TYPE_C_PORT);
#elif((_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_P4_TYPE_C_PORT);
#elif((_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            // ucPortOpMode = ScalerTypeCGetPortOperationMode(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            // ucPortOpMode = ScalerTypeCTcpmGetPortOperationMode(_ADAPTOR_TYPE_C_PORT);
#elif((_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS) && (_TYPE_C_PORT_CTRL_RTS_PDO_INFO_SUPPORT == _ON))
            ucPortOpMode = UserCommonUsbTypeCRtsGetPortOperationMode(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // ucPortOpMode = UserCommonUsbTypeCUserGetPortOperationMode(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
    return ucPortOpMode;
}

//--------------------------------------------------
// Description  : Set Orientation Info to System & Scaler Macro
// Input Value  : enumTypeCPcbPort, Orientation
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetOrientation(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCOrientation enumOrientation)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_D0_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_D0_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_D1_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_D1_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_D2_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_D2_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_P0_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_P0_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_P1_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_P1_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_P2_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_P2_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_P3_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_P3_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_P4_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_P4_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Set System Level Orientation Macro
            SET_USB_TYPE_C_ORIENTATION(_ADAPTOR_TYPE_C_PORT, enumOrientation);

            // Set Scaler Level Orientation Macro
            ScalerTypeCSetOrientation(_ADAPTOR_TYPE_C_PORT, enumOrientation);

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set Pin Assignment Info to System & Scaler Macro
// Input Value  : enumTypeCPcbPort, Pin Assignment
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPinAssignment(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPinCfgType enumPinAssignment)
{
    enumPinAssignment = enumPinAssignment;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_D0_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_D0_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_D1_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_D1_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_D2_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_D2_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_P0_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_P0_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_P1_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_P1_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_P2_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_P2_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_P3_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_P3_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_P4_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_P4_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Set System Level Pin Assignment Macro
            SET_USB_TYPE_C_PIN_ASSIGNMENT(_ADAPTOR_TYPE_C_PORT, enumPinAssignment);

            // Set Scaler Level Pin Assignment Macro
            ScalerTypeCSetPinAssignment(_ADAPTOR_TYPE_C_PORT, enumPinAssignment);

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set Explicit Contract Info to Scaler Macro
// Input Value  : enumTypeCPcbPort, bGetExplicitContract
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetExplicitContract(EnumTypeCPcbPort enumTypeCPcbPort, bit bGetExplicitContract)
{
    bGetExplicitContract = bGetExplicitContract;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_D0_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_D1_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_D2_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_P0_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_P1_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_P2_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_P3_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_P4_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Set Scaler Level Explicit Contract Macro
            ScalerTypeCSetExplicitContract(_ADAPTOR_TYPE_C_PORT, bGetExplicitContract);

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Return CC Attached Status to Rx Input Port
// Input Value  : enumInputPort --> Inputput
// Output Value : CC Attach Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCRxGetCcAttach(EnumInputPort enumInputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbDxConvertToTypeCPort(enumInputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return SysUsbTypeCGetCcAttach(enumTypeCPcbPort);
    }
    else
    {
        return _FALSE;
    }
}

//--------------------------------------------------
// Description  : Return Alt Mode Ready Status to Rx Input Port
// Input Value  : enumInputPort --> Inputput
// Output Value : Alt Mode Ready Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCRxGetAltModeReady(EnumInputPort enumInputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbDxConvertToTypeCPort(enumInputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return SysUsbTypeCGetAltModeReady(enumTypeCPcbPort);
    }
    else
    {
        return _FALSE;
    }
}

//--------------------------------------------------
// Description  : Return PD Negotiated Pin Assignment to Rx Input Port
// Input Value  : enumInputPort --> Inputput
// Output Value : Alt Mode Ready Status (_TRUE / _FALSE)
//--------------------------------------------------
EnumTypeCPinCfgType SysUsbTypeCRxGetPinAssignment(EnumInputPort enumInputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbDxConvertToTypeCPort(enumInputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort);
    }
    else
    {
        return _TYPE_C_PIN_ASSIGNMENT_NONE;
    }
}

//--------------------------------------------------
// Description  : Return TypeC Orientation to Rx Input Port
// Input Value  : enumInputPort --> Inputput
// Output Value : TypeC Orientation Status (_TYPE_C_ORIENTATION_NONE / _TYPE_C_ORIENTATION_UNFLIP / _TYPE_C_ORIENTATION_FLIP)
//--------------------------------------------------
EnumTypeCOrientation SysUsbTypeCRxGetOrientation(EnumInputPort enumInputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbDxConvertToTypeCPort(enumInputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return GET_USB_TYPE_C_ORIENTATION(enumTypeCPcbPort);
    }
    else
    {
        return _TYPE_C_ORIENTATION_NONE;
    }
}

//--------------------------------------------------
// Description  : Return CC Attached Status to Tx Output Port
// Input Value  : enumOutputPort --> Output
// Output Value : CC Attach Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCTxGetCcAttach(EnumOutputPort enumOutputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbPxConvertToTypeCPort(enumOutputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return SysUsbTypeCGetCcAttach(enumTypeCPcbPort);
    }
    else
    {
        return _FALSE;
    }
}

//--------------------------------------------------
// Description  : Return Alt Mode Ready Status to Tx Output Port
// Input Value  : enumOutputPort --> Output
// Output Value : Alt Mode Ready Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCTxGetAltModeReady(EnumOutputPort enumOutputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbPxConvertToTypeCPort(enumOutputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return SysUsbTypeCGetAltModeReady(enumTypeCPcbPort);
    }
    else
    {
        return _FALSE;
    }
}

//--------------------------------------------------
// Description  : Return PD Negotiated Pin Assignment to Tx Output Port
// Input Value  : enumOutputPort --> Output
// Output Value : Alt Mode Ready Status (_TRUE / _FALSE)
//--------------------------------------------------
EnumTypeCPinCfgType SysUsbTypeCTxGetPinAssignment(EnumOutputPort enumOutputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbPxConvertToTypeCPort(enumOutputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort);
    }
    else
    {
        return _TYPE_C_PIN_ASSIGNMENT_NONE;
    }
}

//--------------------------------------------------
// Description  : Return TypeC Orientation to Tx Output Port
// Input Value  : enumOutputPort --> Output
// Output Value : TypeC Orientation Status (_TYPE_C_ORIENTATION_NONE / _TYPE_C_ORIENTATION_UNFLIP / _TYPE_C_ORIENTATION_FLIP)
//--------------------------------------------------
EnumTypeCOrientation SysUsbTypeCTxGetOrientation(EnumOutputPort enumOutputPort)
{
    EnumTypeCPcbPort enumTypeCPcbPort = SysUsbPxConvertToTypeCPort(enumOutputPort);

    if(enumTypeCPcbPort != _NO_TYPE_C_PORT)
    {
        return GET_USB_TYPE_C_ORIENTATION(enumTypeCPcbPort);
    }
    else
    {
        return _TYPE_C_ORIENTATION_NONE;
    }
}

//--------------------------------------------------
// Description  : Translate Alt. Mode Pin Assignment to DP Lane Count
// Input Value  : enumTypeCPcbPort, enumPinAssignment : _TYPE_C_PIN_ASSIGNMENT_C / _TYPE_C_PIN_ASSIGNMENT_D / _TYPE_C_PIN_ASSIGNMENT_E
// Output Value : EnumDpLaneCount -> _DP_LINK_1_LANE / _DP_LINK_2_LANE / _DP_LINK_4_LANE
//--------------------------------------------------
EnumDpLaneCount SysUsbTypeCGetAltModeLaneCnt(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCPinCfgType enumPinAssignment)
{
    EnumDpLaneCount enumAltModeLaneCnt = _DP_LINK_4_LANE;
    enumTypeCPcbPort = enumTypeCPcbPort;

#if(_TYPE_C_EIZO_CUSTOMIZED_DP_LANE_CNT_SUPPORT == _OFF)
    switch(enumPinAssignment)
    {
        case _TYPE_C_PIN_ASSIGNMENT_C:
        case _TYPE_C_PIN_ASSIGNMENT_E:

            enumAltModeLaneCnt = _DP_LINK_4_LANE;

            break;

        case _TYPE_C_PIN_ASSIGNMENT_D:

            enumAltModeLaneCnt = _DP_LINK_2_LANE;

            break;


        default:

            break;
    }
#else
    enumAltModeLaneCnt = UserCommonUsbTypeCGetAltModeLaneCnt(enumTypeCPcbPort, enumPinAssignment);
#endif

    return enumAltModeLaneCnt;
}

//--------------------------------------------------
// Description  : Update OSD Lane Count
// Input Value  : enumTypeCPcbPort, enumDpLaneCount : _DP_LINK_1_LANE / _DP_LINK_2_LANE / _DP_LINK_4_LANE
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCSetSysDataLaneCount(EnumTypeCPcbPort enumTypeCPcbPort, EnumDpLaneCount enumDpLaneCount)
{
    enumDpLaneCount = enumDpLaneCount;
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            UserCommonNVRamSetSystemData(_DP_D0_LANES, enumDpLaneCount);

            break;
#endif

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            UserCommonNVRamSetSystemData(_DP_D1_LANES, enumDpLaneCount);

            break;
#endif

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            UserCommonNVRamSetSystemData(_DP_D2_LANES, enumDpLaneCount);

            break;
#endif

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            // UserCommonNVRamSetSystemData(_DP_P0_LANES, enumDpLaneCount);

            break;
#endif

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            // UserCommonNVRamSetSystemData(_DP_P1_LANES, enumDpLaneCount);

            break;
#endif

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            // UserCommonNVRamSetSystemData(_DP_P2_LANES, enumDpLaneCount);

            break;
#endif

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            // UserCommonNVRamSetSystemData(_DP_P3_LANES, enumDpLaneCount);

            break;
#endif

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            // UserCommonNVRamSetSystemData(_DP_P4_LANES, enumDpLaneCount);

            break;
#endif

        // Adaptor Port Does Not Support Alt Mode
        case _ADAPTOR_TYPE_C_PORT:
        default:
            break;
    }

    UserCommonNVRamSaveSystemData();
}

//--------------------------------------------------
// Description  : Return Type C Ext. Port Ctrl Ac On Status
// Input Value  : enumTypeCPcbPort
// Output Value : Ac On Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbTypeCGetExtPortCtrlAcOnFlag(EnumTypeCPcbPort enumTypeCPcbPort)
{
    bit bAcOnFlag = _FALSE;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D0_TYPE_C_PORT);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D1_TYPE_C_PORT);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_D2_TYPE_C_PORT);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P0_TYPE_C_PORT);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P1_TYPE_C_PORT);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P2_TYPE_C_PORT);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P3_TYPE_C_PORT);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            bAcOnFlag = GET_USB_TYPE_C_EXT_PORT_CTRL_AC_ON_FLAG(_P4_TYPE_C_PORT);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        default:

            break;
    }

    return bAcOnFlag;
}

//--------------------------------------------------
// Description  : Return TypeC DP Status Info
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCDpStatusInfo (enumPartnerDpConnectStatus / b1PartnerMultiFunctionBit...)
//--------------------------------------------------
StructTypeCDpStatusInfo SysUsbTypeCGetDpStatusInfo(EnumTypeCPcbPort enumTypeCPcbPort)
{
#if(_TYPE_C_DPAM_VERSION < _DPAM_VERSION_2_1)
    StructTypeCDpStatusInfo stDpStatusInfo = {_PD_DP_CONNECT_NONE, 0x00, 0x00, 0x00, 0x00, 0x00, _PD_HPD_NONE};
#else
    StructTypeCDpStatusInfo stDpStatusInfo = {_PD_DP_CONNECT_NONE, 0x00, 0x00, 0x00, 0x00, 0x00, _PD_HPD_NONE, 0x00};
#endif
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_D0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_D1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_D2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_P0_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_P1_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_P2_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_P3_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_P4_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDpStatusInfo = ScalerTypeCGetDpStatusInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_TCPM)
            stDpStatusInfo = ScalerTypeCTcpmGetDpStatusInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDpStatusInfo = UserCommonUsbTypeCRtsGetDpStatusInfo(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDpStatusInfo = UserCommonUsbTypeCUserGetDpStatusInfo(_ADAPTOR_TYPE_C_PORT);
#endif

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stDpStatusInfo;
}

#if(_DP_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Check if Specific ucInputPort is TypeC Port Controller or Not
// Input Value  : enumInputPort
// Output Value : _TRUE/_FALSE
//--------------------------------------------------
bit SysUsbTypeCRxCheckTypeCPortControllerExist(EnumInputPort enumInputPort)
{
    switch(enumInputPort)
    {
        case _D0_INPUT_PORT:
#if((_D0_INPUT_PORT_TYPE == _D0_DP_PORT) && (_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON))
            return _TRUE;
#else
            return _FALSE;
#endif
            break;

        case _D1_INPUT_PORT:
#if((_D1_INPUT_PORT_TYPE == _D1_DP_PORT) && (_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON))
            return _TRUE;
#else
            return _FALSE;
#endif
            break;

        case _D2_INPUT_PORT:

#if((_D2_INPUT_PORT_TYPE == _D2_DP_PORT) && (_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON))
            return _TRUE;
#else
            return _FALSE;
#endif
            break;

        default:
            return _FALSE;
            break;
    }
    return _FALSE;
}
#endif  // End of #if(_DP_SUPPORT == _ON)

#if(_TYPE_C_MODAL_OPERATION_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Do TypeC Alt Mode Handler Process According to Port Controller Info
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCAltModeHandler(EnumTypeCPcbPort enumTypeCPcbPort)
{
#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_VENDOR_ALT_MODE_NONE)
    enumTypeCPcbPort = enumTypeCPcbPort;
#endif

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_LENOVO_ALT_MODE)
    StructTypeCLenovoSysEvent stLenovoSysEvent = {_TYPE_C_LENOVO_SYS_DC_MODE, _TYPE_C_LENOVO_SYS_STATE_NONE, _FALSE, 0x00, 0x00};
    StructTypeCLenovoDockEvent stLenovoDockEvent = {_TYPE_C_LENOVO_DOCK_POWER_SWITCH_NONE, _FALSE, _FALSE, 0x00};

    if(UserCommonUsbTypeCCheckLenovoDeviceTypeValid(enumTypeCPcbPort, GET_USB_TYPE_C_LENOVO_DEVICE_TYPE(enumTypeCPcbPort)) == _TYPE_C_LENOVO_DEVICE_TYPE_VALID)
    {
        // Get Lenovo Alt Mode Status from Port Ctrl
        SET_USB_TYPE_C_LENOVO_ALT_MODE_STATUS(enumTypeCPcbPort, SysUsbTypeCGetPortControllerLenovoAltModeReady(enumTypeCPcbPort));

        if(GET_USB_TYPE_C_LENOVO_ALT_MODE_STATUS(enumTypeCPcbPort) == _TYPE_C_LENOVO_ALT_MODE_READY)
        {
            // Get LenovoSysEvent (Including System Acknowledge) from Port Ctrl
            stLenovoSysEvent = SysUsbTypeCGetPortControllerLenovoSystemEvent(enumTypeCPcbPort);

            if((stLenovoSysEvent.b1SystemEvent == _TRUE) || ((stLenovoSysEvent.ucSystemAcknowlegde & _BIT0) == _BIT0))
            {
                // Set LenovoSysEvent (Including System Acknowledge) to User
                UserCommonUsbTypeCLenovoAltModeHandler(enumTypeCPcbPort, stLenovoSysEvent);
            }

            // Check if Last Docking Event has been Sent
            if(SysUsbTypeCCheckPortControllerLenovoDockingEventBusy(enumTypeCPcbPort) == _TYPE_C_LENOVO_DOCK_EVENT_NOT_BUSY)
            {
                // Get LenovoDockEvent from User
                UserCommonUsbTypeCGetLenovoDockingEvent(enumTypeCPcbPort, &stLenovoDockEvent);

                // Set LenovoDockEvent to Port Ctrl
                SysUsbTypeCSetPortControllerLenovoDockingEvent(enumTypeCPcbPort, stLenovoDockEvent);
            }
        }
    }
    else
    {
        if((GET_USB_TYPE_C_LENOVO_DEVICE_TYPE(enumTypeCPcbPort) == _TYPE_C_LENOVO_DEVICE_TYPE_NONE) && (GET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(enumTypeCPcbPort) == _FALSE))
        {
            // Get Lenovo Alt Mode Status from Port Ctrl
            SET_USB_TYPE_C_LENOVO_ALT_MODE_STATUS(enumTypeCPcbPort, SysUsbTypeCGetPortControllerLenovoAltModeReady(enumTypeCPcbPort));

            if(GET_USB_TYPE_C_LENOVO_ALT_MODE_STATUS(enumTypeCPcbPort) == _TYPE_C_LENOVO_ALT_MODE_READY)
            {
                // If Port Controller Not Receive Device Type in 8 sec, Set Type C to Receive Lenovo Device Type Timeout
                SysUsbTypeCActiveLenovoRcvDeviceTypeTimerEvent(enumTypeCPcbPort, 8000);

                // Get Lenovo Device Type from Port Ctrl
                SET_USB_TYPE_C_LENOVO_DEVICE_TYPE(enumTypeCPcbPort, SysUsbTypeCGetPortControllerLenovoDeviceType(enumTypeCPcbPort));

                if(GET_USB_TYPE_C_LENOVO_DEVICE_TYPE(enumTypeCPcbPort) != _TYPE_C_LENOVO_DEVICE_TYPE_NONE)
                {
                    // Cancel Timer Event Which Set Type C to Receive Lenovo Device Type Timeout
                    SysUsbTypeCCancelLenovoRcvDeviceTypeTimerEvent(enumTypeCPcbPort);
                }
            }
        }
    }
#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_LENOVO_ALT_MODE)

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_ACER_ALT_MODE)
    StructTypeCAcerSysEvent stAcerSysEvent = {_TYPE_C_ACER_SYS_EVENT_NONE, {0x00}, 0x00};
    StructTypeCAcerUserEvent stAcerUserEvent = {_TYPE_C_ACER_USER_EVENT_NONE, {0x00}, 0x00};

    if(SysUsbTypeCGetPortControllerAcerAltModeReady(enumTypeCPcbPort) == _TYPE_C_ACER_ALT_MODE_READY)
    {
        // Get Acer System Event from Port Ctrl and Send to User
        stAcerSysEvent = SysUsbTypeCGetPortControllerAcerSystemEvent(enumTypeCPcbPort);

        if(stAcerSysEvent.enumEvent != _TYPE_C_ACER_SYS_EVENT_NONE)
        {
            UserCommonUsbTypeCAcerAltModeHandler(enumTypeCPcbPort, stAcerSysEvent);
        }

        // Check if Acer User Event is NOT Busy
        if(SysUsbTypeCCheckPortControllerAcerUserEventBusy(enumTypeCPcbPort) == _TYPE_C_ACER_USER_EVENT_NOT_BUSY)
        {
            // Get Acer User Event from User and Send to Port Ctrl
            UserCommonUsbTypeCGetAcerUserEvent(enumTypeCPcbPort, &stAcerUserEvent);
            SysUsbTypeCSetPortControllerAcerUserEvent(enumTypeCPcbPort, stAcerUserEvent);
        }
    }
#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_ACER_ALT_MODE)

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_HP_ALT_MODE)
    StructTypeCHpSysEvent stHpSysEvent = {_TYPE_C_HP_SYS_EVENT_NONE, {0x00}, 0x00};
    StructTypeCHpUserEvent stHpUserEvent = {_TYPE_C_HP_USER_EVENT_NONE, {0x00}, 0x00};

    if(SysUsbTypeCGetPortControllerHpAltModeReady(enumTypeCPcbPort) == _TYPE_C_HP_ALT_MODE_READY)
    {
        // Get Hp System Event from Port Ctrl and Send to User
        stHpSysEvent = SysUsbTypeCGetPortControllerHpSystemEvent(enumTypeCPcbPort);

        if(stHpSysEvent.enumEvent != _TYPE_C_HP_SYS_EVENT_NONE)
        {
            UserCommonUsbTypeCHpAltModeHandler(enumTypeCPcbPort, stHpSysEvent);
        }

        // Check if Hp User Event is NOT Busy
        if(SysUsbTypeCCheckPortControllerHpUserEventBusy(enumTypeCPcbPort) == _TYPE_C_HP_USER_EVENT_NOT_BUSY)
        {
            // Get Hp User Event from User and Send to Port Ctrl
            UserCommonUsbTypeCGetHpUserEvent(enumTypeCPcbPort, &stHpUserEvent);
            SysUsbTypeCSetPortControllerHpUserEvent(enumTypeCPcbPort, stHpUserEvent);
        }
    }
#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_HP_ALT_MODE)

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_DELL_ALT_MODE)
    StructTypeCDellSysEvent stDellSysEvent = {_TYPE_C_DELL_SYS_EVENT_NONE, {0x00}, 0x00};
    StructTypeCDellUserEvent stDellUserEvent = {_TYPE_C_DELL_USER_EVENT_NONE, {0x00}, 0x00};

    if(SysUsbTypeCGetPortControllerDellAltModeReady(enumTypeCPcbPort) == _TYPE_C_DELL_ALT_MODE_READY)
    {
        // Get Dell System Event from Port Ctrl and Send to User
        stDellSysEvent = SysUsbTypeCGetPortControllerDellSystemEvent(enumTypeCPcbPort);

        if(stDellSysEvent.enumEvent != _TYPE_C_DELL_SYS_EVENT_NONE)
        {
            UserCommonUsbTypeCDellAltModeHandler(enumTypeCPcbPort, stDellSysEvent);
        }

        // Check if Dell User Event is NOT Busy
        if(SysUsbTypeCCheckPortControllerDellUserEventBusy(enumTypeCPcbPort) == _TYPE_C_DELL_USER_EVENT_NOT_BUSY)
        {
            // Get Dell User Event from User and Send to Port Ctrl
            UserCommonUsbTypeCGetDellUserEvent(enumTypeCPcbPort, &stDellUserEvent);
            SysUsbTypeCSetPortControllerDellUserEvent(enumTypeCPcbPort, stDellUserEvent);
        }
    }

    // Get Dell Initial Complete Status from User and Send to Port Ctrl
    SysUsbTypeCSetPortControllerDellAltModeInitComplete(enumTypeCPcbPort, UserCommonUsbTypeCGetDellAltModeInitComplete(enumTypeCPcbPort));

#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_DELL_ALT_MODE)
}

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_LENOVO_ALT_MODE)
//--------------------------------------------------
// Description  : Get Port Controller Lenovo Alt Mode Ready Info
// Input Value  : enumTypeCPcbPort
// Output Value : Lenovo Alt Mode Ready Status (_TYPE_C_LENOVO_ALT_MODE_READY / _TYPE_C_LENOVO_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCLenovoAltModeStatus SysUsbTypeCGetPortControllerLenovoAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCLenovoAltModeStatus enumLenovoAltModeStatus = _TYPE_C_LENOVO_ALT_MODE_NOT_READY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoAltModeStatus = ScalerTypeCGetLenovoAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoAltModeStatus = UserCommonUsbTypeCRtsGetLenovoAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoAltModeStatus = UserCommonUsbTypeCUserGetLenovoAltModeReady(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumLenovoAltModeStatus = _TYPE_C_LENOVO_ALT_MODE_NOT_READY;

            break;
    }

    return enumLenovoAltModeStatus;
}

//--------------------------------------------------
// Description  : Get Port Partner Lenovo Device Type from Port Controller
// Input Value  : enumTypeCPcbPort
// Output Value : Lenovo Device Type
//--------------------------------------------------
EnumTypeCLenovoDeviceType SysUsbTypeCGetPortControllerLenovoDeviceType(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCLenovoDeviceType enumLenovoDeviceType = _TYPE_C_LENOVO_DEVICE_TYPE_NONE;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumLenovoDeviceType = ScalerTypeCGetLenovoDeviceType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumLenovoDeviceType = UserCommonUsbTypeCRtsGetLenovoDeviceType(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumLenovoDeviceType = UserCommonUsbTypeCUserGetLenovoDeviceType(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumLenovoDeviceType = _TYPE_C_LENOVO_DEVICE_TYPE_NONE;

            break;
    }

    return enumLenovoDeviceType;
}

//--------------------------------------------------
// Description  : Active Timer Event Which Set Type C to Receive Lenovo Device Type Timeout
// Input Value  : enumTypeCPcbPort, Timer Timeout Count
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCActiveLenovoRcvDeviceTypeTimerEvent(EnumTypeCPcbPort enumTypeCPcbPort, WORD usTimeoutCnt)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_D0_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_D1_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_D2_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_P0_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_P1_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_P2_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_P3_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_P4_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Adaptor Has No Alt Mode Function

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Cancel Timer Event Which Set Type C to Receive Lenovo Device Type Timeout
// Input Value  : enumTypeCPcbPort
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCCancelLenovoRcvDeviceTypeTimerEvent(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D0_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D1_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D2_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P0_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P1_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P2_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P3_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P4_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Adaptor Has No Alt Mode Function

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set Type C to Receive Lenovo Device Type Timeout
// Input Value  : enumTypeCPcbPort
// Output Value : NONE
//--------------------------------------------------
void SysUsbTypeCSetLenovoRcvDeviceTypeTimeout(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_D0_TYPE_C_PORT);

            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_D1_TYPE_C_PORT);

            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_D2_TYPE_C_PORT);

            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_P0_TYPE_C_PORT);

            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_P1_TYPE_C_PORT);

            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_P2_TYPE_C_PORT);

            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_P3_TYPE_C_PORT);

            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

            SET_USB_TYPE_C_LENOVO_RCV_DEVICE_TYPE_TIMEOUT(_P4_TYPE_C_PORT);

            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Adaptor Has No Alt Mode Function

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type C Lenovo Alt Mode Get System Event (Including System Acknowledge)
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCLenovoSysEvent
//--------------------------------------------------
StructTypeCLenovoSysEvent SysUsbTypeCGetPortControllerLenovoSystemEvent(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCLenovoSysEvent stLenovoSysEvent = {_TYPE_C_LENOVO_SYS_DC_MODE, _TYPE_C_LENOVO_SYS_STATE_NONE, _FALSE, 0x00, 0x00};

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stLenovoSysEvent = ScalerTypeCGetLenovoSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            stLenovoSysEvent = UserCommonUsbTypeCRtsGetLenovoSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            stLenovoSysEvent = UserCommonUsbTypeCUserGetLenovoSystemEvent(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stLenovoSysEvent;
}

//--------------------------------------------------
// Description  : Type C Lenovo Alt Mode Set Docking Event
// Input Value  : enumTypeCPcbPort, stLenovoDockEvent
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerLenovoDockingEvent(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCLenovoDockEvent stLenovoDockEvent)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_D0_TYPE_C_PORT, stLenovoDockEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_D0_TYPE_C_PORT, stLenovoDockEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_D0_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_D1_TYPE_C_PORT, stLenovoDockEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_D1_TYPE_C_PORT, stLenovoDockEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_D1_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_D2_TYPE_C_PORT, stLenovoDockEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_D2_TYPE_C_PORT, stLenovoDockEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_D2_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_P0_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_P0_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_P0_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_P1_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_P1_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_P1_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_P2_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_P2_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_P2_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_P3_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_P3_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_P3_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_P4_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_P4_TYPE_C_PORT, stLenovoDockEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_P4_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetLenovoDockingEvent(_ADAPTOR_TYPE_C_PORT, stLenovoDockEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            UserCommonUsbTypeCRtsSetLenovoDockingEvent(_ADAPTOR_TYPE_C_PORT, stLenovoDockEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            UserCommonUsbTypeCUserSetLenovoDockingEvent(_ADAPTOR_TYPE_C_PORT, stLenovoDockEvent);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type C Lenovo Alt Mode Check if Last Docking Event has been Sent
// Input Value  : enumTypeCPcbPort
// Output Value : Docking Event Check Busy Result (_TYPE_C_LENOVO_DOCK_EVENT_BUSY / _TYPE_C_LENOVO_DOCK_EVENT_NOT_BUSY)
//--------------------------------------------------
EnumTypeCLenovoCheckBusyResult SysUsbTypeCCheckPortControllerLenovoDockingEventBusy(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCLenovoCheckBusyResult enumCheckBusyResult = _TYPE_C_LENOVO_DOCK_EVENT_NOT_BUSY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckLenovoDockingEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            enumCheckBusyResult = UserCommonUsbTypeCRtsCheckLenovoDockingEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            enumCheckBusyResult = UserCommonUsbTypeCUserCheckLenovoDockingEventBusy(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumCheckBusyResult = _TYPE_C_LENOVO_DOCK_EVENT_NOT_BUSY;

            break;
    }

    return enumCheckBusyResult;
}

//--------------------------------------------------
// Description  : Return Lenovo Alt Mode Ready Status to User
// Input Value  : enumTypeCPcbPort
// Output Value : Lenovo Alt Mode Ready Status (_TYPE_C_LENOVO_ALT_MODE_READY / _TYPE_C_LENOVO_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCLenovoAltModeStatus SysUsbTypeCGetLenovoAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return GET_USB_TYPE_C_LENOVO_ALT_MODE_STATUS(enumTypeCPcbPort);
}

//--------------------------------------------------
// Description  : Return Port Partner Lenovo Device Type to User
// Input Value  : enumTypeCPcbPort
// Output Value : Lenovo Device Type
//--------------------------------------------------
EnumTypeCLenovoDeviceType SysUsbTypeCGetLenovoDeviceType(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return GET_USB_TYPE_C_LENOVO_DEVICE_TYPE(enumTypeCPcbPort);
}
#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_LENOVO_ALT_MODE)

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_ACER_ALT_MODE)
//--------------------------------------------------
// Description  : Get Port Controller Acer Alt Mode Ready Info
// Input Value  : enumTypeCPcbPort
// Output Value : Acer Alt Mode Ready Status (_TYPE_C_ACER_ALT_MODE_READY / _TYPE_C_ACER_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCAcerAltModeStatus SysUsbTypeCGetPortControllerAcerAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCAcerAltModeStatus enumAcerAltModeStatus = _TYPE_C_ACER_ALT_MODE_NOT_READY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumAcerAltModeStatus = ScalerTypeCGetAcerAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumAcerAltModeStatus = UserCommonUsbTypeCRtsGetAcerAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumAcerAltModeStatus = UserCommonUsbTypeCUserGetAcerAltModeReady(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumAcerAltModeStatus = _TYPE_C_ACER_ALT_MODE_NOT_READY;

            break;
    }

    return enumAcerAltModeStatus;
}

//--------------------------------------------------
// Description  : Type C Acer Alt Mode Get System Event
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCAcerSysEvent
//--------------------------------------------------
StructTypeCAcerSysEvent SysUsbTypeCGetPortControllerAcerSystemEvent(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCAcerSysEvent stAcerSysEvent = {_TYPE_C_ACER_SYS_EVENT_NONE, {0x00}, 0x00};

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stAcerSysEvent = ScalerTypeCGetAcerSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stAcerSysEvent = UserCommonUsbTypeCRtsGetAcerSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stAcerSysEvent = UserCommonUsbTypeCUserGetAcerSystemEvent(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stAcerSysEvent;
}

//--------------------------------------------------
// Description  : Type C Acer Alt Mode Set User Event
// Input Value  : enumTypeCPcbPort, stAcerUserEvent
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerAcerUserEvent(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCAcerUserEvent stAcerUserEvent)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_D0_TYPE_C_PORT, stAcerUserEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_D0_TYPE_C_PORT, stAcerUserEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_D0_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_D1_TYPE_C_PORT, stAcerUserEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_D1_TYPE_C_PORT, stAcerUserEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_D1_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_D2_TYPE_C_PORT, stAcerUserEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_D2_TYPE_C_PORT, stAcerUserEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_D2_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_P0_TYPE_C_PORT, stAcerUserEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_P0_TYPE_C_PORT, stAcerUserEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_P0_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_P1_TYPE_C_PORT, stAcerUserEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_P1_TYPE_C_PORT, stAcerUserEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_P1_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_P2_TYPE_C_PORT, stAcerUserEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_P2_TYPE_C_PORT, stAcerUserEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_P2_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_P3_TYPE_C_PORT, stAcerUserEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_P3_TYPE_C_PORT, stAcerUserEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_P3_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_P4_TYPE_C_PORT, stAcerUserEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_P4_TYPE_C_PORT, stAcerUserEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_P4_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetAcerUserEvent(_ADAPTOR_TYPE_C_PORT, stAcerUserEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetAcerUserEvent(_ADAPTOR_TYPE_C_PORT, stAcerUserEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetAcerUserEvent(_ADAPTOR_TYPE_C_PORT, stAcerUserEvent);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type C Acer Alt Mode Check if Last User Event has been Sent
// Input Value  : enumTypeCPcbPort
// Output Value : Acer User Event Busy Status (_TYPE_C_ACER_USER_EVENT_BUSY / _TYPE_C_ACER_USER_EVENT_NOT_BUSY)
//--------------------------------------------------
EnumTypeCAcerBusyStatus SysUsbTypeCCheckPortControllerAcerUserEventBusy(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCAcerBusyStatus enumCheckBusyResult = _TYPE_C_ACER_USER_EVENT_NOT_BUSY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckAcerUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckAcerUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckAcerUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumCheckBusyResult = _TYPE_C_ACER_USER_EVENT_NOT_BUSY;

            break;
    }

    return enumCheckBusyResult;
}

//--------------------------------------------------
// Description  : Return Acer Alt Mode Ready Status to User
// Input Value  : enumTypeCPcbPort
// Output Value : Acer Alt Mode Ready Status (_TYPE_C_ACER_ALT_MODE_READY / _TYPE_C_ACER_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCAcerAltModeStatus SysUsbTypeCGetAcerAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return SysUsbTypeCGetPortControllerAcerAltModeReady(enumTypeCPcbPort);
}

#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_ACER_ALT_MODE)

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_HP_ALT_MODE)
//--------------------------------------------------
// Description  : Get Port Controller Hp Alt Mode Ready Info
// Input Value  : enumTypeCPcbPort
// Output Value : Hp Alt Mode Ready Status (_TYPE_C_HP_ALT_MODE_READY / _TYPE_C_HP_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCHpAltModeStatus SysUsbTypeCGetPortControllerHpAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCHpAltModeStatus enumHpAltModeStatus = _TYPE_C_HP_ALT_MODE_NOT_READY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumHpAltModeStatus = ScalerTypeCGetHpAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumHpAltModeStatus = UserCommonUsbTypeCRtsGetHpAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumHpAltModeStatus = UserCommonUsbTypeCUserGetHpAltModeReady(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumHpAltModeStatus = _TYPE_C_HP_ALT_MODE_NOT_READY;

            break;
    }

    return enumHpAltModeStatus;
}

//--------------------------------------------------
// Description  : Type C Hp Alt Mode Get System Event
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCHpSysEvent
//--------------------------------------------------
StructTypeCHpSysEvent SysUsbTypeCGetPortControllerHpSystemEvent(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCHpSysEvent stHpSysEvent = {_TYPE_C_HP_SYS_EVENT_NONE, {0x00}, 0x00};

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stHpSysEvent = ScalerTypeCGetHpSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stHpSysEvent = UserCommonUsbTypeCRtsGetHpSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stHpSysEvent = UserCommonUsbTypeCUserGetHpSystemEvent(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stHpSysEvent;
}

//--------------------------------------------------
// Description  : Type C Hp Alt Mode Set User Event
// Input Value  : enumTypeCPcbPort, stHpUserEvent
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerHpUserEvent(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCHpUserEvent stHpUserEvent)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_D0_TYPE_C_PORT, stHpUserEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_D0_TYPE_C_PORT, stHpUserEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_D0_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_D1_TYPE_C_PORT, stHpUserEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_D1_TYPE_C_PORT, stHpUserEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_D1_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_D2_TYPE_C_PORT, stHpUserEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_D2_TYPE_C_PORT, stHpUserEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_D2_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_P0_TYPE_C_PORT, stHpUserEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_P0_TYPE_C_PORT, stHpUserEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_P0_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_P1_TYPE_C_PORT, stHpUserEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_P1_TYPE_C_PORT, stHpUserEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_P1_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_P2_TYPE_C_PORT, stHpUserEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_P2_TYPE_C_PORT, stHpUserEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_P2_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_P3_TYPE_C_PORT, stHpUserEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_P3_TYPE_C_PORT, stHpUserEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_P3_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_P4_TYPE_C_PORT, stHpUserEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_P4_TYPE_C_PORT, stHpUserEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_P4_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetHpUserEvent(_ADAPTOR_TYPE_C_PORT, stHpUserEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetHpUserEvent(_ADAPTOR_TYPE_C_PORT, stHpUserEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetHpUserEvent(_ADAPTOR_TYPE_C_PORT, stHpUserEvent);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type C Hp Alt Mode Check if Last User Event has been Sent
// Input Value  : enumTypeCPcbPort
// Output Value : Hp User Event Busy Status (_TYPE_C_HP_USER_EVENT_BUSY / _TYPE_C_HP_USER_EVENT_NOT_BUSY)
//--------------------------------------------------
EnumTypeCHpBusyStatus SysUsbTypeCCheckPortControllerHpUserEventBusy(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCHpBusyStatus enumCheckBusyResult = _TYPE_C_HP_USER_EVENT_NOT_BUSY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckHpUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckHpUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckHpUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumCheckBusyResult = _TYPE_C_HP_USER_EVENT_NOT_BUSY;

            break;
    }

    return enumCheckBusyResult;
}

//--------------------------------------------------
// Description  : Return Hp Alt Mode Ready Status to User
// Input Value  : enumTypeCPcbPort
// Output Value : Hp Alt Mode Ready Status (_TYPE_C_HP_ALT_MODE_READY / _TYPE_C_HP_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCHpAltModeStatus SysUsbTypeCGetHpAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return SysUsbTypeCGetPortControllerHpAltModeReady(enumTypeCPcbPort);
}

#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_HP_ALT_MODE)

#if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_DELL_ALT_MODE)
//--------------------------------------------------
// Description  : Get Port Controller Dell Alt Mode Ready Info
// Input Value  : enumTypeCPcbPort
// Output Value : Dell Alt Mode Ready Status (_TYPE_C_DELL_ALT_MODE_READY / _TYPE_C_DELL_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCDellAltModeStatus SysUsbTypeCGetPortControllerDellAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCDellAltModeStatus enumDellAltModeStatus = _TYPE_C_DELL_ALT_MODE_NOT_READY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumDellAltModeStatus = ScalerTypeCGetDellAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumDellAltModeStatus = UserCommonUsbTypeCRtsGetDellAltModeReady(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumDellAltModeStatus = UserCommonUsbTypeCUserGetDellAltModeReady(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumDellAltModeStatus = _TYPE_C_DELL_ALT_MODE_NOT_READY;

            break;
    }

    return enumDellAltModeStatus;
}

//--------------------------------------------------
// Description  : Type C Dell Alt Mode Get System Event
// Input Value  : enumTypeCPcbPort
// Output Value : StructTypeCDellSysEvent
//--------------------------------------------------
StructTypeCDellSysEvent SysUsbTypeCGetPortControllerDellSystemEvent(EnumTypeCPcbPort enumTypeCPcbPort)
{
    StructTypeCDellSysEvent stDellSysEvent = {_TYPE_C_DELL_SYS_EVENT_NONE, {0x00}, 0x00};

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            stDellSysEvent = ScalerTypeCGetDellSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // stDellSysEvent = UserCommonUsbTypeCRtsGetDellSystemEvent(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // stDellSysEvent = UserCommonUsbTypeCUserGetDellSystemEvent(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }

    return stDellSysEvent;
}

//--------------------------------------------------
// Description  : Type C Dell Alt Mode Set User Event
// Input Value  : enumTypeCPcbPort, stDellUserEvent
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerDellUserEvent(EnumTypeCPcbPort enumTypeCPcbPort, StructTypeCDellUserEvent stDellUserEvent)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_D0_TYPE_C_PORT, stDellUserEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_D0_TYPE_C_PORT, stDellUserEvent);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_D0_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_D1_TYPE_C_PORT, stDellUserEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_D1_TYPE_C_PORT, stDellUserEvent);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_D1_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_D2_TYPE_C_PORT, stDellUserEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_D2_TYPE_C_PORT, stDellUserEvent);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_D2_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_P0_TYPE_C_PORT, stDellUserEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_P0_TYPE_C_PORT, stDellUserEvent);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_P0_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_P1_TYPE_C_PORT, stDellUserEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_P1_TYPE_C_PORT, stDellUserEvent);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_P1_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_P2_TYPE_C_PORT, stDellUserEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_P2_TYPE_C_PORT, stDellUserEvent);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_P2_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_P3_TYPE_C_PORT, stDellUserEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_P3_TYPE_C_PORT, stDellUserEvent);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_P3_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_P4_TYPE_C_PORT, stDellUserEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_P4_TYPE_C_PORT, stDellUserEvent);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_P4_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellUserEvent(_ADAPTOR_TYPE_C_PORT, stDellUserEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellUserEvent(_ADAPTOR_TYPE_C_PORT, stDellUserEvent);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellUserEvent(_ADAPTOR_TYPE_C_PORT, stDellUserEvent);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type C Dell Alt Mode Set Initial Complete Status
// Input Value  : enumTypeCPcbPort, enumDellInitCompleteStatus
// Output Value : None
//--------------------------------------------------
void SysUsbTypeCSetPortControllerDellAltModeInitComplete(EnumTypeCPcbPort enumTypeCPcbPort, EnumTypeCDellInitCompleteStatus enumDellInitCompleteStatus)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_D0_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_D0_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_D0_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_D1_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_D1_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_D1_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_D2_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_D2_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_D2_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_P0_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_P0_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_P0_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_P1_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_P1_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_P1_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_P2_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_P2_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_P2_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_P3_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_P3_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_P3_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_P4_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_P4_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_P4_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            ScalerTypeCSetDellAltModeInitComplete(_ADAPTOR_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // UserCommonUsbTypeCRtsSetDellAltModeInitComplete(_ADAPTOR_TYPE_C_PORT, enumDellInitCompleteStatus);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // UserCommonUsbTypeCUserSetDellAltModeInitComplete(_ADAPTOR_TYPE_C_PORT, enumDellInitCompleteStatus);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type C Dell Alt Mode Check if Last User Event has been Sent
// Input Value  : enumTypeCPcbPort
// Output Value : Dell User Event Busy Status (_TYPE_C_DELL_USER_EVENT_BUSY / _TYPE_C_DELL_USER_EVENT_NOT_BUSY)
//--------------------------------------------------
EnumTypeCDellBusyStatus SysUsbTypeCCheckPortControllerDellUserEventBusy(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCDellBusyStatus enumCheckBusyResult = _TYPE_C_DELL_USER_EVENT_NOT_BUSY;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumCheckBusyResult = ScalerTypeCCheckDellUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumCheckBusyResult = UserCommonUsbTypeCRtsCheckDellUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumCheckBusyResult = UserCommonUsbTypeCUserCheckDellUserEventBusy(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumCheckBusyResult = _TYPE_C_DELL_USER_EVENT_NOT_BUSY;

            break;
    }

    return enumCheckBusyResult;
}

//--------------------------------------------------
// Description  : Get Port Controller Enter Dell Alt Mode Time Out Info
// Input Value  : enumTypeCPcbPort
// Output Value : Enter Dell Alt Mode Time Out Result (_TYPE_C_ENTER_DELL_ALT_MODE_TIMEOUT/ _TYPE_C_ENTER_DELL_ALT_MODE_WITHOUT_TIMEOUT)
//--------------------------------------------------
EnumTypeCEnterDellAltModeTimeOut SysUsbTypeCGetPortControllerEnterDellAltModeTimeOut(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCEnterDellAltModeTimeOut enumEnterDellAMTimeOutResult = _TYPE_C_ENTER_DELL_ALT_MODE_WITHOUT_TIMEOUT;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_D0_TYPE_C_PORT);
#elif(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_D0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_D1_TYPE_C_PORT);
#elif(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_D1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_D2_TYPE_C_PORT);
#elif(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_D2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_P0_TYPE_C_PORT);
#elif(_P0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_P0_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_P1_TYPE_C_PORT);
#elif(_P1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_P1_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_P2_TYPE_C_PORT);
#elif(_P2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_P2_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_P3_TYPE_C_PORT);
#elif(_P3_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_P3_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_P4_TYPE_C_PORT);
#elif(_P4_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_P4_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

#if(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
            enumEnterDellAMTimeOutResult = ScalerTypeCGetEnterDellAltModeTimeOut(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_RTS)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCRtsGetEnterDellAltModeTimeOut(_ADAPTOR_TYPE_C_PORT);
#elif(_ADAPTOR_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_USER)
            // enumEnterDellAMTimeOutResult = UserCommonUsbTypeCUserGetEnterDellAltModeTimeOut(_ADAPTOR_TYPE_C_PORT);
#endif
            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            enumEnterDellAMTimeOutResult = _TYPE_C_ENTER_DELL_ALT_MODE_WITHOUT_TIMEOUT;

            break;
    }

    return enumEnterDellAMTimeOutResult;
}

//--------------------------------------------------
// Description  : Return Dell Alt Mode Ready Status to User
// Input Value  : enumTypeCPcbPort
// Output Value : Dell Alt Mode Ready Status (_TYPE_C_DELL_ALT_MODE_READY / _TYPE_C_DELL_ALT_MODE_NOT_READY)
//--------------------------------------------------
EnumTypeCDellAltModeStatus SysUsbTypeCGetDellAltModeReady(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return SysUsbTypeCGetPortControllerDellAltModeReady(enumTypeCPcbPort);
}

//--------------------------------------------------
// Description  : Return Enter Dell Alt Mode Time Out Info to User
// Input Value  : enumTypeCPcbPort
// Output Value : Enter Dell Alt Mode Time Out Result (_TYPE_C_ENTER_DELL_ALT_MODE_TIMEOUT/ _TYPE_C_ENTER_DELL_ALT_MODE_WITHOUT_TIMEOUT)
//--------------------------------------------------
EnumTypeCEnterDellAltModeTimeOut SysUsbTypeCGetEnterDellAltModeTimeOut(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return SysUsbTypeCGetPortControllerEnterDellAltModeTimeOut(enumTypeCPcbPort);
}

#endif  // End of #if(_TYPE_C_VENDOR_ALT_MODE == _TYPE_C_DELL_ALT_MODE)
#endif  // End of #if(_TYPE_C_MODAL_OPERATION_SUPPORT == _ON)

#if(_BILLBOARD_SUPPORT == _ON)
//--------------------------------------------------
// Description  : UsbBillboard Initial
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbBillboardInitial(void)
{
    CLR_USB_BB_ENABLE_STATUS();

#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))
    ScalerUsbBillboardClrBBProgramEnable();
#endif

#if(_D0_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_D0_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_D0_TYPE_C_PORT);
    SysUsbBillboardControl(_D0_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_D0_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_D0_TYPE_C_PORT, _FALSE);
#endif
#endif

#if(_D1_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_D1_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_D1_TYPE_C_PORT);
    SysUsbBillboardControl(_D1_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_D1_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_D1_TYPE_C_PORT, _FALSE);
#endif
#endif

#if(_D2_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_D2_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_D2_TYPE_C_PORT);
    SysUsbBillboardControl(_D2_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_D2_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_D2_TYPE_C_PORT, _FALSE);
#endif
#endif

#if(_P0_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_P0_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_P0_TYPE_C_PORT);
    SysUsbBillboardControl(_P0_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_P0_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_P0_TYPE_C_PORT, _FALSE);
#endif
#endif

#if(_P1_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_P1_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_P1_TYPE_C_PORT);
    SysUsbBillboardControl(_P1_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_P1_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_P1_TYPE_C_PORT, _FALSE);
#endif
#endif

#if(_P2_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_P2_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_P2_TYPE_C_PORT);
    SysUsbBillboardControl(_P2_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_P2_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_P2_TYPE_C_PORT, _FALSE);
#endif
#endif

#if(_P3_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_P3_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_P3_TYPE_C_PORT);
    SysUsbBillboardControl(_P3_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_P3_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_P3_TYPE_C_PORT, _FALSE);
#endif
#endif

#if(_P4_TYPE_C_BILLBOARD_SUPPORT == _ON)
    // Initialize D0 Port BillBoard related marco
    SET_USB_BB_STATE(_P4_TYPE_C_PORT, _BB_INITIAL_STATE);
    CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(_P4_TYPE_C_PORT);
    SysUsbBillboardControl(_P4_TYPE_C_PORT, _USB_BB_DISABLE);
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_P4_BILLBOARD_SCALER_SUPPORT == _ON))
    SET_USB_BB_USER_PROGRAM_ENABLE(_P4_TYPE_C_PORT, _FALSE);
#endif
#endif
}

//--------------------------------------------------
// Description  : UsbBillboard Handler
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbBillboardHandler(EnumTypeCPcbPort enumTypeCPcbPort)
{
#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))
    EnumBillboardProgramCtrl enumUserUsbTypeCBBProgramEnable = UserCommonUsbTypeCBBProgramEnable(enumTypeCPcbPort);
    bit bUserUsbTypeCBBProgramEnableChange = _FALSE;

    // Check whether User_BB_Program_Enable  change or not
    if(GET_USB_BB_USER_PROGRAM_ENABLE(enumTypeCPcbPort) != enumUserUsbTypeCBBProgramEnable)
    {
        bUserUsbTypeCBBProgramEnableChange = _TRUE;
        DebugMessageTypeC("10.[USB BB][BB_Program_User] BBProgramEnableChange!!!", enumTypeCPcbPort);
    }

    // Update User_BB_Program_Enable
    SET_USB_BB_USER_PROGRAM_ENABLE(enumTypeCPcbPort, enumUserUsbTypeCBBProgramEnable);
#endif

    switch(GET_USB_BB_STATE(enumTypeCPcbPort))
    {
        case _BB_INITIAL_STATE:

#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))
            if((enumUserUsbTypeCBBProgramEnable == _USB_BB_PROGRAM_ENABLE) && (SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _TRUE))
            {
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    // bypass Enable 1sec timer when BB_Program
                    SET_USB_BB_STATE(enumTypeCPcbPort, _BB_UNATTACH_STATE);

                    DebugMessageTypeC("10.[USB BB][BB_Program_User] Initial --> Unattach by BB_Program Processing", enumTypeCPcbPort);
                }

                return;
            }

#endif // End of #if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))

            if((GET_USB_TYPE_C_STATE(enumTypeCPcbPort) == _USB_TYPE_C_ATTACHED_STATE) && (SysUsbTypeCGetDataRole(enumTypeCPcbPort) == _TYPE_C_UFP_U))
            {
                SysUsbBillboardStartTimer(enumTypeCPcbPort);
                SET_USB_BB_STATE(enumTypeCPcbPort, _BB_UNATTACH_STATE);

                DebugMessageTypeC("10.[USB BB] Initial --> Unattach by TypeC Attach", enumTypeCPcbPort);
            }
            else
            {
                // need to confirm hub switch to which port to determine disable BB or not
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    if((GET_USB_BB_ENABLE_STATUS()) == _TRUE)
                    {
                        SysUsbBillboardControl(enumTypeCPcbPort, _USB_BB_DISABLE);
                        CLR_USB_BB_ENABLE_STATUS();
                    }
                }
            }

            break;

        case _BB_UNATTACH_STATE:

#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))
            if((enumUserUsbTypeCBBProgramEnable == _USB_BB_PROGRAM_ENABLE) && (SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _TRUE))
            {
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    // if BB  status is disabled before, then enable BB
                    if(GET_USB_BB_ENABLE_STATUS() == _FALSE)
                    {
                        SysUsbBillboardControl(enumTypeCPcbPort, _USB_BB_ENABLE);
                        SET_USB_BB_ENABLE_STATUS();

                        DebugMessageTypeC("10.[USB BB][BB_Program_User] Turn On BB by BB_Program Processing", enumTypeCPcbPort);
                    }

                    // for BB program use, do not show notification by set DP_AltModeStauts to 2'b11(Success)
                    ScalerUsbBillboardSetBBProgramEnable();

                    // for BB program use, clear ISP related flag before BB Attach state
                    ScalerUsbBillboardIspFlagInitial();

                    SET_USB_BB_STATE(enumTypeCPcbPort, _BB_ATTACHED_STATE);
                    DebugMessageTypeC("10.[USB BB][BB_Program_User] Unattach --> Attach by BB_Program Processing", enumTypeCPcbPort);
                }

                return;
            }
            else if((bUserUsbTypeCBBProgramEnableChange == _TRUE) && (enumUserUsbTypeCBBProgramEnable == _USB_BB_PROGRAM_DISABLE))
            {
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    // if BB  status is enable before, then disable BB
                    if(GET_USB_BB_ENABLE_STATUS() == _TRUE)
                    {
                        SysUsbBillboardControl(enumTypeCPcbPort, _USB_BB_DISABLE);
                        CLR_USB_BB_ENABLE_STATUS();
                        DebugMessageTypeC("10.[USB BB] Turn Off BB", enumTypeCPcbPort);
                    }

                    ScalerUsbBillboardClrBBProgramEnable();
                }

                SET_USB_BB_STATE(enumTypeCPcbPort, _BB_INITIAL_STATE);

                return;
            }
#endif // End of #if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))

            if((GET_USB_TYPE_C_STATE(enumTypeCPcbPort) == _USB_TYPE_C_ATTACHED_STATE) && (SysUsbTypeCGetDataRole(enumTypeCPcbPort) == _TYPE_C_UFP_U))
            {
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    // BB 1S timer expiration
                    if(GET_USB_DP_ALT_MODE_NOT_READY_CONFIRM(enumTypeCPcbPort) == _TRUE)
                    {
                        // if BB  status is disabled before, then enable BB
                        if(GET_USB_BB_ENABLE_STATUS() == _FALSE)
                        {
                            SysUsbBillboardControl(enumTypeCPcbPort, _USB_BB_ENABLE);
                            SET_USB_BB_ENABLE_STATUS();

                            DebugMessageTypeC("10.[USB BB] Turn On BB", enumTypeCPcbPort);
                        }

                        SET_USB_BB_STATE(enumTypeCPcbPort, _BB_ATTACHED_STATE);

                        DebugMessageTypeC("10.[USB BB] Unattach --> Attach by TypeC Alt mode Fail", enumTypeCPcbPort);
                    }
                }
            }
            else
            {
                SysUsbBillboardCancelTimer(enumTypeCPcbPort);
                CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(enumTypeCPcbPort);

                // need to confirm hub switch to which port to determine disable BB or not
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    // if BB  status is enable before, then disable BB
                    if(GET_USB_BB_ENABLE_STATUS() == _TRUE)
                    {
                        SysUsbBillboardControl(enumTypeCPcbPort, _USB_BB_DISABLE);
                        CLR_USB_BB_ENABLE_STATUS();

                        DebugMessageTypeC("10.[USB BB] Turn Off BB", enumTypeCPcbPort);
                    }
                }
                SET_USB_BB_STATE(enumTypeCPcbPort, _BB_INITIAL_STATE);

                DebugMessageTypeC("10.[USB BB] Unattach --> Initial by TypeC Alt mode success", enumTypeCPcbPort);
            }

            break;

        case _BB_ATTACHED_STATE:

#if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))
            if((enumUserUsbTypeCBBProgramEnable == _USB_BB_PROGRAM_ENABLE) && (SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _TRUE))
            {
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    // if BB is already enable,then execute scalerBBHandler
                    if(GET_USB_BB_ENABLE_STATUS() == _TRUE)
                    {
                        SET_USB_HUB_MUX_SEL_STATUS(enumTypeCPcbPort);
                        SysUsbBillboardProcess(enumTypeCPcbPort);
                    }
                }

                return;
            }
            else if((bUserUsbTypeCBBProgramEnableChange == _TRUE) && (enumUserUsbTypeCBBProgramEnable == _USB_BB_PROGRAM_DISABLE))
            {
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    // if BB  status is enable before, then disable BB
                    if(GET_USB_BB_ENABLE_STATUS() == _TRUE)
                    {
                        SysUsbBillboardControl(enumTypeCPcbPort, _USB_BB_DISABLE);
                        CLR_USB_BB_ENABLE_STATUS();
                        DebugMessageTypeC("10.[USB BB] Turn Off BB", enumTypeCPcbPort);
                    }

                    ScalerUsbBillboardClrBBProgramEnable();
                }

                SET_USB_BB_STATE(enumTypeCPcbPort, _BB_INITIAL_STATE);

                return;
            }
#endif // End of #if((_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON) && (_BILLBOARD_SCALER_SUPPORT == _ON))

            if((GET_USB_TYPE_C_STATE(enumTypeCPcbPort) == _USB_TYPE_C_ATTACHED_STATE) && (SysUsbTypeCGetDataRole(enumTypeCPcbPort) == _TYPE_C_UFP_U))
            {
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
                {
                    // if BB is already enable,then execute scalerBBHandler
                    if(GET_USB_BB_ENABLE_STATUS() == _TRUE)
                    {
#if(_BILLBOARD_SCALER_SUPPORT == _ON)
                        SET_USB_HUB_MUX_SEL_STATUS(enumTypeCPcbPort);
#endif
                        SysUsbBillboardProcess(enumTypeCPcbPort);
                    }
                }
                else
                {
                    SET_USB_BB_STATE(enumTypeCPcbPort, _BB_UNATTACH_STATE);
                }
#else
                // if BB is already enable,then execute scalerBBHandler
                if(GET_USB_BB_ENABLE_STATUS() == _TRUE)
                {
#if(_BILLBOARD_SCALER_SUPPORT == _ON)
                    SET_USB_HUB_MUX_SEL_STATUS(enumTypeCPcbPort);
#endif
                    SysUsbBillboardProcess(enumTypeCPcbPort);
                }
#endif
            }
            else
            {
                CLR_USB_DP_ALT_MODE_NOT_READY_CONFIRM(enumTypeCPcbPort);

                // need to confirm hub switch to which port to determine disable BB or not
#if(_USB_HUB_SUPPORT == _ON)
                if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
#endif
                {
                    SysUsbBillboardControl(enumTypeCPcbPort, _USB_BB_DISABLE);
                    CLR_USB_BB_ENABLE_STATUS();

                    DebugMessageTypeC("10.[USB BB] Turn Off BB", enumTypeCPcbPort);
                }

                SET_USB_BB_STATE(enumTypeCPcbPort, _BB_INITIAL_STATE);

                DebugMessageTypeC("10.[USB BB] Attach --> Initial by TypeC Unattach", enumTypeCPcbPort);
            }

            break;

        default:

            break;
    }
}
//--------------------------------------------------
// Description  : Type-C Start Billboard ON Timer
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbBillboardStartTimer(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_D0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _D0_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_D0_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_D1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _D1_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_D1_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_D2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _D2_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_D2_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P0_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_P0_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P1_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_P1_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P2_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_P2_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P3_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P3_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P3_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_P3_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P4_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P4_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P4_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_BILLBOARD_TIME, _SYSTEM_TIMER_EVENT_P4_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Adaptor Has No Billboard Function

            break;

#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type-C Cancel Billboard ON Timer
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbBillboardCancelTimer(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_D0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _D0_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D0_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_D1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _D1_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D1_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_D2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_D2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _D2_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D2_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P0_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P0_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P0_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P1_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P1_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P1_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P2_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P2_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P2_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P3_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P3_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P3_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P3_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if((_P4_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_SCALER) || (_P4_TYPE_C_BILLBOARD_TYPE == _BILLBOARD_HUB))
        case _P4_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_P4_ENABLE_BILLBOARD);

            break;
#endif
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Adaptor Has No Billboard Function

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type-C Billboard Control
// Input Value  : enumTypeCPcbPort, _USB_BB_DISABLE / _USB_BB_ENABLE
// Output Value : None
//--------------------------------------------------
void SysUsbBillboardControl(EnumTypeCPcbPort enumTypeCPcbPort, EnumBillboardCtrl enumAtion)
{
    enumAtion = enumAtion;

    switch(enumTypeCPcbPort)
    {
#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:
#if(_D0_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_D0_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_D0_TYPE_C_PORT, enumAtion);
#elif(_D0_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_D0_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

#if(_D1_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_D1_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_D1_TYPE_C_PORT, enumAtion);
#elif(_D1_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_D1_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

#if(_D2_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_D2_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_D2_TYPE_C_PORT, enumAtion);
#elif(_D2_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_D2_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P0_TYPE_C_PORT:

#if(_P0_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_P0_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_P0_TYPE_C_PORT, enumAtion);
#elif(_P0_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_P0_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_P0_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P1_TYPE_C_PORT:

#if(_P1_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_P1_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_P1_TYPE_C_PORT, enumAtion);
#elif(_P1_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_P1_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_P1_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P2_TYPE_C_PORT:

#if(_P2_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_P2_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_P2_TYPE_C_PORT, enumAtion);
#elif(_P2_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_P2_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_P2_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P3_TYPE_C_PORT:

#if(_P3_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_P3_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_P3_TYPE_C_PORT, enumAtion);
#elif(_P3_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_P3_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_P3_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _P4_TYPE_C_PORT:

#if(_P4_BILLBOARD_SCALER_SUPPORT == _ON)
            // Turn On Scaler Billboard
            ScalerUsbBillboardPllPower(enumAtion);
#elif(_P4_BILLBOARD_RTS_HUB_SUPPORT == _ON)
            // Turn On Hub Billboard
            UserCommonUsbHubRtsBillboardControl(_P4_TYPE_C_PORT, enumAtion);
#elif(_P4_BILLBOARD_USER_HUB_SUPPORT == _ON)
            UserCommonUsbHubUserBillboardControl(_P4_TYPE_C_PORT, enumAtion);
#endif
            break;
#endif  // End of #if(_P4_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        case _ADAPTOR_TYPE_C_PORT:

            // Adaptor Has No Billboard Function

            break;
#endif  // End of #if(_ADAPTOR_TYPE_C_PORT_CTRL_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Type-C Billboard Process
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbBillboardProcess(EnumTypeCPcbPort enumTypeCPcbPort)
{
    enumTypeCPcbPort = enumTypeCPcbPort;

#if(_BILLBOARD_SCALER_SUPPORT == _ON)
    // excute Scaler BillboardHandler
#if(_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON)
    do
    {
        ScalerUsbBillboardHandler();

        if(SysUsbTypeCGetPortControllerCcAttach(enumTypeCPcbPort) != _TYPE_C_ATTACH)
        {
            g_bUsbBillboardIspEn = _FALSE;
        }

        ScalerUsbBillboardProgramCheckDone();

        // Update Kernel BB Custom Command While BB_Program
        SysUsbBillboardCustomCommand(&g_stUsbBillboardCustomCommandInfo);
    }
    while(g_bUsbBillboardIspEn == _TRUE);
#else
    ScalerUsbBillboardHandler();
#endif
#elif(_BILLBOARD_RTS_HUB_SUPPORT == _ON)
    // excute RTS Hub BillboardHandler
    UserCommonUsbHubRtsBillboardHandler(enumTypeCPcbPort);
#elif(_BILLBOARD_USER_HUB_SUPPORT == _ON)
    // excute User Hub BillboardHandler
    UserCommonUsbHubUserBillboardHandler(enumTypeCPcbPort);
#endif
}

#if(_USB_TYPE_C_BB_PROGRAM_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Type-C Billboard Get Kernel BB Custom Command While BB_Program
// Input Value  : pststUsbBillboardCustomCommandInfo
// Output Value : NONE
//--------------------------------------------------
void SysUsbBillboardCustomCommand(StructUsbBillboardCustomCommandInfo *pststUsbBillboardCustomCommandInfo)
{
    UserCommonUsbTypeCBBCustomCommand(pststUsbBillboardCustomCommandInfo);
}

//--------------------------------------------------
// Description  : User Get BB Custon Event Change
// Input Value  : NONE
// Output Value : EnumBillboardCustomEvent
//--------------------------------------------------
EnumBillboardCustomEvent SysUsbBillboardGetCustomEvent(void)
{
    return GET_USB_BB_CUSTOM_EVENT_CHANGE();
}

//--------------------------------------------------
// Description  : UserC Clear BB Custon Event Change
// Input Value  : NONE
// Output Value : EnumBillboardCustomEvent
//--------------------------------------------------
void SysUsbBillboardClrCustomEvent(EnumBillboardCustomEvent enumBillboardCustomEvent)
{
    CLR_USB_BB_CUSTOM_EVENT_CHANGE(enumBillboardCustomEvent);
}
#endif
//--------------------------------------------------
// Description  : Type-C Billboard Set TimerEventFlag
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbBillBoardSetTimerEventFlag(EnumTypeCPcbPort enumTypeCPcbPort)
{
    SET_USB_DP_ALT_MODE_NOT_READY_CONFIRM(enumTypeCPcbPort);
}
#endif // End of #if(_BILLBOARD_SUPPORT == _ON)
#endif // End of #if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)

#if(_USB_HUB_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Translate PCB Port into Hub Port Index For Macro Usage
// Input Value  : enumTypeCPcbPort
// Output Value : Hub Port Index
//--------------------------------------------------
BYTE SysUsbHubGetIndex(EnumTypeCPcbPort enumTypeCPcbPort)
{
    BYTE ucIndex = 0x00;

#if(_D0_USB_HUB_SUPPORT == _ON)

    if(enumTypeCPcbPort == _D0_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)

    if(enumTypeCPcbPort == _D1_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)

    if(enumTypeCPcbPort == _D2_TYPE_C_PORT)
    {
        return ucIndex;
    }
    else
    {
        ucIndex = ucIndex + 1;
    }
#endif

    // enumInputPort Invalid : Show Warning Message
    DebugMessageTypeC("9. [USB] ==========X Invalid TypeC PCB Port For Hub Index", enumTypeCPcbPort);

    return ucIndex;
}

//--------------------------------------------------
// Description  : Usb Hub Handler Initial
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbHubInitial(void)
{
#if(_USB3_REPEATER_SUPPORT == _ON)
#if((_USB3_RETIMER_MAC_SUPPORT == _ON) || (_USB3_REDRIVER_MAC_SUPPORT == _ON))
    // Enable Repeater INT
    SET_REPEATER_GLOBAL_IRQ_ENABLE(_ENABLE);
#endif
#endif

    // Initial Set to NONE for triggering OSD Switch Event at First Round
    SET_USB_HUB_OSD_SWITCH_PORT_RESULT(_HUB_NONE_PORT);

#if(_D0_USB_HUB_SUPPORT == _ON)
    // D0 Port
    // Initial Turn Off Hub BPWR
    UserCommonUsbHubPowerControl(_D0_TYPE_C_PORT, _DISABLE);
    SET_USB_HUB_STATE(_D0_TYPE_C_PORT, _USB_HUB_OFF);
    CLR_USB_HUB_INITIALIZED(_D0_TYPE_C_PORT);
    CLR_USB_HUB_OSD_CAPABILITY_CHG(_D0_TYPE_C_PORT);
    UserCommonUsbHubSwitchControl(_D0_TYPE_C_PORT, _USB_PATH_DISABLE);
    CLR_USB_HUB_FORCE_USB3_ENABLE(_D0_TYPE_C_PORT);

#if(_USB3_REPEATER_SUPPORT == _ON)
    ScalerUsb3RepeaterMacCleanPdNoResponse(_D0_TYPE_C_PORT);
#endif

#if(_D0_USB_HUB_COMMUNICATION_SUPPORT == _ON)
    SysUsbHubCommunicationControl(_D0_TYPE_C_PORT, _DISABLE);
#endif
#endif // End of #if(_D0_USB_HUB_SUPPORT == _ON)

#if(_D1_USB_HUB_SUPPORT == _ON)
    // D1 Port
    // Initial Turn Off Hub BPWR
    UserCommonUsbHubPowerControl(_D1_TYPE_C_PORT, _DISABLE);
    SET_USB_HUB_STATE(_D1_TYPE_C_PORT, _USB_HUB_OFF);
    CLR_USB_HUB_INITIALIZED(_D1_TYPE_C_PORT);
    CLR_USB_HUB_OSD_CAPABILITY_CHG(_D1_TYPE_C_PORT);
    UserCommonUsbHubSwitchControl(_D1_TYPE_C_PORT, _USB_PATH_DISABLE);
    CLR_USB_HUB_FORCE_USB3_ENABLE(_D1_TYPE_C_PORT);

#if(_USB3_REPEATER_SUPPORT == _ON)
    ScalerUsb3RepeaterMacCleanPdNoResponse(_D1_TYPE_C_PORT);
#endif

#if(_D1_USB_HUB_COMMUNICATION_SUPPORT == _ON)
    SysUsbHubCommunicationControl(_D1_TYPE_C_PORT, _DISABLE);
#endif
#endif // End of #if(_D1_USB_HUB_SUPPORT == _ON)

#if(_D2_USB_HUB_SUPPORT == _ON)
    // D2 Port
    // Initial Turn Off Hub BPWR
    UserCommonUsbHubPowerControl(_D2_TYPE_C_PORT, _DISABLE);
    SET_USB_HUB_STATE(_D2_TYPE_C_PORT, _USB_HUB_OFF);
    CLR_USB_HUB_INITIALIZED(_D2_TYPE_C_PORT);
    CLR_USB_HUB_OSD_CAPABILITY_CHG(_D2_TYPE_C_PORT);
    UserCommonUsbHubSwitchControl(_D2_TYPE_C_PORT, _USB_PATH_DISABLE);
    CLR_USB_HUB_FORCE_USB3_ENABLE(_D2_TYPE_C_PORT);

#if(_USB3_REPEATER_SUPPORT == _ON)
    ScalerUsb3RepeaterMacCleanPdNoResponse(_D2_TYPE_C_PORT);
#endif

#if(_D2_USB_HUB_COMMUNICATION_SUPPORT == _ON)
    SysUsbHubCommunicationControl(_D2_TYPE_C_PORT, _DISABLE);
#endif
#endif // End of #if(_D2_USB_HUB_SUPPORT == _ON)
}

//--------------------------------------------------
// Description  : Usb Hub Start Force U3 Enable Timer
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubStartForceEnableTimer(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_USB_HUB_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_USB3_TIME, _SYSTEM_TIMER_EVENT_D0_USB_FROCE_ENABLE);

            break;
#endif  // End of #if(_D0_USB_HUB_SUPPORT == _ON)

#if(_D1_USB_HUB_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_USB3_TIME, _SYSTEM_TIMER_EVENT_D1_USB_FROCE_ENABLE);

            break;
#endif  // End of #if(_D1_USB_HUB_SUPPORT == _ON)

#if(_D2_USB_HUB_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            ScalerTimerActiveTimerEvent(_USB_TYPE_C_ENABLE_USB3_TIME, _SYSTEM_TIMER_EVENT_D2_USB_FROCE_ENABLE);

            break;
#endif  // End of #if(_D2_USB_HUB_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Usb Hub Cancel Force U3 Enable Timer
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubCancelForceEnableTimer(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_USB_HUB_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D0_USB_FROCE_ENABLE);

            break;
#endif  // End of #if(_D0_USB_HUB_SUPPORT == _ON)

#if(_D1_USB_HUB_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D1_USB_FROCE_ENABLE);

            break;
#endif  // End of #if(_D1_USB_HUB_SUPPORT == _ON)

#if(_D2_USB_HUB_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D2_USB_FROCE_ENABLE);

            break;
#endif  // End of #if(_D2_USB_HUB_SUPPORT == _ON)

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Usb Hub Set Force U3 Enable TimerEventFlag
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubSetForceEnableTimerEventFlag(EnumTypeCPcbPort enumTypeCPcbPort)
{
    SET_USB_HUB_FORCE_USB3_ENABLE(enumTypeCPcbPort);
}

//--------------------------------------------------
// Description  : Usb Related Start Condition
// Input Value  : enumTypeCPcbPort
// Output Value : bit
//--------------------------------------------------
bit SysUsbHubPathStartCondition(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Condition-1: Hub Toggle Power Duration Timeout
    // Condition-2: User Defined USB Path Enable Condition = _TRUE
    // Condition-3: Alt Mode Ready OR PD_No_Response Flag OR Force_U3_Enable_Timer_Timeout
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    if((GET_USB_HUB_DISABLE_DURATION_TIMEOUT_FLAG() == _TRUE) &&
       (UserCommonUsbHubPathEnableCond(enumTypeCPcbPort) == _TRUE) &&
       ((SysUsbTypeCGetAltModeReady(enumTypeCPcbPort) == _TRUE) ||
#if((_PORT_CTRL_EMBEDDED_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
        (ScalerUsb3RepeaterMacGetPdNoResponse(enumTypeCPcbPort) == _TRUE) ||
#endif
        (GET_USB_HUB_FORCE_USB3_ENABLE(enumTypeCPcbPort) == _TRUE)))
#else
    if((GET_USB_HUB_DISABLE_DURATION_TIMEOUT_FLAG() == _TRUE) &&
       (UserCommonUsbHubPathEnableCond(enumTypeCPcbPort) == _TRUE) &&
       (GET_USB_HUB_FORCE_USB3_ENABLE(enumTypeCPcbPort) == _TRUE))
#endif // End of #if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    {
        return _TRUE;
    }

    return _FALSE;
}

//--------------------------------------------------
// Description  : Usb Hub Handler Reset
// Input Value  : enumInputPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubReset(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

            // D0 Port
            SET_USB_HUB_STATE(_D0_TYPE_C_PORT, _USB_HUB_OFF);
            CLR_USB_HUB_INITIALIZED(_D0_TYPE_C_PORT);

            // Clear USB OSD Capability change marco
            // To Avoid C-C Unexpected Restart Again
            CLR_USB_HUB_OSD_CAPABILITY_CHG(_D0_TYPE_C_PORT);

#if(_D0_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            SysUsbHubCommunicationControl(_D0_TYPE_C_PORT, _DISABLE);
#endif

            break;

        case _D1_TYPE_C_PORT:

            // D1 Port
            SET_USB_HUB_STATE(_D1_TYPE_C_PORT, _USB_HUB_OFF);
            CLR_USB_HUB_INITIALIZED(_D1_TYPE_C_PORT);

            // Clear USB OSD Capability change marco
            // To Avoid C-C Unexpected Restart Again
            CLR_USB_HUB_OSD_CAPABILITY_CHG(_D1_TYPE_C_PORT);

#if(_D1_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            SysUsbHubCommunicationControl(_D1_TYPE_C_PORT, _DISABLE);
#endif

            break;

        case _D2_TYPE_C_PORT:

            // D2 Port
            SET_USB_HUB_STATE(_D2_TYPE_C_PORT, _USB_HUB_OFF);
            CLR_USB_HUB_INITIALIZED(_D2_TYPE_C_PORT);

            // Clear USB OSD Capability change marco
            // To Avoid C-C Unexpected Restart Again
            CLR_USB_HUB_OSD_CAPABILITY_CHG(_D2_TYPE_C_PORT);

#if(_D2_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            SysUsbHubCommunicationControl(_D2_TYPE_C_PORT, _DISABLE);
#endif

            break;

        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Usb Hub OSD Event Judgement
// Input Value  : void
// Output Value : None
//--------------------------------------------------
void SysUsbHubJudgeOSDEvent(void)
{
    EnumUsbHubOSDResult enumUsbHubOSDResult = _HUB_NONE_PORT;
    enumUsbHubOSDResult = UserCommonUsbHubGetOSDSelectResult();

    // Hub Switch OSD Event : Switch to Port
    // Comparing OSD info from User with Previous OSD info stored by kernel
    if(enumUsbHubOSDResult != GET_USB_HUB_OSD_SWITCH_PORT_RESULT())
    {
        switch(enumUsbHubOSDResult)
        {
#if(_D0_USB_HUB_SUPPORT == _ON)
            case _HUB_D0_TYPE_C_PORT:

                // Update Repeater & Hub USB Mode (U2/U3) From OSD Selected U2/U3 Capability
                SysUsbHubJudgeU2U3ModeCapability(_D0_TYPE_C_PORT);

                // Updata OSD Event : USB_HUB_SWITCH_TO_D0
                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_SWITCH_TO_D0);
                DebugMessageTypeC("9. [USB][OSDEvent] OSD Switch to D0", enumUsbHubOSDResult);

                break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
            case _HUB_D1_TYPE_C_PORT:

                // Update Repeater & Hub USB Mode (U2/U3) From OSD Selected U2/U3 Capability
                SysUsbHubJudgeU2U3ModeCapability(_D1_TYPE_C_PORT);

                // Updata OSD Event : USB_HUB_SWITCH_TO_D1
                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_SWITCH_TO_D1);
                DebugMessageTypeC("9. [USB][OSDEvent] OSD Switch to D1", enumUsbHubOSDResult);

                break;
#endif

            case _HUB_TYPE_B_PORT:

                // Updata OSD Event : USB_HUB_SWITCH_TO_B
                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_SWITCH_TO_B);
                DebugMessageTypeC("9. [USB][OSDEvent] OSD Switch to TypeB", enumUsbHubOSDResult);

                break;

            default:

                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_SWITCH_NONE);
                DebugMessageTypeC("9. [USB][OSDEvent][Debug] Switch to (Default)", enumUsbHubOSDResult);

                break;
        }
    }
    // Hub Switch OSD Event : Still at Port
    else
    {
        switch(enumUsbHubOSDResult)
        {
#if(_D0_USB_HUB_SUPPORT == _ON)
            case _HUB_D0_TYPE_C_PORT:

                // Update Repeater & Hub USB Mode (U2/U3) From OSD Selected U2/U3 Capability
                SysUsbHubJudgeU2U3ModeCapability(_D0_TYPE_C_PORT);

                // Updata OSD Event : USB_HUB_STILL_AT_D0
                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_STILL_AT_D0);

                break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
            case _HUB_D1_TYPE_C_PORT:

                // Update Repeater & Hub USB Mode (U2/U3) From OSD Selected U2/U3 Capability
                SysUsbHubJudgeU2U3ModeCapability(_D1_TYPE_C_PORT);

                // Updata OSD Event : USB_HUB_STILL_AT_D1
                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_STILL_AT_D1);

                break;
#endif

            case _HUB_TYPE_B_PORT:

                // Updata OSD Event : USB_HUB_STILL_AT_B
                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_STILL_AT_B);

                break;

            default:

                SET_HUB_SWITCH_OSD_EVENT(_USB_HUB_SWITCH_NONE);

                break;
        }
    }

    // Updata Hub Switch Result
    SET_USB_HUB_OSD_SWITCH_PORT_RESULT(enumUsbHubOSDResult);

#if(_USB3_REPEATER_MAC_SUPPORT == _ON)
    ScalerUsb3RepeaterMacSetU3HubOSDResult(enumUsbHubOSDResult);
#endif
}
//--------------------------------------------------
// Description  : Usb Hub TypeB Port Process
// Input Value  : void
// Output Value : None
//--------------------------------------------------
void SysUsbHubTypeBProcess(void)
{
    // TypeB Only Processing at TypeB OSD Event
    // OSD Event Still Case : Enable TypeB Hub
    if(GET_HUB_SWITCH_OSD_EVENT() == _USB_HUB_STILL_AT_B)
    {
        UserCommonUsbHubTypeBProcess();
    }
    // OSD Event Switch Case : Disable Repeater & Hub && Switch U2/U3 Mux to TypeB Port
    else if(GET_HUB_SWITCH_OSD_EVENT() == _USB_HUB_SWITCH_TO_B)
    {
        // Disable Unused Repeater & Hub
        SysUsbHubDisableUSBPath();

        // Control PCB U2/U3 Mux
        PCB_U2_MUX_SWITCH_CONTROL(_HUB_TYPE_B_PORT);
        PCB_U3_MUX_SWITCH_CONTROL(_HUB_TYPE_B_PORT);
    }
}

//--------------------------------------------------
// Description  : Usb Repeater/Hub Proc Handler
// Input Value  : enumInputPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubHandler(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumInputPort enumInputPort = SysUsbTypeCConvertToDxPort(enumTypeCPcbPort);
    enumInputPort = enumInputPort;

#if(_RDC_TEST_TYPE == _USB3_REDRIVER_RDC_TEST_TYPE)
    if(ScalerUsb3RepeaterPhyCtsModeCheck(enumTypeCPcbPort) == _TRUE)
    {
        // Release D0 Power Cut
        ScalerPowerDomainEnableControl(_HW_USB3_REPEATER_UFP0_APHY_POWER_CUT_GROUP, _POWER_CUT_OFF, _POWER_ON_DELAY_5_MS);

        // Release D1 Power Cut
        ScalerPowerDomainEnableControl(_POWER_CUT_GROUP_RX1_DP20_U32_APHY, _POWER_CUT_OFF, _POWER_ON_DELAY_5_MS);

        ScalerUsb3RepeaterPhyCtsFlow(enumTypeCPcbPort);
    }
#endif

#if((_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON) && (_USB3_RETIMER_MAC0_SUPPORT == _ON))
    // Check the Power State and P3 Status. Reset the P3 status when expectations are not met.
    if((GET_POWER_STATUS() == _POWER_STATUS_NORMAL) && (ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_EXIT_P3_PS))
    {
        ScalerUsb3RepeaterMacClearLowPowerStateStatus();
    }
#endif

    // OSD Event Switch Case : Switch to Dx Port => (Toggle Repeater & Hub) && (Switch U2/U3 Mux)
    if(((GET_HUB_SWITCH_OSD_EVENT() == _USB_HUB_SWITCH_TO_D0) && (enumTypeCPcbPort == _D0_TYPE_C_PORT)) ||
       ((GET_HUB_SWITCH_OSD_EVENT() == _USB_HUB_SWITCH_TO_D1) && (enumTypeCPcbPort == _D1_TYPE_C_PORT)))
    {
#if(_USB3_REPEATER_SUPPORT == _ON)
        // Disable Mac first to avoid U3 work on new Dx port
        ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);
#endif
        // Switch Dx Port Embedded & PCB U2/U3 Mux before disable Phy. Because Phy refers to mux setting to disable DFP Port.
        UserCommonUsbHubSwitchControl(enumTypeCPcbPort, _USB_PATH_ENABLE);

        // Disable Unused Repeater & Hub
        SysUsbHubDisableUSBPath();
    }

    if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
    {
        if(SysUsbHubGetUfpPortAttachStatus(enumTypeCPcbPort) == _FALSE)
        {
            // Only Active when => (Hub On Dx Port) && (Dx Port Attach Status change from Attacted to Unattached)
            if(SysUsbHubGetPortAttachStatusChange(enumTypeCPcbPort) == _TRUE)
            {
                // Disable Hub Vbus Power
                UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

#if(_USB3_REPEATER_SUPPORT == _ON)
                // Disable Repeater
                ScalerUsb3RepeaterPhyDisable(enumTypeCPcbPort, SysUsbHubGetUfpPortAttachStatus(enumTypeCPcbPort), SysUsbHubGetUfpOrientationStatus(enumTypeCPcbPort), SysUsbHubGetUfpPinAssignmentStatus(enumTypeCPcbPort));
                ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);

                // Clear PD_NO_Response Flag
                ScalerUsb3RepeaterMacCleanPdNoResponse(enumTypeCPcbPort);
#endif

                // Cancel Timer Event : To Avoid Current Port Unattached happen within Timer Activating
                SysUsbHubCancelForceEnableTimer(enumTypeCPcbPort);

                // Clear Force_U3_Enable Flag
                CLR_USB_HUB_FORCE_USB3_ENABLE(enumTypeCPcbPort);

                SysUsbHubReset(enumTypeCPcbPort);
                DebugMessageTypeC("9. [USB] X => OFF By Port Unattached, Dx Port:", enumTypeCPcbPort);
            }

            return;
        }

        switch(GET_USB_HUB_STATE(enumTypeCPcbPort))
        {
            case _USB_HUB_OFF:

                if(GET_POWER_STATUS() == _POWER_STATUS_NORMAL)
                {
#if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
#if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
                    if(GET_USB_HUB_INITIALIZED(enumTypeCPcbPort) == _TRUE)
                    {
                        if(ScalerTypeCGetVbusStatus(enumTypeCPcbPort) == _ENABLE)
                        {
#if(_USB3_REPEATER_SUPPORT == _ON)
                            // Enable Repeater by vbus on/off in CTS
                            ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _ENABLE);
#endif // End of #if(_USB3_REPEATER_SUPPORT == _ON)

                            // Enable Vbus for Hub to Enable U3 Function
                            UserCommonUsbHubPowerControl(enumTypeCPcbPort, _ENABLE);

                            SET_USB_HUB_STATE(enumTypeCPcbPort, _USB_HUB_CHECK);
                            DebugMessageTypeC("9. [USB] OFF => ON By Vbus On, Dx Port:", enumTypeCPcbPort);
                        }
                    }
                    else
#endif // End of #if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
#endif // End of #if(_PORT_CTRL_EMBEDDED_SUPPORT == _ON)
                    {
                        // Enable Timer For Forcing USB Enable after Timeout
                        SysUsbHubStartForceEnableTimer(enumTypeCPcbPort);

                        SET_USB_HUB_STATE(enumTypeCPcbPort, _USB_HUB_INITIAL);
                        DebugMessageTypeC("9. [USB] OFF => INITIAL By Port Attached, Dx Port:", enumTypeCPcbPort);
                    }
                }
                else
                {
                    if(GET_USB_HUB_CAPABILITY_SUPPORT() == _USB_HUB_MODE_U2)
                    {
                        // Enable Timer For Forcing USB Enable after Timeout
                        SysUsbHubStartForceEnableTimer(enumTypeCPcbPort);

                        SET_USB_HUB_STATE(enumTypeCPcbPort, _USB_HUB_INITIAL);
                        DebugMessageTypeC("9. [USB] OFF => INITIAL By U2 Capability, Dx Port:", enumTypeCPcbPort);
                    }
                }

                break;

            case _USB_HUB_INITIAL:

                // Wait for the start condition to be established
                if(SysUsbHubPathStartCondition(enumTypeCPcbPort) == _TRUE)
                {
                    // Cancel Timer Event : When Alt Mode is Ready or PD No Responese Before Timeout
                    SysUsbHubCancelForceEnableTimer(enumTypeCPcbPort);

                    // Hub INITIAL State Process
                    SysUsbHubInitialStateProc(enumTypeCPcbPort);
                    SET_USB_HUB_STATE(enumTypeCPcbPort, _USB_HUB_CHECK);
                    DebugMessageTypeC("9. [USB] INITIAL => CHECK, Dx Port:", enumTypeCPcbPort);
                }

                break;

            case _USB_HUB_CHECK:

                // Hub Re-start Process
                // Situation-1: OSD U3 On/OFF Switch with PinAssignment None OR Alt_Mode status change
                // Situation-2: User set USB Path Condition to _FALSE
                if((SysUsbHubReStart(enumTypeCPcbPort) == _TRUE) || (UserCommonUsbHubPathEnableCond(enumTypeCPcbPort) == _FALSE))
                {
                    // Disable Hub Vbus Power
                    UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

#if(_USB3_REPEATER_SUPPORT == _ON)
                    // Disable Repeater
                    ScalerUsb3RepeaterPhyDisable(enumTypeCPcbPort, SysUsbHubGetUfpPortAttachStatus(enumTypeCPcbPort), SysUsbHubGetUfpOrientationStatus(enumTypeCPcbPort), SysUsbHubGetUfpPinAssignmentStatus(enumTypeCPcbPort));
                    ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);
#endif

                    // Reset Hub Handler
                    SysUsbHubReset(enumTypeCPcbPort);

                    DebugMessageTypeC("9. [USB] CHECK => OFF By USB Re-start Condition", enumTypeCPcbPort);
                    DebugMessageTypeC("9. [USB] Re-start Check: UserCondition Status: ", UserCommonUsbHubPathEnableCond(enumTypeCPcbPort));
                }

#if(_USB_HUB_COMMUNICATION_SUPPORT == _ON)
                // Hub Dsp detect Process
                SysUsbHubDetectDspProc(enumTypeCPcbPort);
#endif
                // Hub CHECK State Process
                if(SysUsbHubCheckStateProc(enumTypeCPcbPort) == _TRUE)
                {
                    SET_USB_HUB_STATE(enumTypeCPcbPort, _USB_HUB_OFF);
                    DebugMessageTypeC("9. [USB] ON => OFF By Type-C Vbus < 5v, Dx Port:", enumTypeCPcbPort);
                }
                break;

            default:

                break;
        }
    }
    else
    {
        // observe Port Attach Status When Hub is currently Switched to other TypeCPcbPort by OSD
        if(SysUsbHubGetUfpPortAttachStatus(enumTypeCPcbPort) == _FALSE)
        {
            // Reset Foce_Enable Condition & PD_No_Response Condition
            if(SysUsbHubGetPortAttachStatusChange(enumTypeCPcbPort) == _TRUE)
            {
#if(_USB3_REPEATER_SUPPORT == _ON)
                // Disable Dx Port Phy
                ScalerUsb3RepeaterPhyDisable(enumTypeCPcbPort, _FALSE, SysUsbHubGetUfpOrientationStatus(enumTypeCPcbPort), SysUsbHubGetUfpPinAssignmentStatus(enumTypeCPcbPort));
#endif
                // Clear Timer Event : To Avoid OSD Switch and Previous Port Unattached happen with Timer Activating
                SysUsbHubCancelForceEnableTimer(enumTypeCPcbPort);

                // Clear Force_U3_Enable Flag
                CLR_USB_HUB_FORCE_USB3_ENABLE(enumTypeCPcbPort);

#if(_USB3_REPEATER_SUPPORT == _ON)
                // Clear PD_NO_Response Flag
                ScalerUsb3RepeaterMacCleanPdNoResponse(enumTypeCPcbPort);
#endif // End of #if(_USB3_REPEATER_SUPPORT == _ON)
            }
        }
        else
        {
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            // Dx port which U3 is not use need to disable dp/u3 lane enable when PinAssignment D chabge to PinAssignment none.
            if(GET_USB_TYPE_C_ALT_MODE_STATUS_CHG(enumTypeCPcbPort) == _TRUE)
            {
                if(SysUsbTypeCGetAltModeReady(enumTypeCPcbPort) == _FALSE)
                {
#if(_USB3_REPEATER_SUPPORT == _ON)
                    ScalerUsb3RepeaterPhyDisable(enumTypeCPcbPort, _TRUE, SysUsbHubGetUfpOrientationStatus(enumTypeCPcbPort), SysUsbHubGetUfpPinAssignmentStatus(enumTypeCPcbPort));
#endif
                }
            }
#endif
        }
    }
}

//--------------------------------------------------
// Description  : Usb Hub INITIAL State Process
// Input Value  : enumInputPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubInitialStateProc(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCPinCfgType enumTypeCPinCfgType = _TYPE_C_PIN_ASSIGNMENT_NONE;
    EnumTypeCOrientation enumTypeCOrientation = _TYPE_C_ORIENTATION_UNFLIP;
    EnumInputPort enumInputPort = SysUsbTypeCConvertToDxPort(enumTypeCPcbPort);

    enumTypeCOrientation = enumTypeCOrientation;
    enumInputPort = enumInputPort;

    // Get PinAssignment / Orientration info. from Type-C if Port Controller exist
    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCPinCfgType = GET_USB_TYPE_C_PIN_ASSIGNMENT(_D0_TYPE_C_PORT);
            enumTypeCOrientation = GET_USB_TYPE_C_ORIENTATION(_D0_TYPE_C_PORT);
#endif
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCPinCfgType = GET_USB_TYPE_C_PIN_ASSIGNMENT(_D1_TYPE_C_PORT);
            enumTypeCOrientation = GET_USB_TYPE_C_ORIENTATION(_D1_TYPE_C_PORT);
#endif
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCPinCfgType = GET_USB_TYPE_C_PIN_ASSIGNMENT(_D2_TYPE_C_PORT);
            enumTypeCOrientation = GET_USB_TYPE_C_ORIENTATION(_D2_TYPE_C_PORT);
#endif
            break;

        default:

            break;
    }

    switch(enumTypeCPinCfgType)
    {
        case _TYPE_C_PIN_ASSIGNMENT_D:
        case _TYPE_C_PIN_ASSIGNMENT_NONE:

#if(_USB3_REPEATER_SUPPORT == _ON)
            if(GET_USB_HUB_CAPABILITY_SUPPORT() == _USB_HUB_MODE_U3)
            {
                // Judge Tx Compliance Mode Condition
                SysUsbHubJudgeCpModeCondition(enumTypeCPinCfgType, enumTypeCPcbPort);

                // Config U3 Capability be PinAssignment
                SysUsbHubConfigU3ByPinAssignment(enumTypeCPinCfgType, enumTypeCPcbPort);

                // Repeater UFP/DFP PHY/MAC Config Setting
                ScalerUsb3RepeaterPhyInitial(enumTypeCPinCfgType, enumTypeCOrientation, enumTypeCPcbPort);
                ScalerUsb3RepeaterMacInitial(enumTypeCOrientation, enumTypeCPcbPort);

                // Repeater UFP/DFP Related Function Enable
                ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _ENABLE);

                DebugMessageTypeC("9. [USB] PIN_ASSIGNMENT_D/NONE with USB3 On, Dx Port:", enumTypeCPcbPort);
            }
#endif
            // Enable Vbus for Hub to Enable USB Function
            UserCommonUsbHubPowerControl(enumTypeCPcbPort, _ENABLE);

            SET_USB_HUB_INITIALIZED(enumTypeCPcbPort);

#if(_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            SysUsbHubCommunicationControl(enumTypeCPcbPort, _ENABLE);
#endif
            DebugMessageTypeC("9. [USB] PIN_ASSIGNMENT_D/NONE, Dx Port:", enumTypeCPcbPort);

            break;

        case _TYPE_C_PIN_ASSIGNMENT_C:

            // Enable Vbus for Hub to Enable USB2.0 Function
            UserCommonUsbHubPowerControl(enumTypeCPcbPort, _ENABLE);

#if(_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            SysUsbHubCommunicationControl(enumTypeCPcbPort, _ENABLE);
#endif
            DebugMessageTypeC("9. [USB] PIN_ASSIGNMENT_C with USB2 On, Dx Port:", enumTypeCPcbPort);

            break;

        case _TYPE_C_PIN_ASSIGNMENT_E:

            DebugMessageTypeC("9. [USB] PIN_ASSIGNMENT_E with USB Off, Dx Port:", enumTypeCPcbPort);

            break;

        default:

            DebugMessageTypeC("9. [USB] [ERROR] Unexpected Pin Assignment, Dx Port:", enumTypeCPcbPort);

            break;
    }
}

//--------------------------------------------------
// Description  : Usb Hub CHECK State Process
// Input Value  : enumInputPort
// Output Value : bDxPortTypeCVbusLow (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbHubCheckStateProc(EnumTypeCPcbPort enumTypeCPcbPort)
{
    bit bDxPortTypeCVbusLow = _FALSE;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
            switch(GET_USB_TYPE_C_STATE(enumTypeCPcbPort))
            {
                case _USB_TYPE_C_ATTACHED_STATE:

#if(_D0_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                    if(ScalerTypeCGetPdPRSwapProcessing(enumTypeCPcbPort) == _FALSE)
                    {
                        if(ScalerTypeCGetVbusStatus(enumTypeCPcbPort) == _DISABLE)
                        {
                            // Disable Hub Vbus Power
                            UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

#if(_USB3_REPEATER_SUPPORT == _ON)
                            // Disable Repeater
                            ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);
#endif // End of #if(_USB3_REPEATER_SUPPORT == _ON)
                            bDxPortTypeCVbusLow = _TRUE;
                        }
                    }
                    break;

                default:

                    break;
            }
#endif // End of #if(_D0_DP_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
#endif // End of #if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
#endif // End of #if(_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
            switch(GET_USB_TYPE_C_STATE(enumTypeCPcbPort))
            {
                case _USB_TYPE_C_ATTACHED_STATE:

#if(_D1_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                    if(ScalerTypeCGetPdPRSwapProcessing(enumTypeCPcbPort) == _FALSE)
                    {
                        if(ScalerTypeCGetVbusStatus(enumTypeCPcbPort) == _DISABLE)
                        {
                            // Disable Hub Vbus Power
                            UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

#if(_USB3_REPEATER_SUPPORT == _ON)
                            // Disable Repeater
                            ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);
#endif // End of #if(_USB3_REPEATER_SUPPORT == _ON)
                            bDxPortTypeCVbusLow = _TRUE;
                        }
                    }
                    break;

                default:

                    break;
            }
#endif // End of #if(_D1_DP_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
#endif // End of ##if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
#endif // End of #if(_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
#if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
            switch(GET_USB_TYPE_C_STATE(enumTypeCPcbPort))
            {
                case _USB_TYPE_C_ATTACHED_STATE:

#if(_D2_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
                    if(ScalerTypeCGetPdPRSwapProcessing(enumTypeCPcbPort) == _FALSE)
                    {
                        if(ScalerTypeCGetVbusStatus(enumTypeCPcbPort) == _DISABLE)
                        {
                            // Disable Hub Vbus Power
                            UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

#if(_USB3_REPEATER_SUPPORT == _ON)
                            // Disable Repeater
                            ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);
#endif // End of #if(_USB3_REPEATER_SUPPORT == _ON)
                            bDxPortTypeCVbusLow = _TRUE;
                        }
                    }
                    break;

                default:

                    break;
            }
#endif // End of #if(_D2_DP_TYPE_C_PORT_CTRL_TYPE == _PORT_CTRL_EMBEDDED)
#endif // End of #if(_USB_HUB_ENABLE_BY_TC_VBUS == _ENABLE)
#endif // End of #if(_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON)
            break;

        default:

            break;
    }
    return bDxPortTypeCVbusLow;
}

//--------------------------------------------------
// Description  : Config Usb Hub U3 function
// Input Value  : enumTypeCPinCfgType, enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubConfigU3ByPinAssignment(EnumTypeCPinCfgType enumTypeCPinCfgType, EnumTypeCPcbPort enumTypeCPcbPort)
{
    enumTypeCPinCfgType = enumTypeCPinCfgType;
    enumTypeCPcbPort = enumTypeCPcbPort;

#if(_USB3_REPEATER_SUPPORT == _ON)

    // Reset U3 Speed/Lane Support Capability to Gen1x1
    ScalerUsb3RepeaterMacCleanU3Capability();

    // Set U3 Speed/Lane Support Capability to PCB Setting
    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

            // D0 Port PCB Speed Capability Setting
#if((_D0_USB_3_SPEED_GEN2_SUPPORT == _ON) && (_HW_USB_MAX_LINK_RATE_SUPPORT == _USB_SPEED_10G))
            ScalerUsb3RepeaterMacSetU3GenSpeed(_USB_3_GEN2);
#endif
            // D0 Port PCB Lane Capability Setting
            if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_D)
            {
                ScalerUsb3RepeaterMacSetU3LaneCount(_USB_3_LANE_X1);
#if(_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON)
                // PinAssignment D - Set Initial Power Cut Mode to FW Mode
                ScalerUsb3RepeaterMacSetPowerCutMode(_USB_POWER_CUT_FW_MODE);
#endif
            }
            else
            {
#if((_D0_USB_3_LANE_X2_SUPPORT == _ON) && (_HW_USB_MAX_LINK_LANE_SUPPORT == _USB_LANE_X2))
                ScalerUsb3RepeaterMacSetU3LaneCount(_USB_3_LANE_X2);
#endif
#if(_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON)
                // PinAssignment None - Set Initial Power Cut Mode to HW Mode
                ScalerUsb3RepeaterMacSetPowerCutMode(_USB_POWER_CUT_HW_MODE);
#endif
            }

            break;

        case _D1_TYPE_C_PORT:

            // D1 Port PCB Speed Capability Setting
#if((_D1_USB_3_SPEED_GEN2_SUPPORT == _ON) && (_HW_USB_MAX_LINK_RATE_SUPPORT == _USB_SPEED_10G))
            ScalerUsb3RepeaterMacSetU3GenSpeed(_USB_3_GEN2);
#endif
            // D1 Port PCB Lane Capability Setting
            if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_D)
            {
                ScalerUsb3RepeaterMacSetU3LaneCount(_USB_3_LANE_X1);
#if(_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON)
                // PinAssignment D - Set Initial Power Cut Mode to FW Mode
                ScalerUsb3RepeaterMacSetPowerCutMode(_USB_POWER_CUT_FW_MODE);
#endif
            }
            else
            {
#if((_D1_USB_3_LANE_X2_SUPPORT == _ON) && (_HW_USB_MAX_LINK_LANE_SUPPORT == _USB_LANE_X2))
                ScalerUsb3RepeaterMacSetU3LaneCount(_USB_3_LANE_X2);
#endif
#if(_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON)
                // PinAssignment None - Set Initial Power Cut Mode to HW Mode
                ScalerUsb3RepeaterMacSetPowerCutMode(_USB_POWER_CUT_HW_MODE);
#endif
            }

            break;

        case _D2_TYPE_C_PORT:

            // D2 Port PCB Speed Capability Setting
#if((_D2_USB_3_SPEED_GEN2_SUPPORT == _ON) && (_HW_USB_MAX_LINK_RATE_SUPPORT == _USB_SPEED_10G))
            ScalerUsb3RepeaterMacSetU3GenSpeed(_USB_3_GEN2);
#endif
            // D2 Port PCB Lane Capability Setting
            if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_D)
            {
                ScalerUsb3RepeaterMacSetU3LaneCount(_USB_3_LANE_X1);
#if(_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON)
                // PinAssignment D - Set Initial Power Cut Mode to FW Mode
                ScalerUsb3RepeaterMacSetPowerCutMode(_USB_POWER_CUT_FW_MODE);
#endif
            }
            else
            {
#if((_D2_USB_3_LANE_X2_SUPPORT == _ON) && (_HW_USB_MAX_LINK_LANE_SUPPORT == _USB_LANE_X2))
                ScalerUsb3RepeaterMacSetU3LaneCount(_USB_3_LANE_X2);
#endif
#if(_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON)
                // PinAssignment None - Set Initial Power Cut Mode to HW Mode
                ScalerUsb3RepeaterMacSetPowerCutMode(_USB_POWER_CUT_HW_MODE);
#endif
            }

            break;

        default:

            break;
    }

#endif
}

//--------------------------------------------------
// Description  : Judge Compliance Mode Condition
// Input Value  : enumTypeCPinCfgType, enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubJudgeCpModeCondition(EnumTypeCPinCfgType enumTypeCPinCfgType, EnumTypeCPcbPort enumTypeCPcbPort)
{
    enumTypeCPinCfgType = enumTypeCPinCfgType;
    enumTypeCPcbPort = enumTypeCPcbPort;

#if(_USB3_REPEATER_SUPPORT == _ON)

    // Reset Phy CTS Condition Macro
    ScalerUsb3RetimerPhySetCtsCtrl(_OFF);

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

            // Check D0 Port PinAignment
            if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_NONE)
            {
#if((_D1_TYPE_C_CONNECTOR_SUPPORT == _ON) || (_D1_USB_TYPE_B_SUPPORT == _ON))
                if(SysUsbHubGetUfpPortAttachStatus(_D1_TYPE_C_PORT) == _FALSE)
#else
                if(GET_D1_CONNECT() == _FALSE)
#endif
                {
                    // Set Phy CTS CP Mode Condition _ON
                    // (1) Current Port At PinAssignment_None
                    // (2) The other Port Is Not Connected
                    ScalerUsb3RetimerPhySetCtsCtrl(_ON);
                }
            }
            break;

        case _D1_TYPE_C_PORT:

            // Check D0 Port PinAignment
            if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_NONE)
            {
#if((_D0_TYPE_C_CONNECTOR_SUPPORT == _ON) || (_D0_USB_TYPE_B_SUPPORT == _ON))
                if(SysUsbHubGetUfpPortAttachStatus(_D0_TYPE_C_PORT) == _FALSE)
#else
                if(GET_D0_CONNECT() == _FALSE)
#endif
                {
                    // Set Phy CTS CP Mode Condition _ON
                    // (1) Current Port At PinAssignment_None
                    // (2) The other Port Is Not Connected
                    ScalerUsb3RetimerPhySetCtsCtrl(_ON);
                }
            }
            break;

        default:

            break;
    }

#endif
}

//--------------------------------------------------
// Description  : Control Usb Hub Support U2 / U3
// Input Value  : enumInputPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubJudgeU2U3ModeCapability(EnumTypeCPcbPort enumTypeCPcbPort)
{
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    EnumTypeCPinCfgType enumTypeCPinCfgType = SysUsbTypeCRxGetPinAssignment(SysUsbTypeCConvertToDxPort(enumTypeCPcbPort));
#endif
    SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_NONE);

#if(_USB3_REPEATER_SUPPORT == _ON)
    // Integrate OSD U3 On/Off & U2/U3 Support at PS/PD
    if((GET_POWER_STATUS() == _POWER_STATUS_NORMAL) && (UserCommonUsbGetOsdU3Mode(enumTypeCPcbPort) == _USB_HUB_MODE_U3))
    {
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        if(SysUsbTypeCGetAltModeReady(enumTypeCPcbPort) == _TRUE)
        {
            if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_D)
            {
                SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U3);
            }
            else if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_C)
            {
                SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U2);
            }
            else
            {
                SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_NONE);
            }
        }
        else
#endif
        {
            SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U3);
        }
    }
    else if(((GET_POWER_STATUS() == _POWER_STATUS_NORMAL) && (UserCommonUsbGetOsdU3Mode(enumTypeCPcbPort) == _USB_HUB_MODE_U2)) ||
            ((GET_POWER_STATUS() == _POWER_STATUS_SAVING) && (GET_USB_HUB_PS_STATUS(enumTypeCPcbPort) == _PS_USB2_ENABLE)) ||
            ((GET_POWER_STATUS() == _POWER_STATUS_OFF) && (GET_USB_HUB_PD_STATUS(enumTypeCPcbPort) == _PD_USB2_ENABLE)))
    {
        SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U2);
    }
    else if(((GET_POWER_STATUS() == _POWER_STATUS_SAVING) && (GET_USB_HUB_PS_STATUS(enumTypeCPcbPort) == _PS_USB_DISABLE)) ||
            ((GET_POWER_STATUS() == _POWER_STATUS_OFF) && (GET_USB_HUB_PD_STATUS(enumTypeCPcbPort) == _PD_USB_DISABLE)))
    {
        SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_NONE);
    }
#else
    // Integrate OSD U3 On/Off & U2/U3 Support at PS/PD
    if((GET_POWER_STATUS() == _POWER_STATUS_NORMAL) && (UserCommonUsbGetOsdU3Mode(enumTypeCPcbPort) == _USB_HUB_MODE_U3))
    {
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
        if(SysUsbTypeCGetAltModeReady(enumTypeCPcbPort) == _TRUE)
        {
            if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_D)
            {
                SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U3);
            }
            else if(enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_C)
            {
                SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U2);
            }
            else
            {
                SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_NONE);
            }
        }
        else
#endif
        {
            SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U3);
        }
    }
    else if((GET_POWER_STATUS() == _POWER_STATUS_NORMAL) && (UserCommonUsbGetOsdU3Mode(enumTypeCPcbPort) == _USB_HUB_MODE_U2))
    {
        SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_U2);
    }
    else
    {
        SET_USB_HUB_CAPABILITY_SUPPORT(_USB_HUB_MODE_NONE);
    }
#endif
}

//--------------------------------------------------
// Description  : Usb Related Reset Flow
// Input Value  : enumInputPort
// Output Value : None
//--------------------------------------------------
bit SysUsbHubReStart(EnumTypeCPcbPort enumTypeCPcbPort)
{
    // Reset Hub Handler when OSD U3 On/OFF Switch: C-A cable / Dx Type-B Port
    if(GET_USB_HUB_OSD_CAPABILITY_CHG(enumTypeCPcbPort) == _TRUE)
    {
        // Clear USB OSD Capability change marco
        CLR_USB_HUB_OSD_CAPABILITY_CHG(enumTypeCPcbPort);

        switch(enumTypeCPcbPort)
        {
            case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
                if((GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort) == _TYPE_C_PIN_ASSIGNMENT_NONE) && (SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _TRUE))
                {
                    return _TRUE;
                }

#elif(_D0_USB_TYPE_B_SUPPORT == _ON)
                return _TRUE;
#endif

                break;

            case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
                if((GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort) == _TYPE_C_PIN_ASSIGNMENT_NONE) && (SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _TRUE))
                {
                    return _TRUE;
                }

#elif(_D1_USB_TYPE_B_SUPPORT == _ON)
                return _TRUE;
#endif

                break;

            case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
                if((GET_USB_TYPE_C_PIN_ASSIGNMENT(enumTypeCPcbPort) == _TYPE_C_PIN_ASSIGNMENT_NONE) && (SysUsbTypeCGetCcAttach(enumTypeCPcbPort) == _TRUE))
                {
                    return _TRUE;
                }

#elif(_D2_USB_TYPE_B_SUPPORT == _ON)
                return _TRUE;
#endif

                break;

            default:
                return _FALSE;

                break;
        }
    }

    // Reset When Alt_Mode status change: Ready to Not Ready
#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    if((SysUsbTypeCGetAltModeReady(enumTypeCPcbPort) == _FALSE) &&
#if((_PORT_CTRL_EMBEDDED_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
       (ScalerUsb3RepeaterMacGetPdNoResponse(enumTypeCPcbPort) == _FALSE) &&
#endif
       (GET_USB_HUB_FORCE_USB3_ENABLE(enumTypeCPcbPort) == _FALSE))
    {
        return _TRUE;
    }
#endif

#if(_TYPE_C_PORT_CTRL_SUPPORT == _ON)
    EnumTypeCPinCfgType enumTypeCPinCfgType = SysUsbTypeCRxGetPinAssignment(SysUsbTypeCConvertToDxPort(enumTypeCPcbPort));

    if((SysUsbTypeCGetAltModeReady(enumTypeCPcbPort) == _TRUE) && (GET_USB_TYPE_C_ALT_MODE_STATUS_CHG(enumTypeCPcbPort) == _TRUE) &&
       ((enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_C) || (enumTypeCPinCfgType == _TYPE_C_PIN_ASSIGNMENT_E)))
    {
        return _TRUE;
    }
#endif
    return _FALSE;
}

//--------------------------------------------------
// Description  : Judge TypeC with OSD Hub Switch Port
// Input Value  : EnumUsbHubOSDResult, EnumTypeCPcbPort
// Output Value : EnumUSBHubPathEnable
//--------------------------------------------------
EnumUSBHubPathEnable SysUsbJudgeHubPathEnable(EnumUsbHubOSDResult enumUsbHubOSDResult, EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumUSBHubPathEnable enumUSBHubPathEnable = _USB_PATH_DISABLE;
    enumTypeCPcbPort = enumTypeCPcbPort;

    switch(enumUsbHubOSDResult)
    {
#if(_D0_USB_HUB_SUPPORT == _ON)
        case _HUB_D0_TYPE_C_PORT:

            if(enumTypeCPcbPort == _D0_TYPE_C_PORT)
            {
                enumUSBHubPathEnable = _USB_PATH_ENABLE;
            }
            else
            {
                enumUSBHubPathEnable = _USB_PATH_DISABLE;
            }

            break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
        case _HUB_D1_TYPE_C_PORT:

            if(enumTypeCPcbPort == _D1_TYPE_C_PORT)
            {
                enumUSBHubPathEnable = _USB_PATH_ENABLE;
            }
            else
            {
                enumUSBHubPathEnable = _USB_PATH_DISABLE;
            }

            break;
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
        case _HUB_D2_TYPE_C_PORT:

            if(enumTypeCPcbPort == _D2_TYPE_C_PORT)
            {
                enumUSBHubPathEnable = _USB_PATH_ENABLE;
            }
            else
            {
                enumUSBHubPathEnable = _USB_PATH_DISABLE;
            }

            break;
#endif

        default:

            break;
    }

    return enumUSBHubPathEnable;
}

//--------------------------------------------------
// Description  : Usb Hub Disable Repeater and Hub Power
// Input Value  : void
// Output Value : None
//--------------------------------------------------
void SysUsbHubDisableUSBPath(void)
{
#if(_USB3_REPEATER_SUPPORT == _ON)
    // Disable All Repeater Function
    SysUsbRepeaterDisableAllFsm();
#endif

#if(_D0_USB_HUB_SUPPORT == _ON)
    UserCommonUsbHubPowerControl(_D0_TYPE_C_PORT, _DISABLE);

    // Reset D0 Port Hub Flow
    SysUsbHubReset(_D0_TYPE_C_PORT);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
    UserCommonUsbHubPowerControl(_D1_TYPE_C_PORT, _DISABLE);

    // Reset D1 Port Hub Flow
    SysUsbHubReset(_D1_TYPE_C_PORT);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
    UserCommonUsbHubPowerControl(_D2_TYPE_C_PORT, _DISABLE);

    // Reset D2 Port Hub Flow
    SysUsbHubReset(_D2_TYPE_C_PORT);
#endif
}

//--------------------------------------------------
// Description  : Return  TypeC CC Attached Status or TypeB vBus Detect
// Input Value  : EnumUsbHubOSDResult
// Output Value : U3 Cable(TypeC/TypeB) Attach Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbHubGetCableAttachStatus(EnumUsbHubOSDResult enumUsbHubOSDResult)
{
    bit bUSBCableAttachStatus = _FALSE;

    switch(enumUsbHubOSDResult)
    {
#if(_D0_USB_HUB_SUPPORT == _ON)
        case _HUB_D0_TYPE_C_PORT:

            bUSBCableAttachStatus = ScalerSyncGetCableStatus(_D0_INPUT_PORT);

            break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
        case _HUB_D1_TYPE_C_PORT:

            bUSBCableAttachStatus = ScalerSyncGetCableStatus(_D1_INPUT_PORT);

            break;
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
        case _HUB_D2_TYPE_C_PORT:

            bUSBCableAttachStatus = ScalerSyncGetCableStatus(_D2_INPUT_PORT);

            break;
#endif

        case _HUB_TYPE_B_PORT:

            // TypeB vBus Detect
            if(PCB_TYPE_B_VBUS_POWER_DETECT() == _TRUE)
            {
                bUSBCableAttachStatus = _TRUE;
            }
            else
            {
                bUSBCableAttachStatus = _FALSE;
            }

            break;

        default:

            bUSBCableAttachStatus = _FALSE;

            break;
    }

    return bUSBCableAttachStatus;
}

//--------------------------------------------------
// Description  : Return Dx Port Attached Status According to TypeC CC Attach Status/TypeB Vbus Status
// Input Value  : enumTypeCPcbPort --> PCB TypeC Port Converted from PCB Port
// Output Value : Port Attach Status (_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbHubGetUfpPortAttachStatus(EnumTypeCPcbPort enumTypeCPcbPort)
{
    bit bDxPortAttachStatus = _FALSE;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            bDxPortAttachStatus = SysUsbTypeCGetCcAttach(_D0_TYPE_C_PORT);

#elif(_D0_USB_TYPE_B_SUPPORT == _ON)
            // Get Current Type-B Attach Status :
            bDxPortAttachStatus = PCB_D0_TYPE_B_VBUS_POWER_DETECT();

            if(GET_USB_TYPE_B_ATTACH_STATUS(_D0_TYPE_C_PORT) != bDxPortAttachStatus)
            {
                // Set Type-B Attach Status Change
                SET_USB_TYPE_B_ATTACH_STATUS_CHG(_D0_TYPE_C_PORT);
                SET_USB_TYPE_B_ATTACH_STATUS(_D0_TYPE_C_PORT, bDxPortAttachStatus);
            }
            else
            {
                // Clear Type-B Attach Status Change
                CLR_USB_TYPE_B_ATTACH_STATUS_CHG(_D0_TYPE_C_PORT);
            }
#endif
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            bDxPortAttachStatus = SysUsbTypeCGetCcAttach(_D1_TYPE_C_PORT);

#elif(_D1_USB_TYPE_B_SUPPORT == _ON)
            // Get Current Type-B Attach Status :
            bDxPortAttachStatus = PCB_D1_TYPE_B_VBUS_POWER_DETECT();

            if(GET_USB_TYPE_B_ATTACH_STATUS(_D1_TYPE_C_PORT) != bDxPortAttachStatus)
            {
                // Set Type-B Attach Status Change
                SET_USB_TYPE_B_ATTACH_STATUS_CHG(_D1_TYPE_C_PORT);
                SET_USB_TYPE_B_ATTACH_STATUS(_D1_TYPE_C_PORT, bDxPortAttachStatus);
            }
            else
            {
                // Clear Type-B Attach Status Change
                CLR_USB_TYPE_B_ATTACH_STATUS_CHG(_D1_TYPE_C_PORT);
            }
#endif
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            bDxPortAttachStatus = SysUsbTypeCGetCcAttach(_D2_TYPE_C_PORT);

#elif(_D2_USB_TYPE_B_SUPPORT == _ON)
            // Get Current Type-B Attach Status :
            bDxPortAttachStatus = PCB_D2_TYPE_B_VBUS_POWER_DETECT();

            if(GET_USB_TYPE_B_ATTACH_STATUS(_D2_TYPE_C_PORT) != bDxPortAttachStatus)
            {
                // Set Type-B Attach Status Change
                SET_USB_TYPE_B_ATTACH_STATUS_CHG(_D2_TYPE_C_PORT);
                SET_USB_TYPE_B_ATTACH_STATUS(_D2_TYPE_C_PORT, bDxPortAttachStatus);
            }
            else
            {
                // Clear Type-B Attach Status Change
                CLR_USB_TYPE_B_ATTACH_STATUS_CHG(_D2_TYPE_C_PORT);
            }
#endif
            break;

        default:

            bDxPortAttachStatus = _FALSE;

            break;
    }
    return bDxPortAttachStatus;
}

//--------------------------------------------------
// Description  : Return Dx Port Attached Status Change According to TypeC CC Attach Status Change/TypeB Vbus Status Change
// Input Value  : enumTypeCPcbPort --> PCB TypeC Port Converted from PCB Port
// Output Value : Port Attach Status Change(_TRUE / _FALSE)
//--------------------------------------------------
bit SysUsbHubGetPortAttachStatusChange(EnumTypeCPcbPort enumTypeCPcbPort)
{
    bit bDxPortAttachStatusChange = _FALSE;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            bDxPortAttachStatusChange = GET_USB_TYPE_C_ATTACH_STATUS_CHG(_D0_TYPE_C_PORT);

#elif(_D0_USB_TYPE_B_SUPPORT == _ON)
            bDxPortAttachStatusChange = GET_USB_TYPE_B_ATTACH_STATUS_CHG(_D0_TYPE_C_PORT);

#endif
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            bDxPortAttachStatusChange = GET_USB_TYPE_C_ATTACH_STATUS_CHG(_D1_TYPE_C_PORT);

#elif(_D1_USB_TYPE_B_SUPPORT == _ON)
            bDxPortAttachStatusChange = GET_USB_TYPE_B_ATTACH_STATUS_CHG(_D1_TYPE_C_PORT);

#endif
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            bDxPortAttachStatusChange = GET_USB_TYPE_C_ATTACH_STATUS_CHG(_D2_TYPE_C_PORT);

#elif(_D2_USB_TYPE_B_SUPPORT == _ON)
            bDxPortAttachStatusChange = GET_USB_TYPE_B_ATTACH_STATUS_CHG(_D2_TYPE_C_PORT);

#endif
            break;

        default:
            bDxPortAttachStatusChange = _FALSE;

            break;
    }
    return bDxPortAttachStatusChange;
}

//--------------------------------------------------
// Description  : Usb Hub Disable Duration Delay Timer Event
// Input Value  : WORD usTimeoutCnt
// Output Value : None
//--------------------------------------------------
void SysUsbHubActiveHubDisableDurationTimerEvent(WORD usTimeoutCnt)
{
    if(usTimeoutCnt > 10)
    {
        ScalerTimerActiveTimerEvent(usTimeoutCnt, _SYSTEM_TIMER_EVENT_USB_HUB_DISABLE_DURATION_TIMEOUT);
    }
    else
    {
        ScalerTimerActiveTimerEvent(10, _SYSTEM_TIMER_EVENT_USB_HUB_DISABLE_DURATION_TIMEOUT);
    }
}

//--------------------------------------------------
// Description  : Usb Repeater/Hub Proc Handler
// Input Value  : enumInputPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubPowerSwitch(EnumPowerAction enumSwitch)
{
    switch(enumSwitch)
    {
        case _POWER_ACTION_NORMAL_TO_PS:
        case _POWER_ACTION_NORMAL_TO_OFF:

#if(_D0_USB_HUB_SUPPORT == _ON)
            SysUsbHubDxPortPowerSwitchProc(enumSwitch, _D0_TYPE_C_PORT);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
            SysUsbHubDxPortPowerSwitchProc(enumSwitch, _D1_TYPE_C_PORT);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
            SysUsbHubDxPortPowerSwitchProc(enumSwitch, _D2_TYPE_C_PORT);
#endif

#if(_USB3_REPEATER_PHY_SUPPORT == _ON)
#if(_D0_USB_HUB_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D0_TYPE_C_PORT);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D1_TYPE_C_PORT);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D2_TYPE_C_PORT);
#endif
#endif

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON))
            // If Lowe Power Status is in AT_P3_PS when PN->PS, shall do the power cut on flow.
            // It represents PS->PN is not triggered by USB3 and RTSSM always at the U3 State in power normal.
            if(ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_AT_P3_PS)
            {
                ScalerUsb3RetimerMac0PowerCutOnSleep();
            }

            // Clear the U3 Late Flag when leaving the Fake Saving State
            if(ScalerUsb3RepeaterMacGetPinDEnterFakeSavingU3Late() == _TRUE)
            {
                ScalerUsb3RepeaterMacClearPinDEnterFakeSavingU3Late();
            }
#endif
            break;

        case _POWER_ACTION_OFF_TO_FAKE_OFF:
        case _POWER_ACTION_AC_ON_TO_NORMAL:

#if(_USB3_REPEATER_PHY_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D0_TYPE_C_PORT);

            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D1_TYPE_C_PORT);

            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D2_TYPE_C_PORT);
#endif

            // Switch Embedded U2/U3 Mux Back to Previous Port
            switch(GET_USB_HUB_OSD_SWITCH_PORT_RESULT())
            {
#if(_D0_USB_HUB_SUPPORT == _ON)
                case _HUB_D0_TYPE_C_PORT:

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
                    ScalerUsb3RepeaterMacMuxSwitchControl(_D0_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
#if(_HW_USB2_EMB_MUX_SUPPORT == _ON)
                    ScalerUsb2MuxSwitchControl(_D0_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if(_HW_USB2_EMB_MUX_SUPPORT == _ON)

                    break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
                case _HUB_D1_TYPE_C_PORT:

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
                    ScalerUsb3RepeaterMacMuxSwitchControl(_D1_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
#if(_HW_USB2_EMB_MUX_SUPPORT == _ON)
                    ScalerUsb2MuxSwitchControl(_D1_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if(_HW_USB2_EMB_MUX_SUPPORT == _ON)

                    break;
#endif

                default:

                    break;
            }

            break;


        case _POWER_ACTION_PS_TO_NORMAL:
        case _POWER_ACTION_OFF_TO_NORMAL:

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON))
            // Power Cut OFF Flow when PS->PN is not triggered by USB3.
            if((ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_AT_P3_PS) && (ScalerUsb3RepeaterMacGetDetectNSQFlag() == _LOW))
            {
                // Power Cut OFF By FW Mode
                ScalerUsb3RetimerMac0PowerCutOffAwake();
            }
#endif

#if(_D0_USB_HUB_SUPPORT == _ON)
            SysUsbHubDxPortPowerSwitchProc(enumSwitch, _D0_TYPE_C_PORT);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
            SysUsbHubDxPortPowerSwitchProc(enumSwitch, _D1_TYPE_C_PORT);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
            SysUsbHubDxPortPowerSwitchProc(enumSwitch, _D2_TYPE_C_PORT);
#endif

#if(_USB3_REPEATER_PHY_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D0_TYPE_C_PORT);

            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D1_TYPE_C_PORT);

            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D2_TYPE_C_PORT);
#endif

            // Switch Embedded U2/U3 Mux Back to Previous Port
            switch(GET_USB_HUB_OSD_SWITCH_PORT_RESULT())
            {
#if(_D0_USB_HUB_SUPPORT == _ON)
                case _HUB_D0_TYPE_C_PORT:

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
                    ScalerUsb3RepeaterMacMuxSwitchControl(_D0_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
#if(_HW_USB2_EMB_MUX_SUPPORT == _ON)
                    ScalerUsb2MuxSwitchControl(_D0_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if(_HW_USB2_EMB_MUX_SUPPORT == _ON)

                    break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
                case _HUB_D1_TYPE_C_PORT:

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
                    ScalerUsb3RepeaterMacMuxSwitchControl(_D1_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_HW_USB3_REPEATER_MAC_MUX_TYPE == _ON))
#if(_HW_USB2_EMB_MUX_SUPPORT == _ON)
                    ScalerUsb2MuxSwitchControl(_D1_INPUT_PORT, _USB_PATH_ENABLE);
#endif // End of #if(_HW_USB2_EMB_MUX_SUPPORT == _ON)

                    break;
#endif

                default:

                    break;
            }

            break;

        case _POWER_ACTION_NORMAL_TO_FAKE_PS:
        case _POWER_ACTION_NORMAL_TO_FAKE_OFF:

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON))
            // PinAssignment D - Power Cut ON Flow
            ScalerUsb3RetimerMac0PowerCutOnSleep();
#endif
            break;

        case _POWER_ACTION_FAKE_PS_TO_NORMAL:
        case _POWER_ACTION_FAKE_OFF_TO_NORMAL:

#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON))
            if(ScalerUsb3RepeaterMacGetPinDEnterFakeSavingU3Late() == _TRUE)
            {
                // Special Case
                // Some Hosts may not enter the U3 state after sleep. When awake host shall disable the U3 IRQ enabled during PN->Fake Saving.
                ScalerUsb3RepeaterMacDisableU3IRQ();

                // Clear PinD Fake Saving U3 Late Flag
                ScalerUsb3RepeaterMacClearPinDEnterFakeSavingU3Late();
            }
#endif
            break;

        default:

#if(_USB3_REPEATER_PHY_SUPPORT == _ON)
#if(_D0_USB_HUB_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D0_TYPE_C_PORT);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D1_TYPE_C_PORT);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
            ScalerUsb3RepeaterPhyPowerSwitchInitial(enumSwitch, _D2_TYPE_C_PORT);
#endif
#endif

            break;
    }
}

//--------------------------------------------------
// Description  : Usb Dx Hub Power Switch Proc
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbHubDxPortPowerSwitchProc(EnumPowerAction enumSwitch, EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumInputPort enumInputPort = SysUsbTypeCConvertToDxPort(enumTypeCPcbPort);
    enumInputPort = enumInputPort;

    switch(enumSwitch)
    {
        case _POWER_ACTION_NORMAL_TO_PS:

#if(_USB_HUB_TOGGLE_POWER_TO_U2 == _ENABLE)
            if(GET_USB_HUB_PS_STATUS(enumTypeCPcbPort) == _PS_USB2_ENABLE)
            {
                // TODO: To Be Modified => Disable When Dx Port Enable and Only Dsiable Repeater
                // Toggle Hub Bus Power Detect to make Host detect USB2.0
                UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

                // Reset SysUsbHubHandler()
                // Hub will be enable after timeout and HubHandler execute U2 Initial Flow
                SysUsbHubReset(enumTypeCPcbPort);
            }
#endif
            if(GET_USB_HUB_PS_STATUS(enumTypeCPcbPort) == _PS_USB_DISABLE)
            {
                // Disable Hub
                UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

                // Reset SysUsbHubHandler()
                SysUsbHubReset(enumTypeCPcbPort);
            }
#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON))
            // Disable Repeater
            if(ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION)
            {
                ScalerUsb3RepeaterPhyDisable(enumTypeCPcbPort, SysUsbHubGetUfpPortAttachStatus(enumTypeCPcbPort), SysUsbHubGetUfpOrientationStatus(enumTypeCPcbPort), SysUsbHubGetUfpPinAssignmentStatus(enumTypeCPcbPort));
                ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);
            }
#endif
            break;

        case _POWER_ACTION_NORMAL_TO_OFF:

#if(_USB_HUB_TOGGLE_POWER_TO_U2 == _ENABLE)
            if(GET_USB_HUB_PD_STATUS(enumTypeCPcbPort) == _PD_USB2_ENABLE)
            {
                // TODO: To Be Modified => Disable When Dx Port Enable and Only Dsiable Repeater
                // Toggle Hub Bus Power Detect to make Host detect USB2.0
                UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

                // Reset SysUsbHubHandler()
                // Hub will be enable after timeout and HubHandler execute U2 Initial Flow
                SysUsbHubReset(enumTypeCPcbPort);
            }
#endif
            if(GET_USB_HUB_PD_STATUS(enumTypeCPcbPort) == _PD_USB_DISABLE)
            {
                // Disable Hub
                UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

                // Reset SysUsbHubHandler()
                SysUsbHubReset(enumTypeCPcbPort);
            }
#if((_USB3_REPEATER_MAC_SUPPORT == _ON) && (_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON))
            // Disable Repeater
            if(ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION)
            {
                ScalerUsb3RepeaterPhyDisable(enumTypeCPcbPort, SysUsbHubGetUfpPortAttachStatus(enumTypeCPcbPort), SysUsbHubGetUfpOrientationStatus(enumTypeCPcbPort), SysUsbHubGetUfpPinAssignmentStatus(enumTypeCPcbPort));
                ScalerUsb3RepeaterMacEnable(enumTypeCPcbPort, _DISABLE);
            }
#endif
            break;

        case _POWER_ACTION_PS_TO_NORMAL:

            if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
            {
                if((GET_USB_HUB_PS_STATUS(enumTypeCPcbPort) == _PS_USB2_ENABLE) && (UserCommonUsbGetOsdU3Mode(enumTypeCPcbPort) == _USB_HUB_MODE_U3))
                {
                    // Toggle Hub Bus Power Detect to make Host detect USB3.0
                    UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

                    // Reset SysUsbHunHandler() for Re-open Repeater & Hub
                    SysUsbHubReset(enumTypeCPcbPort);
                }
            }

            break;

        case _POWER_ACTION_OFF_TO_NORMAL:

            if(SysUsbJudgeHubPathEnable(GET_USB_HUB_OSD_SWITCH_PORT_RESULT(), enumTypeCPcbPort) == _USB_PATH_ENABLE)
            {
                if((GET_USB_HUB_PD_STATUS(enumTypeCPcbPort) == _PD_USB2_ENABLE) && (UserCommonUsbGetOsdU3Mode(enumTypeCPcbPort) == _USB_HUB_MODE_U3))
                {
                    // Toggle Hub Bus Power Detect to make Host detect USB3.0
                    UserCommonUsbHubPowerControl(enumTypeCPcbPort, _DISABLE);

                    // Reset SysUsbHunHandler() for Re-open Repeater & Hub
                    SysUsbHubReset(enumTypeCPcbPort);
                }
            }

            break;

        default:

            break;
    }
}

#if(_USB3_REPEATER_SUPPORT == _ON)
//--------------------------------------------------
// Description  : USB3 Repeater Get PD No Reponse Status
// Input Value  : EnumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
bit SysUsbHubC2ACableAttachStatus(EnumTypeCPcbPort enumTypeCPcbPort)
{
    return ScalerUsb3RepeaterMacGetPdNoResponse(enumTypeCPcbPort);
}

//--------------------------------------------------
// Description  : Usb Hub Communication Control => Power Switch to Saving/Off will disable all Repeater function
// Input Value  : enumInputPort , bEn
// Output Value : None
//--------------------------------------------------
void SysUsbRepeaterDisableAllFsm(void)
{
#if(_D0_USB_HUB_SUPPORT == _ON)
    ScalerUsb3RepeaterPhyDisable(_D0_TYPE_C_PORT, SysUsbHubGetUfpPortAttachStatus(_D0_TYPE_C_PORT), SysUsbHubGetUfpOrientationStatus(_D0_TYPE_C_PORT), SysUsbHubGetUfpPinAssignmentStatus(_D0_TYPE_C_PORT));
    ScalerUsb3RepeaterMacEnable(_D0_TYPE_C_PORT, _DISABLE);
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
    ScalerUsb3RepeaterPhyDisable(_D1_TYPE_C_PORT, SysUsbHubGetUfpPortAttachStatus(_D1_TYPE_C_PORT), SysUsbHubGetUfpOrientationStatus(_D1_TYPE_C_PORT), SysUsbHubGetUfpPinAssignmentStatus(_D1_TYPE_C_PORT));
    ScalerUsb3RepeaterMacEnable(_D1_TYPE_C_PORT, _DISABLE);
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
    ScalerUsb3RepeaterPhyDisable(_D2_TYPE_C_PORT, SysUsbHubGetUfpPortAttachStatus(_D2_TYPE_C_PORT), SysUsbHubGetUfpOrientationStatus(_D2_TYPE_C_PORT), SysUsbHubGetUfpPinAssignmentStatus(_D2_TYPE_C_PORT));
    ScalerUsb3RepeaterMacEnable(_D2_TYPE_C_PORT, _DISABLE);
#endif
}

//--------------------------------------------------
// Description  : Judge USB Cable Change
// Input Value  : void
// Output Value : EnumTypeCCableStatus : _USB_CABLE_UNPLUG / PLUG / UNCHANGE
//--------------------------------------------------
EnumUsbCableChangeStatus SysUsbHubGetAttachStatusChange(void)
{
    EnumUsbCableChangeStatus enumUsbCableChangeStatus = _USB_CABLE_UNCHANGE;

#if(_D0_USB_HUB_SUPPORT == _ON)
    if(SysUsbHubGetPortAttachStatusChange(_D0_TYPE_C_PORT) == _TRUE)
    {
        // Attach Status Changed, Check Attach Status
        if(SysUsbHubGetUfpPortAttachStatus(_D0_TYPE_C_PORT) == _TRUE)
        {
            enumUsbCableChangeStatus = _USB_CABLE_PLUG;
        }
        else
        {
            enumUsbCableChangeStatus = _USB_CABLE_UNPLUG;
        }
    }
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
    if(SysUsbHubGetPortAttachStatusChange(_D1_TYPE_C_PORT) == _TRUE)
    {
        // Attach Status Changed, Check Attach Status
        if(SysUsbHubGetUfpPortAttachStatus(_D1_TYPE_C_PORT) == _TRUE)
        {
            enumUsbCableChangeStatus = _USB_CABLE_PLUG;
        }
        else
        {
            enumUsbCableChangeStatus = _USB_CABLE_UNPLUG;
        }
    }
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
    if(SysUsbHubGetPortAttachStatusChange(_D2_TYPE_C_PORT) == _TRUE)
    {
        // Attach Status Changed, Check Attach Status
        if(SysUsbHubGetUfpPortAttachStatus(_D2_TYPE_C_PORT) == _TRUE)
        {
            enumUsbCableChangeStatus = _USB_CABLE_PLUG;
        }
        else
        {
            enumUsbCableChangeStatus = _USB_CABLE_UNPLUG;
        }
    }
#endif

    return enumUsbCableChangeStatus;
}

//--------------------------------------------------
// Description  : Judge USB3 Retimer PS Support Status
// Input Value  : void
// Output Value : EnumUSBPSSupportStatus
//--------------------------------------------------
EnumUSBPSSupportStatus SysUsbHubJudgeUsbPSStatus(void)
{
    EnumUSBPSSupportStatus enumHubPSSupportStatus = _PS_USB_DISABLE;

    switch(GET_USB_HUB_OSD_SWITCH_PORT_RESULT())
    {
#if(_D0_USB_HUB_SUPPORT == _ON)
        case _HUB_D0_TYPE_C_PORT:

            // Set USB Power Saving Status for Repeater Power Switch Use
            SET_USB_HUB_PS_STATUS(_D0_TYPE_C_PORT, UserCommonUsbHubGetUSBPSSupportStatus(_D0_TYPE_C_PORT));

            // Judge USB Power Saving Status, and Check CC Attach
#if((_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
            if((GET_USB_HUB_PS_STATUS(_D0_TYPE_C_PORT) == _PS_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D0_TYPE_C_PORT) == _TRUE) && (ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION))
#else
            if((GET_USB_HUB_PS_STATUS(_D0_TYPE_C_PORT) == _PS_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D0_TYPE_C_PORT) == _TRUE))
#endif
            {
                enumHubPSSupportStatus = _PS_USB3_ENABLE;
            }

            break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
        case _HUB_D1_TYPE_C_PORT:

            SET_USB_HUB_PS_STATUS(_D1_TYPE_C_PORT, UserCommonUsbHubGetUSBPSSupportStatus(_D1_TYPE_C_PORT));

#if((_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
            if((GET_USB_HUB_PS_STATUS(_D1_TYPE_C_PORT) == _PS_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D1_TYPE_C_PORT) == _TRUE) && (ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION))
#else
            if((GET_USB_HUB_PS_STATUS(_D1_TYPE_C_PORT) == _PS_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D1_TYPE_C_PORT) == _TRUE))
#endif
            {
                enumHubPSSupportStatus = _PS_USB3_ENABLE;
            }

            break;
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
        case _HUB_D2_TYPE_C_PORT:

            SET_USB_HUB_PS_STATUS(_D2_TYPE_C_PORT, UserCommonUsbHubGetUSBPSSupportStatus(_D2_TYPE_C_PORT));

#if((_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
            if((GET_USB_HUB_PS_STATUS(_D2_TYPE_C_PORT) == _PS_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D2_TYPE_C_PORT) == _TRUE) && (ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION))
#else
            if((GET_USB_HUB_PS_STATUS(_D2_TYPE_C_PORT) == _PS_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D2_TYPE_C_PORT) == _TRUE))
#endif
            {
                enumHubPSSupportStatus = _PS_USB3_ENABLE;
            }

            break;
#endif

        default:

            break;
    }

    return enumHubPSSupportStatus;
}

//--------------------------------------------------
// Description  : Judge USB3 Retimer PD Support Status
// Input Value  : void
// Output Value : EnumUSBPDSupportStatus
//--------------------------------------------------
EnumUSBPDSupportStatus SysUsbHubJudgeUsbPDStatus(void)
{
    EnumUSBPDSupportStatus enumUSBPDSupportStatus = _PD_USB_DISABLE;

    switch(GET_USB_HUB_OSD_SWITCH_PORT_RESULT())
    {
#if(_D0_USB_HUB_SUPPORT == _ON)
        case _HUB_D0_TYPE_C_PORT:

            // Set USB Power Down Status for Repeater Power Switch Use
            SET_USB_HUB_PD_STATUS(_D0_TYPE_C_PORT, UserCommonUsbHubGetUSBPDSupportStatus(_D0_TYPE_C_PORT));

#if((_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
            if((GET_USB_HUB_PD_STATUS(_D0_TYPE_C_PORT) == _PD_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D0_TYPE_C_PORT) == _TRUE) && (ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION))
#else
            if((GET_USB_HUB_PD_STATUS(_D0_TYPE_C_PORT) == _PD_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D0_TYPE_C_PORT) == _TRUE))
#endif
            {
                enumUSBPDSupportStatus = _PD_USB3_ENABLE;
            }

            break;
#endif

#if(_D1_USB_HUB_SUPPORT == _ON)
        case _HUB_D1_TYPE_C_PORT:

            SET_USB_HUB_PD_STATUS(_D1_TYPE_C_PORT, UserCommonUsbHubGetUSBPDSupportStatus(_D1_TYPE_C_PORT));

#if((_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
            if((GET_USB_HUB_PD_STATUS(_D1_TYPE_C_PORT) == _PD_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D1_TYPE_C_PORT) == _TRUE) && (ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION))
#else
            if((GET_USB_HUB_PD_STATUS(_D1_TYPE_C_PORT) == _PD_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D1_TYPE_C_PORT) == _TRUE))
#endif
            {
                enumUSBPDSupportStatus = _PD_USB3_ENABLE;
            }

            break;
#endif

#if(_D2_USB_HUB_SUPPORT == _ON)
        case _HUB_D2_TYPE_C_PORT:

            SET_USB_HUB_PD_STATUS(_D2_TYPE_C_PORT, UserCommonUsbHubGetUSBPDSupportStatus(_D2_TYPE_C_PORT));

#if((_USB3_U3_P3_POWER_SAVING_SUPPORT == _ON) && (_USB3_REPEATER_MAC_SUPPORT == _ON))
            if((GET_USB_HUB_PD_STATUS(_D2_TYPE_C_PORT) == _PD_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D2_TYPE_C_PORT) == _TRUE) && (ScalerUsb3RepeaterMacGetLowPowerStateStatus() == _USB3_RETIMER_NO_ACTION))
#else
            if((GET_USB_HUB_PD_STATUS(_D2_TYPE_C_PORT) == _PD_USB3_ENABLE) && (SysUsbHubGetUfpPortAttachStatus(_D2_TYPE_C_PORT) == _TRUE))
#endif
            {
                enumUSBPDSupportStatus = _PD_USB3_ENABLE;
            }

            break;
#endif

        default:

            break;
    }

    return enumUSBPDSupportStatus;
}

//--------------------------------------------------
// Description  : Return Dx Port Unflip/Flip Status
// Input Value  : enumTypeCPcbPort --> PCB TypeC Port Converted from PCB Port
// Output Value : EnumTypeCOrientation
//--------------------------------------------------
EnumTypeCOrientation SysUsbHubGetUfpOrientationStatus(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCOrientation enumTypeCOrientation = _TYPE_C_ORIENTATION_NONE;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCOrientation = SysUsbTypeCRxGetOrientation(SysUsbTypeCConvertToDxPort(_D0_TYPE_C_PORT));
#elif(_D0_USB_TYPE_B_SUPPORT == _ON)
            enumTypeCOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCOrientation = SysUsbTypeCRxGetOrientation(SysUsbTypeCConvertToDxPort(_D1_TYPE_C_PORT));
#elif(_D1_USB_TYPE_B_SUPPORT == _ON)
            enumTypeCOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCOrientation = SysUsbTypeCRxGetOrientation(SysUsbTypeCConvertToDxPort(_D2_TYPE_C_PORT));
#elif(_D2_USB_TYPE_B_SUPPORT == _ON)
            enumTypeCOrientation = _TYPE_C_ORIENTATION_UNFLIP;
#endif
            break;

        default:
            break;
    }

    return enumTypeCOrientation;
}

//--------------------------------------------------
// Description  : Return Dx Port PinAssignment Status
// Input Value  : enumTypeCPcbPort --> PCB TypeC Port Converted from PCB Port
// Output Value : EnumTypeCPinCfgType
//--------------------------------------------------
EnumTypeCPinCfgType SysUsbHubGetUfpPinAssignmentStatus(EnumTypeCPcbPort enumTypeCPcbPort)
{
    EnumTypeCPinCfgType enumTypeCPinCfgType = _TYPE_C_PIN_ASSIGNMENT_NONE;

    switch(enumTypeCPcbPort)
    {
        case _D0_TYPE_C_PORT:

#if(_D0_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCPinCfgType = SysUsbTypeCRxGetPinAssignment(SysUsbTypeCConvertToDxPort(_D0_TYPE_C_PORT));
#elif(_D0_USB_TYPE_B_SUPPORT == _ON)
            enumTypeCPinCfgType = _TYPE_C_PIN_ASSIGNMENT_NONE;
#endif
            break;

        case _D1_TYPE_C_PORT:

#if(_D1_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCPinCfgType = SysUsbTypeCRxGetPinAssignment(SysUsbTypeCConvertToDxPort(_D1_TYPE_C_PORT));
#elif(_D1_USB_TYPE_B_SUPPORT == _ON)
            enumTypeCPinCfgType = _TYPE_C_PIN_ASSIGNMENT_NONE;
#endif
            break;

        case _D2_TYPE_C_PORT:

#if(_D2_TYPE_C_PORT_CTRL_TYPE != _PORT_CTRL_NONE)
            enumTypeCPinCfgType = SysUsbTypeCRxGetPinAssignment(SysUsbTypeCConvertToDxPort(_D2_TYPE_C_PORT));
#elif(_D2_USB_TYPE_B_SUPPORT == _ON)
            enumTypeCPinCfgType = _TYPE_C_PIN_ASSIGNMENT_NONE;
#endif
            break;

        default:
            break;
    }

    return enumTypeCPinCfgType;
}
#endif // End of #if(_USB3_REPEATER_SUPPORT == _ON)

#if(_USB_HUB_COMMUNICATION_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Set Usb Hub SS mode by SMBus
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubSetSSModebySMBus(EnumTypeCPcbPort enumTypeCPcbPort, bit bEn)
{
    bEn = bEn;
    switch(enumTypeCPcbPort)
    {
#if(_D0_USB_HUB_COMMUNICATION_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            if(UserCommonUsbHubSetSSMode(enumTypeCPcbPort, bEn) == _USB_HUB_SET_U3_MODE_SUCCESS)
            {
                ScalerTimerReactiveTimerEvent(SysUsbHubGetU3ReadyDelayTime(enumTypeCPcbPort), _SYSTEM_TIMER_EVENT_D0_USBHUB_DETECT);
            }

            break;
#endif

#if(_D1_USB_HUB_COMMUNICATION_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            if(UserCommonUsbHubSetSSMode(enumTypeCPcbPort, bEn) == _USB_HUB_SET_U3_MODE_SUCCESS)
            {
                ScalerTimerReactiveTimerEvent(SysUsbHubGetU3ReadyDelayTime(enumTypeCPcbPort), _SYSTEM_TIMER_EVENT_D1_USBHUB_DETECT);
            }

            break;
#endif

#if(_D2_USB_HUB_COMMUNICATION_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            if(UserCommonUsbHubSetSSMode(enumTypeCPcbPort, bEn) == _USB_HUB_SET_U3_MODE_SUCCESS)
            {
                ScalerTimerReactiveTimerEvent(SysUsbHubGetU3ReadyDelayTime(enumTypeCPcbPort), _SYSTEM_TIMER_EVENT_D2_USBHUB_DETECT);
            }

            break;
#endif
        default:

            break;
    }
}

//--------------------------------------------------
// Description  : Set Usb Hub DSP Device Detect Flag
// Input Value  : enumTypeCPcbPort
// Output Value : None
//--------------------------------------------------
void SysUsbHubSetDspDeviceDetectFlag(EnumTypeCPcbPort enumTypeCPcbPort)
{
    SET_USB_HUB_DSP_DEVICE_DETECT_FLG(enumTypeCPcbPort);
}

//--------------------------------------------------
// Description  : Usb Hub Communication Control
// Input Value  : enumInputPort , bEn
// Output Value : None
//--------------------------------------------------
void SysUsbHubCommunicationControl(EnumTypeCPcbPort enumTypeCPcbPort, bit bEn)
{
    if(bEn == _ENABLE)
    {
        SET_USB_HUB_DSP_DEVICE_DETECT_FLG(enumTypeCPcbPort);
    }
    else
    {
        CLR_USB_HUB_DSP_DEVICE_DETECT_FLG(enumTypeCPcbPort);

        switch(enumTypeCPcbPort)
        {
#if(_D0_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            case _D0_TYPE_C_PORT:

                ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D0_USBHUB_DETECT);

                break;
#endif

#if(_D1_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            case _D1_TYPE_C_PORT:

                ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D1_USBHUB_DETECT);

                break;
#endif

#if(_D2_USB_HUB_COMMUNICATION_SUPPORT == _ON)
            case _D2_TYPE_C_PORT:

                ScalerTimerCancelTimerEvent(_SYSTEM_TIMER_EVENT_D2_USBHUB_DETECT);

                break;
#endif

            default:

                break;
        }
    }
}

//--------------------------------------------------
// Description  : Detect Usb Hub Info
// Input Value  : enumInputPort --> Input Port
// Output Value : None
//--------------------------------------------------
void SysUsbHubDetectDspProc(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_USB_HUB_COMMUNICATION_SUPPORT == _ON)
        case _D0_TYPE_C_PORT:

            if(GET_USB_HUB_DSP_DEVICE_DETECT_FLG(_D0_TYPE_C_PORT) == _TRUE)
            {
                SysUsbHubCommunicationControl(_D0_TYPE_C_PORT, _DISABLE);
                ScalerTimerActiveTimerEvent(UserCommonUsbHubSetPollingStep(_D0_TYPE_C_PORT), _SYSTEM_TIMER_EVENT_D0_USBHUB_DETECT);

                if(UserCommonUsbHubDetectDFPStatus(_D0_TYPE_C_PORT) == _HUB_DSP_DEVICE_CHANGE)
                {
                    SET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D0_TYPE_C_PORT, _HUB_DSP_DEVICE_CHANGE);

                    DebugMessageTypeC("8. [TYPE C] <HUB> D0 Hub Info Change", GET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D0_TYPE_C_PORT));
                }
            }

            break;
#endif

#if(_D1_USB_HUB_COMMUNICATION_SUPPORT == _ON)
        case _D1_TYPE_C_PORT:

            if(GET_USB_HUB_DSP_DEVICE_DETECT_FLG(_D1_TYPE_C_PORT) == _TRUE)
            {
                SysUsbHubCommunicationControl(_D1_TYPE_C_PORT, _DISABLE);
                ScalerTimerActiveTimerEvent(UserCommonUsbHubSetPollingStep(_D1_TYPE_C_PORT), _SYSTEM_TIMER_EVENT_D1_USBHUB_DETECT);

                if(UserCommonUsbHubDetectDFPStatus(_D1_TYPE_C_PORT) == _HUB_DSP_DEVICE_CHANGE)
                {
                    SET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D1_TYPE_C_PORT, _HUB_DSP_DEVICE_CHANGE);

                    DebugMessageTypeC("8. [TYPE C] <HUB> D0 Hub Info Change", GET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D1_TYPE_C_PORT));
                }
            }

            break;
#endif

#if(_D2_USB_HUB_COMMUNICATION_SUPPORT == _ON)
        case _D2_TYPE_C_PORT:

            if(GET_USB_HUB_DSP_DEVICE_DETECT_FLG(_D2_TYPE_C_PORT) == _TRUE)
            {
                SysUsbHubCommunicationControl(_D2_TYPE_C_PORT, _DISABLE);
                ScalerTimerActiveTimerEvent(UserCommonUsbHubSetPollingStep(_D2_TYPE_C_PORT), _SYSTEM_TIMER_EVENT_D2_USBHUB_DETECT);

                if(UserCommonUsbHubDetectDFPStatus(_D2_TYPE_C_PORT) == _HUB_DSP_DEVICE_CHANGE)
                {
                    SET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D2_TYPE_C_PORT, _HUB_DSP_DEVICE_CHANGE);

                    DebugMessageTypeC("8. [TYPE C] <HUB> D0 Hub Info Change", GET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D2_TYPE_C_PORT));
                }
            }

            break;
#endif

        default:
            break;
    }
}

//--------------------------------------------------
// Description  : Set Usb Hub Config U3 Delay Time
// Input Value  : enumInputPort --> Input Port
// Output Value : Usb Hub Info
//--------------------------------------------------
WORD SysUsbHubGetU3ReadyDelayTime(EnumTypeCPcbPort enumTypeCPcbPort)
{
    switch(enumTypeCPcbPort)
    {
#if(_D0_USB_HUB_COMMUNICATION_SUPPORT == _ON)

        case _D0_TYPE_C_PORT:

            if(UserCommonUsbHubGetControlMode(_D0_TYPE_C_PORT) == _USB_HUB_CTR_BY_USER)
            {
                return SEC(0);
            }
            else
            {
                return SEC(2);
            }

            break;
#endif

#if(_D1_USB_HUB_COMMUNICATION_SUPPORT == _ON)

        case _D1_TYPE_C_PORT:

            if(UserCommonUsbHubGetControlMode(_D1_TYPE_C_PORT) == _USB_HUB_CTR_BY_USER)
            {
                return SEC(0);
            }
            else
            {
                return SEC(2);
            }

            break;
#endif

#if(_D2_USB_HUB_COMMUNICATION_SUPPORT == _ON)

        case _D2_TYPE_C_PORT:

            if(UserCommonUsbHubGetControlMode(_D2_TYPE_C_PORT) == _USB_HUB_CTR_BY_USER)
            {
                return SEC(0);
            }
            else
            {
                return SEC(2);
            }

            break;
#endif

        default:
            break;
    }

    return SEC(0);
}

//--------------------------------------------------
// Description  : For OSD Handler to do Process According to USB Hub Info
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbHubOsdProc(void)
{
#if((_D0_TYPE_C_PORT_CTRL_SUPPORT == _ON) && (_D0_USB_HUB_COMMUNICATION_SUPPORT == _ON))
    if(GET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D0_TYPE_C_PORT) == _HUB_DSP_DEVICE_CHANGE)
    {
        UserCommonUsbHubDspChangeProc(_D0_TYPE_C_PORT);

        // 1. Get Latest Source Capability from Port Controller
        if(SysUsbTypeCUpdatePortCtrlSrcPdo(_D0_TYPE_C_PORT) == _TYPE_C_PDO_CHANGE)
        {
            // 2. Set Flag to Request Port Ctrl to Re-Send Source Capability Message
            SET_USB_TYPE_C_CAPABILITY_CHG(_D0_TYPE_C_PORT, _TYPE_C_SEND_SRC_CAP);
        }

        SET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D0_TYPE_C_PORT, _HUB_DSP_DEVICE_NO_CHANGE);
    }
#endif

#if((_D1_TYPE_C_PORT_CTRL_SUPPORT == _ON) && (_D1_USB_HUB_COMMUNICATION_SUPPORT == _ON))
    if(GET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D1_TYPE_C_PORT) == _HUB_DSP_DEVICE_CHANGE)
    {
        UserCommonUsbHubDspChangeProc(_D1_TYPE_C_PORT);

        // 1. Get Latest Source Capability from Port Controller
        if(SysUsbTypeCUpdatePortCtrlSrcPdo(_D1_TYPE_C_PORT) == _TYPE_C_PDO_CHANGE)
        {
            // 2. Set Flag to Request Port Ctrl to Re-Send Source Capability Message
            SET_USB_TYPE_C_CAPABILITY_CHG(_D1_TYPE_C_PORT, _TYPE_C_SEND_SRC_CAP);
        }

        SET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D1_TYPE_C_PORT, _HUB_DSP_DEVICE_NO_CHANGE);
    }
#endif

#if((_D2_TYPE_C_PORT_CTRL_SUPPORT == _ON) && (_D2_USB_HUB_COMMUNICATION_SUPPORT == _ON))
    if(GET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D2_TYPE_C_PORT) == _HUB_DSP_DEVICE_CHANGE)
    {
        UserCommonUsbHubDspChangeProc(_D2_TYPE_C_PORT);

        // 1. Get Latest Source Capability from Port Controller
        if(SysUsbTypeCUpdatePortCtrlSrcPdo(_D2_TYPE_C_PORT) == _TYPE_C_PDO_CHANGE)
        {
            // 2. Set Flag to Request Port Ctrl to Re-Send Source Capability Message
            SET_USB_TYPE_C_CAPABILITY_CHG(_D2_TYPE_C_PORT, _TYPE_C_SEND_SRC_CAP);
        }

        SET_USB_HUB_PLUG_DEVICE_CHANGE_FLG(_D2_TYPE_C_PORT, _HUB_DSP_DEVICE_NO_CHANGE);
    }
#endif
}

#endif // End of #if(_USB_HUB_COMMUNICATION_SUPPORT == _ON)
#endif // End of #if(_USB_HUB_SUPPORT == _ON)

#if(_USB2_HOST_SUPPORT == _ON)
#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_MAIN_LOOP)
//--------------------------------------------------
// Description  : U2Host Function Inital Setting
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbU2HostAcOnInitial(void)
{
#if(_USB2_HOST_EHCI_SUPPORT == _ON)
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
    EnumUSB2HostEventType enumUSB2HostEventType = _U2HOST_FILE_NAME_SEARCH_EVENT;
    EnumUSB2HostEventChangeType enumUSB2HostEventChangeType = _U2HOST_OSD_FW_UPDATE_ENABLE;
#endif
#endif

    SET_U2HOST_MODE_STATE(_U2HOST_MODE_STATE_POWER_OFF);
    SET_U2HOST_CONNECT_STATUS(_U2HOST_CONNECT_STATUS_NONE);
    SET_U2HOST_COMMUNICATE_STATE(_U2HOST_COMMUNICATE_STATE_NONE);
    SET_U2HOST_ENUM_STATE(_U2HOST_ENUM_STATE_NONE);

    SET_U2HOST_CONNECT_DET_READY_FLAG();
    CLR_U2HOST_MODE_STATE_CHANGE_FLAG();
    CLR_U2HOST_COMPLETE_STATUS();
    CLR_U2HOST_TRANSFER_STATUS();

    // Reset ValidDevIndex to No Valid Device
    g_stUsbU2HostDevConnectInfo.ucValidDevIndex = 0x00;

#if(_USB2_HOST_OHCI_SUPPORT == _ON)
    if(GET_U2HOST_OWENER() == _U2HOST_OWNER_OHCI)
    {
        ScalerUsbU2HostClrContent(_U2HOST_OWNER_OHCI);
    }
#if(_USB2_HOST_OHCI_COLOR_ANALYZER_SUPPORT == _ON)
    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_NONE);
    CLR_U2HOST_COLOR_REQ_STATUS();
    CLR_U2HOST_COLOR_RSP_STATUS();
#endif
#endif

#if(_USB2_HOST_EHCI_SUPPORT == _ON)
    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
    if(GET_U2HOST_OWENER() == _U2HOST_OWNER_EHCI)
    {
        ScalerUsbU2HostClrContent(_U2HOST_OWNER_EHCI);
    }
    ScalerUsbFileSysInitial();

#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON)
    // Reset File name("z") - [Test_xx_yy_z], only need to Reset "z".[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
    ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_M1_INDEX);
    CLR_U2HOST_DUMP_CUR_FRAME_FINISH();
#endif

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
    CLR_U2_HOST_FW_UPDATE_RATE();
    CLR_U2HOST_BULK_READ_ENABLE();

    // Clear All Event Status and Event Change Marco
    for(enumUSB2HostEventType = _U2HOST_FILE_NAME_SEARCH_EVENT; enumUSB2HostEventType < _U2HOST_EVENT_COUNT; enumUSB2HostEventType++)
    {
        if(GET_U2HOST_EVENT_STATUS(enumUSB2HostEventType) == _U2HOST_EVENT_ON_GOING)
        {
            CLR_U2HOST_EVENT_STATUS(enumUSB2HostEventType);
        }
    }

    for(enumUSB2HostEventChangeType = _U2HOST_OSD_FW_UPDATE_ENABLE; enumUSB2HostEventChangeType < _U2HOST_EVENT_CHANGE_COUNT; enumUSB2HostEventChangeType++)
    {
        CLR_U2HOST_EVENT_CHANGE(enumUSB2HostEventChangeType);
        CLR_U2HOST_EVENT_CHANGE_STATUS(enumUSB2HostEventChangeType);
    }
#endif

    CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

#endif // End of #if(_USB2_HOST_EHCI_SUPPORT == _ON)
}

//--------------------------------------------------
// Description  : U2Host Handler Function
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbU2HostHandler(void)
{
    do
    {
        ScalerUsbU2HostJudgeHandler();
        SysUsbU2HostModeHandler();

#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON)
        ScalerDebug(); // For tool polling dummy reg

#endif
    }
    while(0);
/*
    // Local Test Use, the actual use method is determined by Dolby Owner
    while((_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON) &&
          (g_bUsbU2HostDummyRegBit0 == _TRUE) &&
          (GET_RGN_DISPLAY_STATE(_REGION_INDEX_0) == _DISPLAY_STATE_ACTIVE)) ;
*/
}

//----------------------------------------------------------------------------------------------------
// Description  : USB Mode State Machine
// Input Value  : None
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostModeHandler(void)
{
    switch(GET_U2HOST_MODE_STATE())
    {
        case _U2HOST_MODE_STATE_EHCI_RH_PORT_ENABLE:

            if(GET_U2HOST_MODE_STATE_CHANGE_FLAG() == _TRUE)
            {
                CLR_U2HOST_MODE_STATE_CHANGE_FLAG();

                // Reserved
            }

            break;

        case _U2HOST_MODE_STATE_COMMUNICATION:

            SysUsbU2HostCommunication();

            if(GET_U2HOST_MODE_STATE_CHANGE_FLAG() == _TRUE)
            {
                CLR_U2HOST_MODE_STATE_CHANGE_FLAG();

                // Reserved
            }
            break;

        case _U2HOST_MODE_STATE_OHCI_POWER_ON:

            if(GET_U2HOST_MODE_STATE_CHANGE_FLAG() == _TRUE)
            {
                CLR_U2HOST_MODE_STATE_CHANGE_FLAG();
                ScalerUsbU2HostPowerControl(_U2HOST_OWNER_OHCI, _ON);
                // SET_U2HOST_MODE_STATE(_U2HOST_MODE_STATE_OHCI_RH_PORT_ENABLE);
            }

            break;

        case _U2HOST_MODE_STATE_OHCI_RH_PORT_ENABLE:

            if(GET_U2HOST_MODE_STATE_CHANGE_FLAG() == _TRUE)
            {
                CLR_U2HOST_MODE_STATE_CHANGE_FLAG();

                // Reserved
            }
            break;

        case _U2HOST_MODE_STATE_ROOT_HUB_REMOVE_DEVICE:

            if(GET_U2HOST_MODE_STATE_CHANGE_FLAG() == _TRUE)
            {
                CLR_U2HOST_MODE_STATE_CHANGE_FLAG();
                SysUsbU2HostRootHubRemoveDevice(GET_U2HOST_OWENER());

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                // Error Handling for FW Update when USB Device removed
                SET_U2HOST_EVENT_STATUS(_U2HOST_FW_UPDATE_EVENT, _U2HOST_EVENT_FAIL);
#endif
                SET_U2HOST_COMMUNICATE_STATE(_U2HOST_COMMUNICATE_STATE_NONE);
            }

            break;

        default:
            break;
    }

    SysUsbU2HostDataProcHandler(GET_U2HOST_OWENER());
}

//----------------------------------------------------------------------------------------------------
// Description  : USB Communication State Machine
// Input Value  : None
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostCommunication(void)
{
    if(GET_U2HOST_TRANSFER_STATUS() == _FALSE)
    {
        // Make sure cmd will not be executed repeatly until U2Host think it can send next cmd
        SET_U2HOST_TRANSFER_STATUS();

        switch(GET_U2HOST_COMMUNICATE_STATE())
        {
            case _U2HOST_COMMUNICATE_STATE_ENUMERATION:

                ScalerUsbU2HostEnum(GET_U2HOST_OWENER());
                break;

            case _U2HOST_COMMUNICATE_STATE_BULK_TRANS_OPERATION:
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                ScalerUsbU2HostBulkReadOperation();
#endif

#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON)
                if(GET_RGN_DISPLAY_STATE(_REGION_INDEX_0) == _DISPLAY_STATE_ACTIVE)
                {
                    SET_U2HOST_DDR_STATE(_U2HOST_DDR_READY);

                    // CAITEST USE - force true
                    // g_bUsbU2HostDummyRegBit0 = _TRUE;
                }
                else
                {
                    SET_U2HOST_DDR_STATE(_U2HOST_DDR_NOT_READY);
                    DebugMessageU2HostEHCI("DisPlay State Inactive!!!.", 0);
                }

                if(g_bUsbU2HostDummyRegBit0 == _TRUE)
                {
                    ScalerUsbU2HostBulkWriteOperation(GET_U2HOST_DDR_STATE());
                }
#endif
                break;

            case _U2HOST_COMMUNICATE_STATE_INT_TRANS_OPERATION:
#if(_USB2_HOST_OHCI_SUPPORT == _ON)
                ScalerUsbU2HostIntTransOperation();
#endif
                break;

#if(_USB2_HOST_OHCI_COLOR_ANALYZER_SUPPORT == _ON)
            case _U2HOST_COMMUNICATE_STATE_COLOR_ANALYZER_OPERATION:

                ScalerUsbU2HostColorOperation();
                break;
#endif
            default:

                break;
        }
    }
}

//----------------------------------------------------------------------------------------------------
// Description  : USB Remove Device from Root Hub Process
// Input Value  : USB Host Controller Type : EHCI or OHCI
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostRootHubRemoveDevice(EnumUsbU2HostOwner enumOwner)
{
    DebugMessageU2Host("[Enum] Root Hub Remove Device", 0);

    SysUsbU2HostAcOnInitial();

    if(enumOwner == _U2HOST_OWNER_OHCI)
    {
        // Contain Configuration Flag (CF) set to 1 for port routing control (all ports attached to EHCI)
        ScalerUsbU2HostPortOwnerSwitch(_U2HOST_OWNER_EHCI);

        // Include in ScalerUsbU2HostPortOwnerSwitch()
        // ScalerUsbU2HostSetRegBitField(_PDF_04_PT_054_EHCI_PORTSC_1, ~_BIT4, _BIT4);
        // ScalerUsbU2HostSetRegBitField(0x0541, ~_BIT4, _BIT4);
    }
    else
    {
        // No defined
    }

    // Enable Timer Event - Time interval from unplug to next detect connection
    SysUsbU2HostActiveDetConnectDurationTimerEvent();

    // Make sure not excute connect handler if CONNECT_CHECK_DURATION_TIME is not expired
    CLR_U2HOST_CONNECT_DET_READY_FLAG();
}

//--------------------------------------------------
// Description  : Usb U2Host Time interval from unplug to next detect connection
// Input Value  : None
// Output Value : None
//--------------------------------------------------
void SysUsbU2HostActiveDetConnectDurationTimerEvent(void)
{
    // Enable Timer Event - Time interval from unplug to next detect connection
    ScalerTimerActiveTimerEvent(_USB_U2HOST_CONNECT_CHECK_DURATION_TIME, _SYSTEM_TIMER_EVENT_USB_U2HOST_DETECT);
}

//----------------------------------------------------------------------------------------------------
// Description  : USB Data Process Procedure
// Input Value  : USB Host Controller Type : EHCI or OHCI
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostDataProcHandler(EnumUsbU2HostOwner enumOwner)
{
    if(ScalerUsbU2HostCheckLastTransactionCompleteStatus(enumOwner) == _TRUE)
    {
        SET_U2HOST_COMPLETE_STATUS();
        // DebugMessageU2HostEHCI("[Data] EHCI Complete Last Trans", 0);
    }
    else
    {
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
        // FW Burn-In Feature. Any Fail happen.
        if(GET_U2HOST_FLOW_RESET() == _TRUE)
        {
            CLR_U2HOST_FLOW_RESET();
            CLR_U2HOST_BULK_READ_ENABLE();
            DebugMessageU2Host("[U2 Host] Reconnect !!!", 0xFF);

            // U2 Host Reconnect
            SysUsbU2HostReconnect();
        }

        // FW Burn-In Feature. Wait End-User Enable FW Update Function in OSD.
        if(GET_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_UPDATE_ENABLE) == _TRUE)
        {
            if(GET_U2HOST_EVENT_CHANGE_STATUS(_U2HOST_OSD_FW_UPDATE_ENABLE) == _ENABLE)
            {
                CLR_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_UPDATE_ENABLE);
                DebugMessageU2Host("[U2 Host] Reconnect by OSD Flow Enable !!!", 0xFF);

                // U2 Host Reconnect
                SysUsbU2HostReconnect();
                // Enable Bulk Read AFTER Reconnect
                SET_U2HOST_BULK_READ_ENABLE();
            }
            else
            {
                CLR_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_UPDATE_ENABLE);
                CLR_U2HOST_BULK_READ_ENABLE();
                DebugMessageU2Host("[U2 Host] OSD FW Update Disable !!!", 0xFF);
            }
        }
#endif
        // Not define;
        // DebugMessageU2HostEHCI("[Data] EHCI Not Complete Lase Trans", 0);

        /*
        if(GET_U2HOST_COMMUNICATE_STATE() == _U2HOST_COMMUNICATE_STATE_BULK_TRANS_OPERATION)
        {
            ScalerUsbU2HostDebugReg();
        }
        */
    }

    // Set may from other case (Non-Reply from Device)
    if(GET_U2HOST_COMPLETE_STATUS() == _TRUE)
    {
        CLR_U2HOST_COMPLETE_STATUS();

        switch(GET_U2HOST_COMMUNICATE_STATE())
        {
            case _U2HOST_COMMUNICATE_STATE_ENUMERATION:

                ScalerUsbU2HostEnumDataHandler(enumOwner);

                break;

#if(_USB2_HOST_EHCI_SUPPORT == _ON)
            case _U2HOST_COMMUNICATE_STATE_BULK_TRANS_OPERATION:

                SysUsbU2HostBulkTransOperationDataHandler(enumOwner);

                break;
#endif

#if(_USB2_HOST_OHCI_SUPPORT == _ON)
            case _U2HOST_COMMUNICATE_STATE_INT_TRANS_OPERATION:

                ScalerUsbU2HostIntTransOperationDataHandler();

                break;
#endif

#if(_USB2_HOST_OHCI_COLOR_ANALYZER_SUPPORT == _ON)
            case _U2HOST_COMMUNICATE_STATE_COLOR_ANALYZER_OPERATION:

                SysUsbU2HostColorOperationDataHandler();

                break;
#endif
            default:

                break;
        }
    }
}

//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host Work on communication
// Input Value  : None
// Output Value : BYTE
//----------------------------------------------------------------------------------------------------
BYTE SysUsbU2HostWorkOnCommunication(void)
{
    if(GET_U2HOST_ENUM_STATE() != _U2HOST_ENUM_STATE_NONE)
    {
        return _TRUE;
    }

#if(_USB2_HOST_EHCI_SUPPORT == _ON)
    if(GET_U2HOST_BULK_SCSI_STATE() != _U2HOST_BULK_SCSI_NONE)
    {
        return _TRUE;
    }
#endif

#if(_USB2_HOST_OHCI_SUPPORT == _ON)
    if(GET_U2HOST_COMMUNICATE_STATE() == _U2HOST_COMMUNICATE_STATE_INT_TRANS_OPERATION)
    {
        return _TRUE;
    }
#endif

    return _FALSE;
}

//----------------------------------------------------------------------------------------------------
// Description  : USB2.0 Host Reconnect
// Input Value  : None
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostReconnect(void)
{
    ScalerUsbU2HostPowerControl(_U2HOST_OWNER_EHCI, _OFF);
    SysUsbU2HostAcOnInitial();
    ScalerTimerDelayXms(20);
    ScalerUsbU2HostPowerControl(_U2HOST_OWNER_EHCI, _ON);
}

#if(_USB2_HOST_OHCI_COLOR_ANALYZER_SUPPORT == _ON)
//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host Color Analyzer Operation Data Handler
// Input Value  : None
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostColorOperationDataHandler(void)
{
    BYTE ucColorState = GET_U2HOST_COLOR_STATE();

    if(GET_U2HOST_TRANSFER_STATUS() == _TRUE)
    {
        // Check if ColorState in No-Reply State
        if(ucColorState <= _U2HOST_COLOR_IDLE)
        {
            // Command Completed
            CLR_U2HOST_TRANSFER_STATUS();
        }
        else if((ucColorState == _U2HOST_COLOR_CONTROL_OUT) || (ucColorState == _U2HOST_COLOR_CONTROL_IN))
        {
            // Check if previous action encountered an Error
            if(ScalerUsbU2HostChkCtrlQueueErrSts(_U2HOST_OWNER_OHCI) == _TRUE)
            {
                DebugMessageU2HostOHCI("[OHCI][Err] Color Control transfer Err", GET_U2HOST_COLOR_STATE());
                return;
            }
            // Check if previous action is completed
            else if(ScalerUsbU2HostChkCtrlQueueComplete(_U2HOST_OWNER_OHCI) == _TRUE)
            {
                CLR_U2HOST_TRANSFER_STATUS();
            }
            else
            {
                return;
            }
        }
        else if((ucColorState == _U2HOST_COLOR_BULK_OUT) || (ucColorState == _U2HOST_COLOR_BULK_IN))
        {
            // Check if previous action encountered an Error
            if(ScalerUsbU2HostChkBulkQueueErrSts(_U2HOST_OWNER_OHCI) == _TRUE)
            {
                DebugMessageU2HostOHCI("[OHCI][Err] Color Bulk transfer Err", GET_U2HOST_COLOR_STATE());
                return;
            }
            // Check if previous action is completed
            else if(ScalerUsbU2HostChkBulkQueueComplete(_U2HOST_OWNER_OHCI) == _TRUE)
            {
                CLR_U2HOST_TRANSFER_STATUS();
            }
            else
            {
                return;
            }
        }
        else if((ucColorState == _U2HOST_COLOR_INT_OUT) || (ucColorState == _U2HOST_COLOR_INT_IN))
        {
            // Check if previous action encountered an Error
            if(ScalerUsbU2HostChkIntQueueErrSts(_U2HOST_OWNER_OHCI, 0x00) == _TRUE)
            {
                DebugMessageU2HostOHCI("[OHCI][Err] Color Int transfer Err", GET_U2HOST_COLOR_STATE());
                return;
            }
            // Check if previous action is completed
            else if(ScalerUsbU2HostChkIntQueueComplete(_U2HOST_OWNER_OHCI, 0x00) == _TRUE)
            {
                CLR_U2HOST_TRANSFER_STATUS();
            }
            else
            {
                return;
            }
        }
    }
    else
    {
        return;
    }

    switch(GET_U2HOST_COLOR_STATE())
    {
        case _U2HOST_COLOR_ADD_BULK_ED:

            SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_IDLE);
            DebugMessageU2HostOHCI("[OHCI][COLOR STATE] ADD_BULK_ED -> IDLE", 0);

            break;

        case _U2HOST_COLOR_ADD_INT_ED:

            SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_IDLE);
            DebugMessageU2HostOHCI("[OHCI][COLOR STATE] ADD_INT_ED -> IDLE", 0);

            break;

        case _U2HOST_COLOR_IDLE:

            switch(GET_U2HOST_COLOR_REQ_STATUS())
            {
                case _U2HOST_COLOR_REQ_CONTROL_OUT:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_CONTROL_OUT);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> CONTROL_OUT", 0);

                    break;

                case _U2HOST_COLOR_REQ_CONTROL_IN:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_CONTROL_IN);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> CONTROL_IN", 0);

                    break;

                case _U2HOST_COLOR_REQ_BULK_INITIAL:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_ADD_BULK_ED);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> ADD_BULK_ED", 0);

                    break;

                case _U2HOST_COLOR_REQ_BULK_OUT:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_BULK_OUT);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> BULK_OUT", 0);

                    break;

                case _U2HOST_COLOR_REQ_BULK_IN:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_BULK_IN);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> BULK_IN", 0);

                    break;

                case _U2HOST_COLOR_REQ_INT_INITIAL:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_ADD_INT_ED);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> ADD_INT_ED", 0);

                    break;

                case _U2HOST_COLOR_REQ_INT_OUT:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_INT_OUT);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> INT_OUT", 0);

                    break;

                case _U2HOST_COLOR_REQ_INT_IN:

                    CLR_U2HOST_COLOR_REQ_STATUS();

                    SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_INT_IN);
                    DebugMessageU2HostOHCI("[OHCI][COLOR STATE] IDLE -> INT_IN", 0);

                    break;

                default:
                    break;
            }

            break;

        case _U2HOST_COLOR_BULK_OUT:

            SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_IDLE);
            DebugMessageU2HostOHCI("[OHCI][COLOR STATE] BULK_OUT -> IDLE", 0);

            break;

        case _U2HOST_COLOR_BULK_IN:

            // The BulkIn Data will be read to Color FW directly from BulkIn Buffer (to avoid waste of global variable)

            SET_U2HOST_COLOR_RSP_STATUS(_U2HOST_COLOR_RSP_BULK_IN);

            SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_IDLE);
            DebugMessageU2HostOHCI("[OHCI][COLOR STATE] BULK_IN -> IDLE", 0);

            break;

        case _U2HOST_COLOR_INT_OUT:

            SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_IDLE);
            DebugMessageU2HostOHCI("[OHCI][COLOR STATE] INT_OUT -> IDLE", 0);

            break;

        case _U2HOST_COLOR_INT_IN:

            // The IntIn Data will be read to Color FW directly from BulkIn Buffer (to avoid waste of global variable)

            SET_U2HOST_COLOR_RSP_STATUS(_U2HOST_COLOR_RSP_INT_IN);

            SET_U2HOST_COLOR_STATE(_U2HOST_COLOR_IDLE);
            DebugMessageU2HostOHCI("[OHCI][COLOR STATE] INT_IN -> IDLE", 0);

            break;

        default:

            break;
    }
}
#endif

#if(_USB2_HOST_EHCI_SUPPORT == _ON)
//----------------------------------------------------------------------------------------------------
// Description  : USB Bulk Function Operation Data Handler
// Input Value  : None
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostBulkTransOperationDataHandler(EnumUsbU2HostOwner enumOwner)
{
    BYTE puc512BTmp[512] = {0};
    BYTE pucUsbU2HostCswInfo[_U2HOST_BULK_CSW_EHCI_BUFFER_SIZE] = {0};

    WORD usUsbU2HostOffsetInFat1 = 0;
    DWORD ulFileLastClusValue = 0;
    DWORD ulUsbU2HostNextClusLBA = 0;
    DWORD ulUsbU2HostFileLastLBA = 0;
    BYTE ucCurPtnNum = 0;
    BYTE ucLoopI = 0;
    BYTE ucLoopJ = 0;
    bit bTargetFound = _FALSE;

#if(_USB2_HOST_FILE_SYSTEM_NTFS_SUPPORT == _ON)
    WORD usOffsetToNext = 0;
    WORD usLenTmp = 0;
    WORD usCurOffset = 0;
#endif

#if((_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON) && (_USB2_HOST_EHCI_FW_PROGRAM_FW_VERSION_CHECK == _ON) && (_CUSTOMER_FW_VERSION_SUPPORT == _ON))
    BYTE pucUsbU2HostFWVersion[2] = {0xFF};
#endif

    ucLoopJ = ucLoopJ;
    ulFileLastClusValue = ulFileLastClusValue;
    ulUsbU2HostFileLastLBA = ulUsbU2HostFileLastLBA;

    // Check Bulk Transfer Process Data Finish or Not.
    if(GET_U2HOST_TRANSFER_STATUS() == _TRUE)
    {
        if(ScalerUsbU2HostChkBulkQueueErrSts(enumOwner) == _TRUE)
        {
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
            DebugMessageU2Host("[Err] Bulk transfer Err", GET_U2HOST_FLOW_RESET());
#endif
            // DebugMessageU2Host("[data] Get Cur State", GET_U2HOST_BULK_SCSI_STATE());
            return;
        }
        else if(ScalerUsbU2HostChkBulkQueueComplete(enumOwner) == _TRUE)
        {
            CLR_U2HOST_TRANSFER_STATUS();

            // DebugMessageU2Host("[Data] Bulk transfer Complete", 0);

            if((GET_U2HOST_BULK_SCSI_STATE() & (_BIT7 | _BIT6 | _BIT5)) != 0x00)   // Need Spec Defined Command that is not defined by yourself
            {
                ScalerUsbU2HostScheduleEnable(_U2HOST_SCHEDULE_ASYNC, _DISABLE);
                // DebugMessageU2Host("[DATA] EHCI Async Schedule Disable", 0);
            }
        }
        else
        {
            DebugMessageU2Host("[U2 Host] No Data, Wait OSD", 0);
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _OFF)
            return;
#endif
        }
    }
    else
    {
        DebugMessageU2Host("[DATA] Transfer Status False", 0);
        return;
    }

    // Check CSW Status for Bulk IN QH (csw is 1st IN Qtd for Bluk Write(cbw-data out-csw), csw is 2nd IN Qtd for Bulk Read(cbw-data in-csw))
    if((((GET_U2HOST_BULK_SCSI_STATE() & (_BIT7 | _BIT6 | _BIT5)) == 0x40) && (GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _TRUE)) ||
       ((GET_U2HOST_BULK_SCSI_STATE() & (_BIT7 | _BIT6 | _BIT5)) == 0xC0) ||
       (GET_U2HOST_BULK_SCSI_STATE() == _U2HOST_BULK_SCSI_TEST_UNIT_READY_IN_QH)) // TEST_UNIT_READY_IN_QH Only have 1 IN Qtd(csw), 1ST_QTD_PROCESS_FLAG() = _FALSE
    {
        // DebugMessageU2Host("[DATA] Bulk Buffer ARER", 0);
        // ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, 0x00, pucUsbU2HostCswInfo, 0x20);

        // DebugMessageU2Host("[DATA] CSW ARER", 0);
        ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_CSW_BUFFER_ST_ADDR, 0x00, pucUsbU2HostCswInfo, 0x20); // receive 13Byte

        if(ScalerUsbU2HostBulkCheckCswStatus(pucUsbU2HostCswInfo) == _FALSE)
        {
            DebugMessageU2Host("CSW Abnormal", 0);
            ScalerUsbU2HostBulkCswErrResetRecovery();
            return;
        }
        else
        {
            // DebugMessageU2Host("CSW OK", 0);
        }
    }

    // Get Data From EHCI Buffer or Do sth(ex.switch state). By Different Bulk State.
    switch(GET_U2HOST_BULK_SCSI_STATE())
    {
        case _U2HOST_ADD_BULK_READ_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_IDLE);
            DebugMessageU2Host("[BULK STATE]  ADD_BULK_READ_QH -> IDLE", 0);

            break;

        case _U2HOST_IDLE:

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
            if(GET_U2HOST_BULK_READ_ENABLE() == _ENABLE)
#endif
            {
                DebugMessageU2Host("[U2 Host] Bulk Read Start", 0xFF);
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_INQUIRY_OUT_QH);
                DebugMessageU2Host("[BULK STATE]  IDLE -> INQUIRY_OUT", 0);
            }

            break;

        case _U2HOST_BULK_SCSI_INQUIRY_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_INQUIRY_IN_QH);
            DebugMessageU2Host("[BULK STATE]  INQUIRY_OUT -> INQUIRY_IN1", 0);

            break;

        case _U2HOST_BULK_SCSI_INQUIRY_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_INQUIRY_IN_QH);
                DebugMessageU2Host("[BULK STATE] INQUIRY_IN1 -> INQUIRY_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ_FORMAT_CAP_OUT_QH);
                DebugMessageU2Host("[BULK STATE] INQUIRY_IN2 -> FORMAT_CAP_OUT", 0);
            }

            break;

        case _U2HOST_BULK_SCSI_READ_FORMAT_CAP_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ_FORMAT_CAP_IN_QH);
            DebugMessageU2Host("[BULK STATE] FORMAT_CAP_OUT -> FORMAT_CAP_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ_FORMAT_CAP_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ_FORMAT_CAP_IN_QH);
                DebugMessageU2Host("[BULK STATE] FORMAT_CAP_IN1 -> FORMAT_CAP_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                // SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_MODE_SENSE6_OUT_QH);
                // DebugMessageU2Host("[BULK STATE] READ_CAPACITY10_IN2 -> MODE_SENSE6_OUT_QH", 0);

                if((g_ucUsbU2HostScsiFlowFlag & _BIT0) == 0) // 1st Time
                {
                    g_ucUsbU2HostScsiFlowFlag |= _BIT0;
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_REQ_SENSE_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] FORMAT_CAP_IN2 -> REQ_SENSE_OUT_QH", 0);
                }
                else // Second Time
                {
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ_CAPACITY10_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] FORMAT_CAP_IN2 -> READ_CAPACITY10_OUT", 0);
                }
            }

            break;

        case _U2HOST_BULK_SCSI_REQ_SENSE_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_REQ_SENSE_IN_QH);
            // DebugMessageU2Host("[BULK STATE] MODE_SENSE6_OUT -> MODE_SENSE6_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_REQ_SENSE_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_REQ_SENSE_IN_QH);
                DebugMessageU2Host("[BULK STATE] REQ_SENSE_IN1 -> REQ_SENSE_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                // SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_MODE_SENSE6_OUT_QH);
                // DebugMessageU2Host("[BULK STATE] READ_CAPACITY10_IN2 -> MODE_SENSE6_OUT", 0);

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ_FORMAT_CAP_OUT_QH);
                DebugMessageU2Host("[BULK STATE] REQ_SENSE_IN2 -> FORMAT_CAP_OUT", 0);

                if((g_ucUsbU2HostScsiFlowFlag & _BIT7) == _BIT7) // BIT7 DBR state Has done once
                {
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] REQ_SENSE_IN2 -> DBR_OUT", 0);
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ_CAPACITY10_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ_CAPACITY10_IN_QH);
            break;

        case _U2HOST_BULK_SCSI_READ_CAPACITY10_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ_CAPACITY10_IN_QH);
                DebugMessageU2Host("[BULK STATE] READ_CAPACITY10_IN1 -> READ_CAPACITY10_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                // SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_MODE_SENSE6_OUT_QH);
                // DebugMessageU2Host("[BULK STATE] READ_CAPACITY10_IN2 -> MODE_SENSE6_OUT_QH", 0);

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_TEST_UNIT_READY_OUT_QH);
                DebugMessageU2Host("[BULK STATE] READ_CAPACITY10_IN2 -> TEST_UNIT_OUT", 0);
            }

            break;

        case _U2HOST_BULK_SCSI_MODE_SENSE6_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_MODE_SENSE6_IN_QH);
            DebugMessageU2Host("[BULK STATE] MODE_SENSE6_OUT -> MODE_SENSE6_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_MODE_SENSE6_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_MODE_SENSE6_IN_QH);
                DebugMessageU2Host("[BULK STATE] MODE_SENSE6_IN1 -> MODE_SENSE6_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_TEST_UNIT_READY_OUT_QH);
                DebugMessageU2Host("[BULK STATE] MODE_SENSE6_IN2 -> TEST_UNIT_OUT", 0);
            }
            break;

        case _U2HOST_BULK_SCSI_TEST_UNIT_READY_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_TEST_UNIT_READY_IN_QH);
            // DebugMessageU2Host("[BULK STATE] TEST_UNIT_OUT -> TEST_UNIT_IN2", 0);
            break;

        case _U2HOST_BULK_SCSI_TEST_UNIT_READY_IN_QH:

            // Test unit IN State has only 1 csw state
            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
            // DebugMessageU2Host("[BULK STATE] TEST_UNIT_IN2 -> MBR_OUT", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_MBR_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_IN_QH);
            // DebugMessageU2Host("[BULK STATE] MBR_OUT -> MBR_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_MBR_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_IN_QH);
                // DebugMessageU2Host("[BULK STATE] MBR_IN1 -> MBR_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, 0x00, puc512BTmp, 0x01);

                // Check if MBR exist
                if((puc512BTmp[0] == 0xEB) || (puc512BTmp[0] == 0xE9))
                {
                    // DBR Start LBA = 0 since MBR does not exist
                    g_pstUsbFileSysMbrPartitionEntry[0].ulDbrStartLBA = 0x00;
                    DebugMessageU2Host("[FAT32] MBR doesn't exist (should be only 1 Partition), DBRStartLBA = 0", puc512BTmp[0]);

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] MBR_IN2 -> DBR_OUT", 0);
                }
                else
                {
                    // MBR Sanity Check with End Signature
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, _U2HOST_FILE_SYS_MBR_DBR_END_OFFSET_ADDR, puc512BTmp, 0x02);
                    if((puc512BTmp[0] != 0x55) || (puc512BTmp[1] != 0xAA))
                    {
                        DebugMessageU2Host("[FAT32] Warning: MBR Sanity Check Fail ! (MBR end != 0x55AA)", TO_WORD(puc512BTmp[0], puc512BTmp[1]));
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                        DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_IN2 -> NONE", 0);
                    }
                    else
                    {
                        // Store Partition Entry info.
                        ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, _U2HOST_FILE_SYS_MBR_PTN_ENTRY_OFFSET_ADDR, puc512BTmp, (4 * _U2HOST_FILE_SYS_MBR_PTN_ENTRY_SIZE));
                        ScalerUsbFileSysGetMbrEntry(puc512BTmp);

                        // Check if the MBR is a Protective-MBR
                        if((g_pstUsbFileSysMbrPartitionEntry[0].ucSystemID) == 0xEE)
                        {
                            DebugMessageU2Host("[FAT32][System Type] GPT w/ Protective MBR", g_pstUsbFileSysMbrPartitionEntry[ucCurPtnNum].ucSystemID);
                            // Set LBA to GPT Header Address (the ulDbrStartLBA field in 1st PartitionEntry of P-MBR)
                            SET_U2HOST_CUR_LBA(g_pstUsbFileSysMbrPartitionEntry[ucCurPtnNum].ulDbrStartLBA);

                            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_GPT_HDR_OUT_QH);
                            DebugMessageU2Host("[BULK STATE] MBR_IN2 -> GPT_HDR_OUT", 0);
                        }
                        // Normal MBR
                        else
                        {
                            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_JUDGE_PARTITION_ID);
                            DebugMessageU2Host("[BULK STATE] MBR_IN2 -> JUDGE_PARTITION_ID", 0);
                        }
                    }
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_GPT_HDR_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_GPT_HDR_IN_QH);
            // DebugMessageU2Host("[BULK STATE] GPT_HDR_OUT -> GPT_HDR_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_GPT_HDR_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_GPT_HDR_IN_QH);
                // DebugMessageU2Host("[BULK STATE] GPT_HDR_IN1 -> GPT_HDR_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, _U2HOST_FILE_SYS_GPT_HEADER_OFFSET_ADDR, puc512BTmp, _U2HOST_FILE_SYS_GPT_ENTRY_SIZE);

                ScalerUsbFileSysGetGptHeader(puc512BTmp);

                if((g_stUsbFileSysGptHeader.ulSignatureH != 0x54524150) || (g_stUsbFileSysGptHeader.ulSignatureL != 0x20494645))
                {
                    DebugMessageU2Host("[FAT32] Warning: GPT Header Sanity Check Fail !", 0);
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                    DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_IN2 -> NONE", 0);
                }
                else
                {
                    // Update Current LBA to get GPT Partition Entry
                    SET_U2HOST_CUR_LBA(g_stUsbFileSysGptHeader.ulGptEntryStartLBA);

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_GPT_ENT_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] GPT_HDR_IN2 -> GPT_ENT_OUT", 0);
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_GPT_ENT_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_GPT_ENT_IN_QH);
            // DebugMessageU2Host("[BULK STATE] GPT_ENT_OUT -> GPT_ENT_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_GPT_ENT_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_GPT_ENT_IN_QH);
                // DebugMessageU2Host("[BULK STATE] GPT_ENT_IN1 -> GPT_ENT_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, 0x00, puc512BTmp, (4 * _U2HOST_FILE_SYS_GPT_ENTRY_SIZE));

                ScalerUsbFileSysGetGptEntry(puc512BTmp);

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_JUDGE_PARTITION_ID);
                DebugMessageU2Host("[BULK STATE] GPT_ENT_IN2 -> JUDGE_PARTITION_ID", 0);
            }

            break;

        case _U2HOST_JUDGE_PARTITION_ID:

            ucCurPtnNum = GET_U2HOST_CUR_PARTITION_NUM();

            // Check if Protective-MBR do not exist
            if((g_pstUsbFileSysMbrPartitionEntry[0].ucSystemID) == 0xEE)
            {
                // Set LBA to the 1st LBA Address of Current Partition
                SET_U2HOST_CUR_LBA(g_pstUsbFileSysGptEntry[ucCurPtnNum].ulDbrStartLBA);

                switch(g_pstUsbFileSysGptEntry[ucCurPtnNum].ulPartitionTypeLL)
                {
                    case 0x00:

                        DebugMessageU2Host("[FileSys][GPT] Empty Entry (Last Entry)", ucCurPtnNum);
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> NONE", 0);

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                        // Set Event Status to User
                        SET_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT, _U2HOST_EVENT_FAIL);
                        SET_U2HOST_FLOW_RESET();

                        DebugMessageU2Host("[FileSys][GPT] Target FileName Not Found in all exist Partition !", ucCurPtnNum);
#endif
                        break;

                    case 0xEBD0A0A2:

                        // The GUID of Basic Data Partition is EBD0A0A2-B9E5-4433-87C0-68B6B72699C7, here we only check the LL 8 byte
                        DebugMessageU2Host("[FileSys][GPT] Basic Data Partition", ucCurPtnNum);

                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> DBR_OUT", 0);

                        break;

                    default:

                        DebugMessageU2Host("[FileSys][GPT] Warning: System Type not supported !", g_pstUsbFileSysGptEntry[ucCurPtnNum].ulPartitionTypeLL);
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> CUR_PARTITION_ABORT", 0);

                        break;
                }
            }
            else
            {
                // Set LBA to the 1st LBA Address of Current Partition
                SET_U2HOST_CUR_LBA(g_pstUsbFileSysMbrPartitionEntry[ucCurPtnNum].ulDbrStartLBA);

                switch(g_pstUsbFileSysMbrPartitionEntry[ucCurPtnNum].ucSystemID)
                {
                    case 0x00:

                        DebugMessageU2Host("[FileSys][MBR] Empty Entry (Last Entry)", ucCurPtnNum);
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> NONE", 0);

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                        // Set Event Status to User
                        SET_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT, _U2HOST_EVENT_FAIL);
                        SET_U2HOST_FLOW_RESET();

                        DebugMessageU2Host("[FileSys][MBR] Target FileName Not Found in all exist Partition !", ucCurPtnNum);
#endif
                        break;

                    case 0x07:

                        DebugMessageU2Host("[FileSys][MBR] NTFS / exFAT / IFS / HPFS", ucCurPtnNum);
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> DBR_OUT", 0);

                        break;

                    case 0x0B:

                        DebugMessageU2Host("[FileSys][MBR] Microsoft basic FAT32 (w/ CHS)", ucCurPtnNum);
                        SET_U2HOST_CUR_PARTITION_TYPE(_USB_FILE_SYS_FAT32);

                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> DBR_OUT", 0);

                        break;

                    case 0x0C:

                        DebugMessageU2Host("[FileSys][MBR] Microsoft FAT32 w/ LBA ", ucCurPtnNum);
                        SET_U2HOST_CUR_PARTITION_TYPE(_USB_FILE_SYS_FAT32);

                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> DBR_OUT", 0);

                        break;

                    default:

                        if(g_pstUsbFileSysMbrPartitionEntry[ucCurPtnNum].ucSystemID == 0x0F)
                        {
                            DebugMessageU2Host("[FileSys][MBR] Extended Partition w/ LBA ", ucCurPtnNum);
                        }

                        DebugMessageU2Host("[FileSys][MBR] Warning: System Type not supported !", g_pstUsbFileSysMbrPartitionEntry[ucCurPtnNum].ucSystemID);
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                        DebugMessageU2Host("[BULK STATE] JUDGE_PARTITION_ID -> CUR_PARTITION_ABORT", 0);

                        break;
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_DBR_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_IN_QH);
            // DebugMessageU2Host("[BULK STATE] DBR_OUT -> DBR_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_DBR_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_DBR_IN_QH);
                // DebugMessageU2Host("[BULK STATE] DBR_IN1 -> DBR_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                // Sanity Check with End Signature
                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, _U2HOST_FILE_SYS_MBR_DBR_END_OFFSET_ADDR, puc512BTmp, 0x02);
                if((puc512BTmp[0] != 0x55) || (puc512BTmp[1] != 0xAA))
                {
                    DebugMessageU2Host("[FileSys][DBR] Warning: DBR Sanity Check Fail ! (DBR end != 0x55AA)", TO_WORD(puc512BTmp[0], puc512BTmp[1]));
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                    DebugMessageU2Host("[BULK STATE] DBR_IN2 -> CUR_PARTITION_ABORT", 0);
                }
                else
                {
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, _U2HOST_FILE_SYS_DBR_TABLE_OFFSET_ADDR, puc512BTmp, _U2HOST_FILE_SYS_DBR_TABLE_SIZE);

                    // Get OEMName from DBR
                    g_stUsbFileSysDbrTable.uqOEMName = TO_QWORD(TO_DWORD(puc512BTmp[10], puc512BTmp[9], puc512BTmp[8], puc512BTmp[7]),
                                                                TO_DWORD(puc512BTmp[6], puc512BTmp[5], puc512BTmp[4], puc512BTmp[3]));

#if(_USB2_HOST_FILE_SYSTEM_NTFS_SUPPORT == _ON)
                    // Check System Type by OEMName == "NTFS"
                    if((g_stUsbFileSysDbrTable.uqOEMName & 0xFFFFFFFF) == 0x5346544E)
                    {
                        SET_U2HOST_CUR_PARTITION_TYPE(_USB_FILE_SYS_NTFS);
                    }
#endif
#if(_USB2_HOST_FILE_SYSTEM_EXFAT_SUPPORT == _ON)
                    // Check System Type by OEMName == "EXFAT"
                    else if((g_stUsbFileSysDbrTable.uqOEMName & 0xFFFFFFFFFF) == 0x5441465845)
                    {
                        SET_U2HOST_CUR_PARTITION_TYPE(_USB_FILE_SYS_EXFAT);
                    }
#endif
                    if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_NONE)
                    {
                        // Since not all FAT32 FileSys set the OEMName in DBR, default set to FAT32
                        DebugMessageU2Host("[FileSys][DBR] Warning: System Type uncertain, set to FAT32", 0);
                        SET_U2HOST_CUR_PARTITION_TYPE(_USB_FILE_SYS_FAT32);
                    }
                    // Store DBR info.
                    ScalerUsbFileSysGetDbrTable(puc512BTmp, GET_U2HOST_CUR_PARTITION_TYPE());

                    ucCurPtnNum = GET_U2HOST_CUR_PARTITION_NUM();

                    switch(GET_U2HOST_CUR_PARTITION_TYPE())
                    {
                        case _USB_FILE_SYS_FAT32:

                            // Calculate the FAT32/EXFAT related info. and judge if supported
                            if(ScalerUsbFileSysFatCalInfo(ucCurPtnNum) == _TRUE)
                            {
                                // Update Current LBA to get first Cluster Num. occupied by Directory
                                SET_U2HOST_CUR_LBA(ScalerUsbFileSysFatGetFAT1ClusNumLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0]));
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_OUT_QH);
                                DebugMessageU2Host("[BULK STATE] DBR_IN2 -> FAT_DIR_CLUS_NUM_OUT", 0);
                            }
                            else
                            {
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                                DebugMessageU2Host("[BULK STATE] DBR_IN2 -> CUR_PARTITION_ABORT", 0);
                            }

                            break;

#if(_USB2_HOST_FILE_SYSTEM_EXFAT_SUPPORT == _ON)
                        case _USB_FILE_SYS_EXFAT:

                            // The ExFAT action here is identical with FAT32

                            // Calculate the FAT32/EXFAT related info. and judge if supported
                            if(ScalerUsbFileSysFatCalInfo(ucCurPtnNum) == _TRUE)
                            {
                                // Update Current LBA to get first Cluster Num. occupied by Directory
                                SET_U2HOST_CUR_LBA(ScalerUsbFileSysFatGetFAT1ClusNumLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0]));
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_OUT_QH);
                                DebugMessageU2Host("[BULK STATE] DBR_IN2 -> FAT_DIR_CLUS_NUM_OUT", 0);
                            }
                            else
                            {
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                                DebugMessageU2Host("[BULK STATE] DBR_IN2 -> CUR_PARTITION_ABORT", 0);
                            }

                            break;
#endif
#if(_USB2_HOST_FILE_SYSTEM_NTFS_SUPPORT == _ON)
                        case _USB_FILE_SYS_NTFS:

                            // Calculate the NTFS related info. and judge if supported
                            if(ScalerUsbFileSysNtfsCalInfo(ucCurPtnNum) == _TRUE)
                            {
                                // Update Current LBA to get the MFT Record of $Root
                                SET_U2HOST_CUR_LBA(g_stUsbFileSysNtfsInfo.ulNtfsRootEntryLBA);

                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_ROOT_ENTRY_OUT_QH);
                                DebugMessageU2Host("[BULK STATE] DBR_IN2 -> NTFS_ROOT_ENTRY_OUT", 0);
                            }
                            else
                            {
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                                DebugMessageU2Host("[BULK STATE] DBR_IN2 -> CUR_PARTITION_ABORT", 0);
                            }

                            break;
#endif
                        default:

                            DebugMessageU2Host("[FileSys][DBR] Warning: System Type not supported !", g_pstUsbFileSysMbrPartitionEntry[ucCurPtnNum].ucSystemID);
                            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                            DebugMessageU2Host("[BULK STATE] DBR_IN2 -> CUR_PARTITION_ABORT", 0);

                            break;
                    }
                }
            }
            break;

#if(_USB2_HOST_FILE_SYSTEM_NTFS_SUPPORT == _ON)
        case _U2HOST_BULK_SCSI_READ10_NTFS_ROOT_ENTRY_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_ROOT_ENTRY_IN_QH);
            // DebugMessageU2Host("[BULK STATE] NTFS_ROOT_ENTRY_OUT -> NTFS_ROOT_ENTRY_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_NTFS_ROOT_ENTRY_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_ROOT_ENTRY_IN_QH);
                // DebugMessageU2Host("[BULK STATE] NTFS_ROOT_ENTRY_IN1 -> NTFS_ROOT_ENTRY_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, 0, puc512BTmp, 512);
                ScalerUsbFileSysNtfsParseMftHdr(puc512BTmp);

                // Get to the offset of Index Root Attribute (0x90)
                // Notice! The puc512BTmp content will be changed in ScalerUsbFileSysNtfsSrchMftAttr()
                usOffsetToNext = ScalerUsbFileSysNtfsSrchMftAttr(puc512BTmp, 0x90);

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, usOffsetToNext, puc512BTmp, 512);

                if(usOffsetToNext < 512)
                {
                    ScalerUsbFileSysNtfsFixUpArray(puc512BTmp, 0, usOffsetToNext);
                }
                else
                {
                    ScalerUsbFileSysNtfsFixUpArray(puc512BTmp, 1, (usOffsetToNext - 512));
                }

                usLenTmp = TO_DWORD(puc512BTmp[0x07], puc512BTmp[0x06], puc512BTmp[0x05], puc512BTmp[0x04]);

                // Parse Index Root Attribute (0x90)
                if(ScalerUsbFileSysNtfsParseIdxRootAttr(puc512BTmp) == _TRUE)
                {
                    // Parse Index Root Allocation (0xA0)
                    ScalerUsbFileSysNtfsParseIdxAllocAttr(&puc512BTmp[usLenTmp]);

                    // Update Current LBA to get the 1st Index Buffer
                    g_stUsbFileSysNtfsInfo.usCurRootAllocClusIdx = 0;
                    g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord = 0;
                    g_stUsbFileSysNtfsInfo.ucCurSecInClus = 0;
                    g_stUsbFileSysNtfsInfo.ulCurClusNum = ScalerUsbFileSysNtfsParseDataRun(g_stUsbFileSysNtfsInfo.pucCurDataRun, g_stUsbFileSysNtfsInfo.usCurRootAllocClusIdx);
                    SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysNtfsInfo.ulCurClusNum));

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_IDX_RECORD_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] NTFS_ROOT_ENTRY_IN2 -> NTFS_IDX_RECORD_OUT", 0);
                }
                else
                {
                    DebugMessageU2Host("[FileSys][NTFS] Index Allocation Attribute (0xA0) doesn't exist", usOffsetToNext + usLenTmp);
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_NTFS_IDX_RECORD_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_IDX_RECORD_IN_QH);
            // DebugMessageU2Host("[BULK STATE] NTFS_IDX_RECORD_OUT -> NTFS_IDX_RECORD_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_NTFS_IDX_RECORD_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_IDX_RECORD_IN_QH);
                // DebugMessageU2Host("[BULK STATE] NTFS_IDX_RECORD_IN1 -> NTFS_IDX_RECORD_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, 0x00, puc512BTmp, 512);

                // 1. Get the Offset for SrchFileName
                // First Sector in current Index Record
                if(g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord == 0)
                {
                    // Get Info. from Header of current Index Record
                    ScalerUsbFileSysNtfsParseIdxRecordHdr(puc512BTmp);
                    // Get Current Offset from Header
                    usCurOffset = g_stUsbFileSysNtfsInfo.usByteOffsetInIdxRecord;
                }
                else
                {
                    // Calculate the Offset in this sector (512 Byte)
                    usCurOffset = g_stUsbFileSysNtfsInfo.usByteOffsetInIdxRecord - (g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord * 512);
                }

                ScalerUsbFileSysNtfsFixUpArray(puc512BTmp, g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord, 0);

                // 2. Get the Len for SrchFileName
                // Last Sector in current Index Buffer
                if(((g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord + 1) * 512) > g_stUsbFileSysNtfsInfo.usCurIdxRecordLen)
                {
                    // Calculate the left data to be searched in current Cluster
                    usLenTmp = g_stUsbFileSysNtfsInfo.usCurIdxRecordLen % 512;
                }
                else
                {
                    usLenTmp = 512;
                }

                // 3. Search all Index Entries in current sector
                usCurOffset = ScalerUsbFileSysNtfsSrchFileName(puc512BTmp, usCurOffset, usLenTmp);

                // 4. Check & Search the Fragmented Index Entry
                if(usCurOffset != 0x00)
                {
                    // Get the the Fragmented Index Entry
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, usCurOffset, puc512BTmp, 512);
                    ScalerUsbFileSysNtfsFixUpArray(puc512BTmp, g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord, usCurOffset);

                    usLenTmp = TO_WORD(puc512BTmp[0x09], puc512BTmp[0x08]);

                    // Check if Target File Name matched the Fragmented Index Entry
                    ScalerUsbFileSysNtfsSrchFileName(puc512BTmp, 0x00, usLenTmp);
                    usCurOffset += usLenTmp;
                }

                // 5. Judge if next Cluster/IdxRecord in RootAlloc needed
                // Target File found in this Loop
                if(GET_U2HOST_SEARCH_NAME_STATUS() == _USB_FILE_SYS_SRCH_FINISH)
                {
                    SET_U2HOST_SEARCH_NAME_STATUS(_USB_FILE_SYS_SRCH_NAME_NONE);

                    DebugMessageU2Host("[FileSys][NTFS] Target FileName Found, ulFileMftNum =", g_stUsbFileSysNtfsInfo.ulFileMftNum);
                    SET_U2HOST_CUR_LBA(g_stUsbFileSysNtfsInfo.ulNtfsRootEntryLBA + g_stUsbFileSysNtfsInfo.ulSecPerMftRecord * (g_stUsbFileSysNtfsInfo.ulFileMftNum - 5));
                    DebugMessageU2Host("[BULK STATE] File mft lba", GET_U2HOST_CUR_LBA());

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                    SET_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT, _U2HOST_EVENT_PASS);
                    DebugMessageU2Host("[FileSys] Target File Name Found in Partition: ", GET_U2HOST_CUR_PARTITION_NUM());
#endif
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_FILE_ENTRY_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] NTFS_IDX_RECORD_IN2 -> NTFS_FILE_ENTRY_OUT", 0);
                }
                // Target File Not found in this Loop
                else
                {
                    // IdxRecordSize >= ClusterSize
                    if(g_stUsbFileSysNtfsInfo.ulSecPerIdxRecord >= g_stUsbFileSysDbrTable.ulSecPerClus)
                    {
                        // Current Cluster search done => Next Cluster
                        if(((DWORD)(g_stUsbFileSysNtfsInfo.ucCurSecInClus + 1)) == g_stUsbFileSysDbrTable.ulSecPerClus)
                        {
                            // Next Cluster in new IdxRecord
                            if((g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord + 1) == (BYTE)(g_stUsbFileSysNtfsInfo.ulSecPerIdxRecord))
                            {
                                // Reset the Current Sector in IdxRecord, since it will be a new IdxRecord next loop
                                g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord = 0;
                            }
                            // Next Cluster in same IdxRecord
                            else
                            {
                                g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord ++;
                                g_stUsbFileSysNtfsInfo.usByteOffsetInIdxRecord = ((g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord - 1) * 512) + usCurOffset;
                            }

                            // Get next Cluster in RootAlloc
                            g_stUsbFileSysNtfsInfo.usCurRootAllocClusIdx ++;
                            // Calculate the LBA of next Cluster
                            g_stUsbFileSysNtfsInfo.ulCurClusNum = ScalerUsbFileSysNtfsParseDataRun(g_stUsbFileSysNtfsInfo.pucCurDataRun, g_stUsbFileSysNtfsInfo.usCurRootAllocClusIdx);
                            // Reset the Current Sector in Cluster, since it will be a new Cluster next loop
                            g_stUsbFileSysNtfsInfo.ucCurSecInClus = 0;

                            // if next RootAlloc Cluster dosen't exist (all Index Record searched) -> target file not found
                            if(g_stUsbFileSysNtfsInfo.ulCurClusNum == 0x00)
                            {
                                SET_U2HOST_NTFS_FILE_NOT_FOUND();
                            }
                            SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysNtfsInfo.ulCurClusNum));
                        }
                        else
                        {
                            g_stUsbFileSysNtfsInfo.ucCurSecInClus ++;
                            g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord ++;
                            g_stUsbFileSysNtfsInfo.usByteOffsetInIdxRecord = ((g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord - 1) * 512) + usCurOffset;
                            SET_U2HOST_CUR_LBA(GET_U2HOST_CUR_LBA() + 1);
                        }
                    }
                    // IdxRecordSize < ClusterSize
                    else
                    {
                        // Current IdxRecord search done => Next IdxRecord
                        if((g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord + 1) == (BYTE)(g_stUsbFileSysNtfsInfo.ulSecPerIdxRecord))
                        {
                            // Reset the Current Sector in IdxRecord, since it will be a new IdxRecord next loop
                            g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord = 0;

                            // Next IdxRecord in new Cluster
                            if(((DWORD)(g_stUsbFileSysNtfsInfo.ucCurSecInClus + 1)) == g_stUsbFileSysDbrTable.ulSecPerClus)
                            {
                                // Get next Cluster in RootAlloc
                                g_stUsbFileSysNtfsInfo.usCurRootAllocClusIdx ++;
                                // Calculate the LBA of next Cluster
                                g_stUsbFileSysNtfsInfo.ulCurClusNum = ScalerUsbFileSysNtfsParseDataRun(g_stUsbFileSysNtfsInfo.pucCurDataRun, g_stUsbFileSysNtfsInfo.usCurRootAllocClusIdx);
                                // Reset the Current Sector in Cluster, since it will be a new Cluster next loop
                                g_stUsbFileSysNtfsInfo.ucCurSecInClus = 0;

                                // if next RootAlloc Cluster dosen't exist (all Index Record searched) -> target file not found
                                if(g_stUsbFileSysNtfsInfo.ulCurClusNum == 0x00)
                                {
                                    SET_U2HOST_NTFS_FILE_NOT_FOUND();
                                }
                                SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysNtfsInfo.ulCurClusNum));
                            }
                            // Next IdxRecord in same Cluster
                            else
                            {
                                g_stUsbFileSysNtfsInfo.ucCurSecInClus ++;
                                SET_U2HOST_CUR_LBA(GET_U2HOST_CUR_LBA() + 1);
                            }
                        }
                        // Next Sector in same IdxRecord
                        else
                        {
                            g_stUsbFileSysNtfsInfo.ucCurSecInClus ++;
                            g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord ++;
                            g_stUsbFileSysNtfsInfo.usByteOffsetInIdxRecord = ((g_stUsbFileSysNtfsInfo.ucCurSecInIdxRecord - 1) * 512) + usCurOffset;
                            SET_U2HOST_CUR_LBA(GET_U2HOST_CUR_LBA() + 1);
                        }
                    }

                    // Target File not found in Root Dir Node
                    if(GET_U2HOST_NTFS_FILE_NOT_FOUND() == _TRUE)
                    {
                        CLR_U2HOST_NTFS_FILE_NOT_FOUND();
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                        CLR_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT);
#endif
                        DebugMessageU2Host("[FileSys][NTFS] Target FileName Not Found in Current Partition !", 0);
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                        DebugMessageU2Host("[BULK STATE] NTFS_IDX_RECORD_IN2 -> CUR_PARTITION_ABORT", 0);
                    }
                    else
                    {
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_IDX_RECORD_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] NTFS_IDX_RECORD_IN2 -> NTFS_IDX_RECORD_OUT", 0);
                    }
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_NTFS_FILE_ENTRY_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_FILE_ENTRY_IN_QH);
            // DebugMessageU2Host("[BULK STATE] NTFS_FILE_ENTRY_OUT -> NTFS_FILE_ENTRY_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_NTFS_FILE_ENTRY_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_NTFS_FILE_ENTRY_IN_QH);
                // DebugMessageU2Host("[BULK STATE] NTFS_FILE_ENTRY_IN1 -> NTFS_FILE_ENTRY_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, 0, puc512BTmp, 512);
                ScalerUsbFileSysNtfsParseMftHdr(puc512BTmp);

                // Get to the offset of Data Attribute (0x80)
                // Notice! The puc512BTmp content will be changed in ScalerUsbFileSysNtfsSrchMftAttr()
                usOffsetToNext = ScalerUsbFileSysNtfsSrchMftAttr(puc512BTmp, 0x80);

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, usOffsetToNext, puc512BTmp, 512);

                if(usOffsetToNext < 512)
                {
                    ScalerUsbFileSysNtfsFixUpArray(puc512BTmp, 0, usOffsetToNext);
                }
                else
                {
                    ScalerUsbFileSysNtfsFixUpArray(puc512BTmp, 1, (usOffsetToNext - 512));
                }

                // Parse Data Attribute (0x80)
                ScalerUsbFileSysNtfsParseDataAttr(puc512BTmp);

                if((g_stUsbFileSysFileInfo.ulFileLastClusNum - g_stUsbFileSysFileInfo.ulFileStartClusNum + 1) != g_stUsbFileSysFileInfo.usFileSizeInClus)
                {
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                    DebugMessageU2Host("[BULK STATE] NTFS_FILE_ENTRY_IN2 -> CUR_PARTITION_ABORT, Cluster Discontinuous", g_stUsbFileSysFileInfo.ulFileLastClusNum);
                }
                else
                {
#if((_USB2_HOST_EHCI_FW_PROGRAM_FW_VERSION_CHECK == _ON) && (_CUSTOMER_FW_VERSION_SUPPORT == _ON))

                    SET_U2HOST_EVENT_STATUS(_U2HOST_FW_VERSION_CHECK_EVENT, _U2HOST_EVENT_ON_GOING);
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FW_VERSION_CHK_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> FW_VERSION_CHECK_OUT", 0);

                    // Set LBA to FW Version location at Bin file
                    SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetFileFwVersionLBA());
#else
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_WAIT_USER_OSD_ENABLE);
                    DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> WAIT_USER_OSD_ENABLE, FW Version Check Disable", 0);
                    DebugMessageU2Host("[U2 Host] Wait End-User choose OSD to Enable FW Update", 0);
#endif
                }
            }

            break;
#endif // End of #if(_USB2_HOST_FILE_SYSTEM_NTFS_SUPPORT == _ON)

        case _U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_OUT_QH: // Get all cluster numbers occupied by the root directory

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_IN_QH);
            // DebugMessageU2Host("[BULK STATE] FAT_DIR_CLUS_NUM_OUT -> FAT_DIR_CLUS_NUM_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_IN_QH);
                // DebugMessageU2Host("[BULK STATE] FAT_DIR_CLUS_NUM_IN1 -> FAT_DIR_CLUS_NUM_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                if((GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_EXFAT) && (GET_U2HOST_SRCH_FROM_DIR_TYPE() == _SRCH_FILE_FROM_1ST_SUB_DIR))
                {
                    if(g_stUsbFileSysFatInfo.b1stSubDirNoFatChain)
                    {
                        g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex = (g_stUsbFileSysFileInfo.usFileSizeInClus / g_stUsbFileSysDbrTable.ulSecPerClus);
                        for(ucLoopI = 1; ucLoopI < g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex; ucLoopI ++)
                        {
                            g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[ucLoopI] = g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[ucLoopI - 1] + 1;
                        }

                        // Update Cur LBA to Root/Sub 1st Cluster in order to search FileName in Dir Data
                        SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0]));

                        // Set start LBA to current Cluster
                        SET_U2HOST_CUR_CLUS_START_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0]));

                        g_stUsbFileSysFatInfo.ucCurEntryOffset = 0;
                        g_stUsbFileSysFatInfo.ucNxtEntrySetOffset = 0;

                        // Since this is the last Clus occupied by Root/Sub Dir In FAT1, switch to next state
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_SRCH_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] FAT_DIR_CLUS_NUM_IN2 -> FAT_DIR_SRCH_OUT", 0);

                        break;
                    }
                }

                // Calculate Current ClusNum offset in this FAT1 sector (offset unit: byte; 512 bytes in 1 sector).
                usUsbU2HostOffsetInFat1 = ((g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex] * 4) % g_stUsbFileSysDbrTable.usBytePerSec);
                DebugMessageU2Host("[FAT] Next Dir ClusNum Offset in FAT1", usUsbU2HostOffsetInFat1);

                // Update index for next ClusNum, store the ClusNum value to global array
                g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex ++;
                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, usUsbU2HostOffsetInFat1, (BYTE *)(&g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex]), 4);
                DebugMessageU2Host("[FAT] Next Dir ClusNum", g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex]);


                if(ScalerUsbFileSysFatChkEOC(GET_U2HOST_CUR_PARTITION_TYPE(), g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex]) == _TRUE)
                {
                    DebugMessageU2Host("[FAT] Total Dir Cluster NumCnt", g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex);
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                    SET_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT, _U2HOST_EVENT_ON_GOING);
#endif
                    // Update Cur LBA to Root/Sub 1st Cluster in order to search FileName in Dir Data
                    SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0]));

                    // Set start LBA to current Cluster
                    SET_U2HOST_CUR_CLUS_START_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0]));

                    g_stUsbFileSysFatInfo.ucCurEntryOffset = 0;
                    g_stUsbFileSysFatInfo.ucNxtEntrySetOffset = 0;

                    // Since this is the last Clus occupied by Root/Sub Dir In FAT1, switch to next state
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_SRCH_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] FAT_DIR_CLUS_NUM_IN2 -> FAT_DIR_SRCH_OUT", 0);
                }
                else
                {
                    // Update Current LBA to get next Cluster Num. occupied by Root/Sub Directory
                    SET_U2HOST_CUR_LBA(ScalerUsbFileSysFatGetFAT1ClusNumLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex]));
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] FAT_DIR_CLUS_NUM_IN2 -> FAT_DIR_CLUS_NUM_OUT", 0);
                }
            }
            break;

        case _U2HOST_BULK_SCSI_READ10_FAT_DIR_SRCH_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_SRCH_IN_QH);
            // DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_OUT -> FAT_DIR_SRCH_IN1", 0);
            break;

        case _U2HOST_BULK_SCSI_READ10_FAT_DIR_SRCH_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_SRCH_IN_QH);
                // DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_IN1 -> FAT_DIR_SRCH_IN2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                // 1. Find the specified File / Dir Entry
                for(ucLoopI = 0; ucLoopI < 2; ucLoopI++)
                {
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, (512 * ucLoopI), puc512BTmp, 512);

                    if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_FAT32)
                    {
                        // Since this is a new Loop (new Sector)
                        g_stUsbFileSysFatInfo.ucCurEntryOffset %= (512 / _U2HOST_FILE_SYS_FAT_ENTRY_SIZE);
                        bTargetFound = ScalerUsbFileSysFat32ParseFileEntry(GET_U2HOST_SRCH_FROM_DIR_TYPE(), puc512BTmp, &g_stUsbFileSysFatInfo.ucCurEntryOffset, &g_stUsbFileSysFatInfo.ucCurMatchEntryCnt, ucLoopI);
                    }
#if(_USB2_HOST_FILE_SYSTEM_EXFAT_SUPPORT == _ON)
                    else if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_EXFAT)
                    {
                        // Since this is a new Loop (new Sector)
                        g_stUsbFileSysFatInfo.ucCurEntryOffset %= (512 / _U2HOST_FILE_SYS_FAT_ENTRY_SIZE);
                        g_stUsbFileSysFatInfo.ucNxtEntrySetOffset %= (512 / _U2HOST_FILE_SYS_FAT_ENTRY_SIZE);

                        bTargetFound = ScalerUsbFileSysExfatParseFileEntry(GET_U2HOST_SRCH_FROM_DIR_TYPE(), puc512BTmp, &g_stUsbFileSysFatInfo.ucCurEntryOffset, &g_stUsbFileSysFatInfo.ucNxtEntrySetOffset, &g_stUsbFileSysFatInfo.ucCurMatchEntryCnt, ucLoopI);
                    }
#endif
                    if(bTargetFound)
                    {
                        break;
                    }
                    if(g_stUsbFileSysDbrTable.ulSecPerClus == 1)
                    {
                        // Only 1 Sector each Cluster
                        break;
                    }
                }

                // 2. Parse the info. in the located Entry if Target found
                if(GET_U2HOST_SEARCH_NAME_STATUS() == _USB_FILE_SYS_SRCH_FINISH)
                {
                    SET_U2HOST_SEARCH_NAME_STATUS(_USB_FILE_SYS_SRCH_NAME_NONE);

                    SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndexTarget]) + g_stUsbFileSysFatInfo.usSecInClusTarget);
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_GET_TGT_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_IN2 -> FILE_GET_TGT_OUT", 0);

                    break;
                }
                // 3. Judge Next Loop
                else
                {
                    // Judge if current Cluster is not wholly visited
                    if((GET_U2HOST_CUR_LBA() + (g_usUsbFileSysU2HostEHCIMaxDataLen / g_stUsbFileSysDbrTable.usBytePerSec)) < ((GET_U2HOST_CUR_CLUS_START_LBA()) + g_stUsbFileSysDbrTable.ulSecPerClus))
                    {
                        // Update Current LBA to get next 1kB in the same Cluster
                        SET_U2HOST_CUR_LBA(GET_U2HOST_CUR_LBA() + (g_usUsbFileSysU2HostEHCIMaxDataLen / g_stUsbFileSysDbrTable.usBytePerSec));
                    }
                    else
                    {
                        // Record next Root/Sub Dir ClusNum to be visit
                        g_stUsbFileSysFatInfo.stFatDirInfo.ucIndexShadow ++;

                        // Judge if there's still remaining Clusters in Root/Sub Dir
                        if(g_stUsbFileSysFatInfo.stFatDirInfo.ucIndexShadow < g_stUsbFileSysFatInfo.stFatDirInfo.ucIndex)
                        {
                            // Update Current LBA to get next Cluster
                            ulUsbU2HostNextClusLBA = ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndexShadow]);
                            SET_U2HOST_CUR_LBA(ulUsbU2HostNextClusLBA);
                            SET_U2HOST_CUR_CLUS_START_LBA(ulUsbU2HostNextClusLBA);
                            DebugMessageU2Host("[FAT] DirClus IndexCntShadow", g_stUsbFileSysFatInfo.stFatDirInfo.ucIndexShadow);
                            DebugMessageU2Host("[FAT] DirClus IndexCntShadow Start LBA", GET_U2HOST_CUR_LBA());
                        }
                        else
                        {
#if(_USB2_HOST_FILE_NAME_JUDGE_VERSION == _ON)
                            if(g_stUsbFileSysFileInfo.bNot1stFile)
                            {
                                SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[g_stUsbFileSysFatInfo.stFatDirInfo.ucIndexTarget]) + g_stUsbFileSysFatInfo.usSecInClusTarget);
                                DebugMessageU2Host("[FAT] Whole Dir searched, get selected File", 0);

                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_GET_TGT_OUT_QH);
                                DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_IN2 -> FILE_GET_TGT_OUT", 0);

                                break;
                            }
#endif
                            // Whole RootDir Data visited, Target FileName not found.
                            CLR_U2HOST_NTFS_FILE_NOT_FOUND();
                            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                            DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_IN2 -> CUR_PARTITION_ABORT", 0);

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                            CLR_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT);
#endif
                            // will be repalced by Real_IC_Dummy_reg as cychen2's choice. (Value 0 means not execute dump flow)
                            g_bUsbU2HostDummyRegBit0 = _FALSE;

#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON)
                            if(GET_U2HOST_DUMP_CUR_FRAME_FINISH() == _TRUE)
                            {
                                CLR_U2HOST_DUMP_CUR_FRAME_FINISH();
                                DebugMessageU2Host("[DM] Cur Frame Dump Done", 0);
                            }
                            else
#endif
                            {
                                DebugMessageU2Host("[FileSys][FAT32] Target FileName Not Found in Current Partition !", GET_U2HOST_CUR_PARTITION_NUM());
                            }

                            break;
                        }
                    }
                }

                // For FileName not found yet, or FileName found and ShortEntry in the 1st 512 Byte of next Loop
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_SRCH_OUT_QH);
                DebugMessageU2Host("[BULK STATE] FAT_DIR_SRCH_IN2 -> FAT_DIR_SRCH_OUT", 0);
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_FILE_GET_TGT_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_GET_TGT_IN_QH);
            break;

        case _U2HOST_BULK_SCSI_READ10_FILE_GET_TGT_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_GET_TGT_IN_QH);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, 0, puc512BTmp, 512);

                // 1. Get Target Dir / File Info.
                if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_FAT32)
                {
                    ScalerUsbFileSysFat32GetSfnInfo(puc512BTmp, g_stUsbFileSysFatInfo.ucEntryInSecTarget);
                }
#if(_USB2_HOST_FILE_SYSTEM_EXFAT_SUPPORT == _ON)
                else if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_EXFAT)
                {
                    ScalerUsbFileSysExfatGetStrmExtInfo(puc512BTmp, g_stUsbFileSysFatInfo.ucEntryInSecTarget, GET_U2HOST_SRCH_FROM_DIR_TYPE());
                }
#endif
                // 2. Set Next Scsi state
                switch(GET_U2HOST_SRCH_FROM_DIR_TYPE())
                {
                    case _SRCH_1ST_SUB_DIR_FROM_ROOT:

                        // Search Type = Search Sub Dir
                        SET_U2HOST_SRCH_FROM_DIR_TYPE(_SRCH_FILE_FROM_1ST_SUB_DIR);
                        memset(&g_stUsbFileSysFatInfo.stFatDirInfo, 0, sizeof(g_stUsbFileSysFatInfo.stFatDirInfo));
                        g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0] = g_stUsbFileSysFileInfo.ulFileStartClusNum;
                        SET_U2HOST_CUR_LBA(ScalerUsbFileSysFatGetFAT1ClusNumLBA(g_stUsbFileSysFatInfo.stFatDirInfo.pulClusNum[0]));

                        if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_FAT32)
                        {
                            ScalerUsbFileSysFat32ChkGoldenFileName(_SRCH_FILE_FROM_1ST_SUB_DIR);
                        }

                        DebugMessageU2Host("[FileSys] Target Folder Found.", 0);
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FAT_DIR_CLUS_NUM_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] FILE_GET_TGT_IN2 -> FAT_DIR_CLUS_NUM_OUT", 0);

                        break;

                    default:

                        // Search Type = Search File
                        // Update Current LBA to get last Cluster Num. occupied by Target File
                        SET_U2HOST_CUR_LBA(ScalerUsbFileSysFatGetFAT1ClusNumLBA(g_stUsbFileSysFileInfo.ulFileLastClusNum));
                        // Target File found, transition to next step
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_CHK_END_OUT_QH);
                        DebugMessageU2Host("[BULK STATE] FILE_GET_TGT_IN2 -> FILE_CHK_END_OUT", 0);

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
                        SET_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT, _U2HOST_EVENT_PASS);
                        DebugMessageU2Host("[FileSys] Target File Name Found in Partition: ", GET_U2HOST_CUR_PARTITION_NUM());
#endif
                        break;
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_FILE_CHK_END_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_CHK_END_IN_QH);
            break;

        case _U2HOST_BULK_SCSI_READ10_FILE_CHK_END_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_CHK_END_IN_QH);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)

// Do not check File Cluster Continuity for DP_DUMP_DATA
#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _OFF)

                // Check File Continuity for FAT32 (NTFS/exFAT checked already)
                if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_FAT32)
                {
                    // Check if the Last Cluster of Target File is EOC as expected
                    usUsbU2HostOffsetInFat1 = (g_stUsbFileSysFileInfo.ulFileLastClusNum * 4) % g_stUsbFileSysDbrTable.usBytePerSec;
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, usUsbU2HostOffsetInFat1, (BYTE *)(&ulFileLastClusValue), 4);

                    if(ScalerUsbFileSysFatChkEOC(GET_U2HOST_CUR_PARTITION_TYPE(), ulFileLastClusValue) != _TRUE)
                    {
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                        DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> CUR_PARTITION_ABORT, FAT32 Cluster Discontinuous", ulFileLastClusValue);

                        break;
                    }
                }
                else if(GET_U2HOST_CUR_PARTITION_TYPE() == _USB_FILE_SYS_EXFAT)
                {
                    if(g_stUsbFileSysFatInfo.bFileNoFatChain == _FALSE)
                    {
                        SET_U2HOST_BULK_SCSI_STATE(_U2HOST_CUR_PARTITION_ABORT);
                        DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> CUR_PARTITION_ABORT, exFAT Cluster Discontinuous", 0);
                        break;
                    }
                }
#endif

#if((_USB2_HOST_EHCI_FW_PROGRAM_FW_VERSION_CHECK == _ON) && (_CUSTOMER_FW_VERSION_SUPPORT == _ON))

                SET_U2HOST_EVENT_STATUS(_U2HOST_FW_VERSION_CHECK_EVENT, _U2HOST_EVENT_ON_GOING);
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FW_VERSION_CHK_OUT_QH);
                DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> FW_VERSION_CHECK_OUT", 0);

                // Set LBA to FW Version location at Bin file
                SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetFileFwVersionLBA());
#else
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_WAIT_USER_OSD_ENABLE);
                DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> WAIT_USER_OSD_ENABLE, FW Version Check Disable", 0);
                DebugMessageU2Host("[U2 Host] Wait End-User choose OSD to Enable FW Update", 0);
#endif
#endif

#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON)
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_ADD_BULK_WRITE_QH);
                DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> ADD_BULK_WRITE", 0);

                // Set initial file cur LBA that will be Used in WRITE10_DATA_OUT2 State
                SET_U2HOST_FAT32_DB_FILE_DUMP_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFileInfo.ulFileStartClusNum));
                DebugMessageU2Host("[FAT32] DB File Dump Initial LBA", GET_U2HOST_FAT32_DB_FILE_DUMP_LBA());
#endif
            }

            break;

#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
#if((_USB2_HOST_EHCI_FW_PROGRAM_FW_VERSION_CHECK == _ON) && (_CUSTOMER_FW_VERSION_SUPPORT == _ON))
        case _U2HOST_BULK_SCSI_READ10_FW_VERSION_CHK_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FW_VERSION_CHK_IN_QH);
            // DebugMessageU2Host("[BULK STATE] FW_VERSION_CHECK_OUT -> FW_VERSION_CHECK_IN1", 0x00);

            break;

        case _U2HOST_BULK_SCSI_READ10_FW_VERSION_CHK_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, ScalerUsbFileSysGetFileFwVersionOffset(), pucUsbU2HostFWVersion, 2);

                if((pucUsbU2HostFWVersion[0] == _CUSTOMER_FW_VERSION) && (pucUsbU2HostFWVersion[1] == _CUSTOMER_FW_SUB_VERSION))
                {
                    // Set Event Status to User
                    SET_U2HOST_EVENT_STATUS(_U2HOST_FW_VERSION_CHECK_EVENT, _U2HOST_EVENT_FAIL);
                    SET_U2HOST_FLOW_RESET();

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                    DebugMessageU2Host("[BULK STATE] FW_VERSION_CHECK_IN2 -> NONE, FW Version Same.", pucUsbU2HostFWVersion[0]);
                }
                else
                {
                    SET_U2HOST_EVENT_STATUS(_U2HOST_FW_VERSION_CHECK_EVENT, _U2HOST_EVENT_PASS);

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_WAIT_USER_OSD_ENABLE);
                    DebugMessageU2Host("[BULK STATE] FW_VERSION_CHECK_IN2 -> WAIT_USER_OSD_ENABLE, FW Version different.", 0);
                    DebugMessageU2Host("[U2 Host] Wait End-User choose OSD to Enable FW Update", 0);
                }
            }

            break;
#endif // End of #if((_USB2_HOST_EHCI_FW_PROGRAM_FW_VERSION_CHECK == _ON) && (_CUSTOMER_FW_VERSION_SUPPORT == _ON))

        case _U2HOST_WAIT_USER_OSD_ENABLE:

            // Only apply EVENT_CHANGE_STATS when User Change EVENT (EVENT_CHANGE == _TRUE)
            if(GET_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_UPDATE_START) == _TRUE)
            {
                if(GET_U2HOST_EVENT_CHANGE_STATUS(_U2HOST_OSD_FW_UPDATE_START) == _ENABLE)
                {
                    CLR_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_UPDATE_START);
                    SET_U2HOST_EVENT_STATUS(_U2HOST_FW_UPDATE_EVENT, _U2HOST_EVENT_ON_GOING);

                    // Set initial file cur LBA that will be Used in DATA_OUT_QH State
                    SET_U2HOST_CUR_LBA(ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFileInfo.ulFileStartClusNum));
                    DebugMessageU2Host("[FileSys] 1st File LBA", GET_U2HOST_CUR_LBA());

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_DATA_OUT_QH);
                    DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> FILE_DATA_OUT, User Enable", 0);
                }
                else
                {
                    CLR_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_UPDATE_START);
                    SET_U2HOST_FLOW_RESET();

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                    DebugMessageU2Host("[BULK STATE] FILE_CLUS_NUM_IN2 -> NONE, User Disable", 0);
                }
            }

            break;

        case _U2HOST_BULK_SCSI_READ10_FILE_DATA_OUT_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_DATA_IN_QH);
            // DebugMessageU2Host("[BULK STATE] FILE_DATA_OUT -> FILE_DATA_IN1", 0);

            break;

        case _U2HOST_BULK_SCSI_READ10_FILE_DATA_IN_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_DATA_IN_QH);
                // DebugMessageU2Host("[BULK STATE] FILE_DATA_IN1 -> FILE_DATA_IN2", 0);

            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

                if(g_stUsbFileSysFileInfo.usFileRecLoopCnt == 0)
                {
                    UserCommonFwUpdateStartProcess(_USB_U2HOST_PROGRAM_LEN_ONCE, _TRUE);

                    DebugMessageU2Host("[U2 Host] FW_UPDATE_START!", ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFileInfo.ulFileStartClusNum));
                }

                for(ucLoopI = 0; ucLoopI < 2; ucLoopI++)
                {
                    // Get the ucLoop(1st/2nd) 512 Byte Data during 1KB, Store in puc512BTmp[].
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_EHCI_BULK_DATA_BUFFER_ST_ADDR, (512 * ucLoopI), puc512BTmp, 512);

                    for(ucLoopJ = 0; ucLoopJ < 2; ucLoopJ++)
                    {
                        // update FW 256 Byte Each time
                        UserCommonFwUpdateWriteDataProcess((&puc512BTmp[ucLoopJ * 256]), _USB_U2HOST_PROGRAM_LEN_ONCE, _FALSE);

                        // Add Delay to avoid write flash data error and HDCP Check Fail
                        ScalerTimerDelayXms(3);
                    }
                }

                // Calculate the Last LBA of the Target File
                ulUsbU2HostFileLastLBA = ScalerUsbFileSysGetClusStartLBA(g_stUsbFileSysFileInfo.ulFileLastClusNum) + ((g_stUsbFileSysFileInfo.uqFileSizeInByte / g_stUsbFileSysDbrTable.usBytePerSec) - ((g_stUsbFileSysFileInfo.usFileSizeInClus - 1) * g_stUsbFileSysDbrTable.ulSecPerClus));
                // Judge if the whole Target File is loaded
                if((GET_U2HOST_CUR_LBA() + (g_usUsbFileSysU2HostEHCIMaxDataLen / g_stUsbFileSysDbrTable.usBytePerSec)) == ulUsbU2HostFileLastLBA)
                {
                    DebugMessageU2Host("[U2 Host] Read File Finished !", 0);

                    if(GET_U2HOST_EVENT_STATUS(_U2HOST_FW_UPDATE_EVENT) == _U2HOST_EVENT_ON_GOING)
                    // FwUpdateFinish() hasn't been checked
                    {
                        if(UserCommonFwUpdateFinishProcess() == _FALSE)
                        {
                            // Update Event Status to User
                            SET_U2HOST_EVENT_STATUS(_U2HOST_FW_UPDATE_EVENT, _U2HOST_EVENT_FAIL);

                            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                            DebugMessageU2Host("[BULK STATE] FILE_DATA_IN2 -> NONE, Read File Finish And Check FW Update Fail !!", 0);

                            break;
                        }
                        else
                        {
                            // Update Event Status to User
                            SET_U2HOST_EVENT_STATUS(_U2HOST_FW_UPDATE_EVENT, _U2HOST_EVENT_PASS);
                            // Update the FW Update Progress in percentage to User
                            SET_U2_HOST_FW_UPDATE_RATE(100);

                            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_WAIT_USER_OSD_REBOOT);
                            DebugMessageU2Host("[BULK STATE] FILE_DATA_IN2 -> WAIT_USER_OSD_REBOOT, Read File Finish And Check FW Update Pass !!", 0);
                            DebugMessageU2Host("[U2 Host] Wait End-User choose OSD to Re-Boot", 0);
                        }
                    }
                    else
                    {
                        DebugMessageU2Host("[U2 Host] Unexpected Case, FILE_DATA_IN2", 0);
                    }
                }
                // Next loop is needed to get whole Target File
                else
                {
                    g_stUsbFileSysFileInfo.usFileRecLoopCnt ++;
                    SET_U2HOST_CUR_LBA(GET_U2HOST_CUR_LBA() + (g_usUsbFileSysU2HostEHCIMaxDataLen / g_stUsbFileSysDbrTable.usBytePerSec));

                    // Update the FW Update Progress in percentage to User, reserve 10% for CRC check
                    SET_U2_HOST_FW_UPDATE_RATE((BYTE)((((QWORD)g_stUsbFileSysFileInfo.usFileRecLoopCnt * g_usUsbFileSysU2HostEHCIMaxDataLen * 90) / g_stUsbFileSysFileInfo.uqFileSizeInByte)));
                    // DebugMessageU2Host("[Read File] Percentage : ", GET_U2_HOST_FW_UPDATE_RATE());

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_FILE_DATA_OUT_QH);
                    // DebugMessageU2Host("[BULK STATE] FILE_DATA_IN2 -> FILE_DATA_IN1", 0);
                }
            }

            break;

        case _U2HOST_WAIT_USER_OSD_REBOOT:

            // Only apply EVENT_CHANGE_STATS when User Change EVENT (EVENT_CHANGE == _TRUE)
            if(GET_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_REBOOT_ENABLE) == _TRUE)
            {
                if(GET_U2HOST_EVENT_CHANGE_STATUS(_U2HOST_OSD_FW_REBOOT_ENABLE) == _ENABLE)
                {
                    CLR_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_REBOOT_ENABLE);

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                    DebugMessageU2Host("[BULK STATE] FILE_DATA_IN2 -> NONE, Re-Boot Enable", 0);
                    CLR_U2HOST_BULK_READ_ENABLE();
                    CLR_U2HOST_TRANSFER_STATUS();

                    // Reset IC after FW Update finished
                    UserCommonFwUpdateReset();
                }
                else if(GET_U2HOST_EVENT_CHANGE_STATUS(_U2HOST_OSD_FW_REBOOT_ENABLE) == _DISABLE)
                {
                    CLR_U2HOST_EVENT_CHANGE(_U2HOST_OSD_FW_REBOOT_ENABLE);

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                    DebugMessageU2Host("[BULK STATE] FILE_DATA_IN2 -> NONE, Re-Boot Disable", 0);
                    CLR_U2HOST_BULK_READ_ENABLE();
                    CLR_U2HOST_TRANSFER_STATUS();
                }
            }

            break;

        case _U2HOST_CUR_PARTITION_ABORT:

            ucCurPtnNum = GET_U2HOST_CUR_PARTITION_NUM();

            if (ucCurPtnNum < _SUPPORT_PARTITION_NUM)
            {
                SET_U2HOST_CUR_PARTITION_NUM(ucCurPtnNum + 1);

                SET_U2HOST_CUR_PARTITION_TYPE(_USB_FILE_SYS_NONE);
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_JUDGE_PARTITION_ID);
                DebugMessageU2Host("[BULK STATE] CUR_PARTITION_ABORT -> JUDGE_PARTITION_ID, Try next Partition: ", (ucCurPtnNum + 1));
            }
            else
            {
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_NONE);
                DebugMessageU2Host("[BULK STATE] CUR_PARTITION_ABORT -> NONE, all 4 Partition failed", ucCurPtnNum);

                // Set Event Status to User
                SET_U2HOST_EVENT_STATUS(_U2HOST_FILE_NAME_SEARCH_EVENT, _U2HOST_EVENT_FAIL);
                SET_U2HOST_FLOW_RESET();

                DebugMessageU2Host("[FAT32] Target FileName Not Found in all exist Partition !", ucCurPtnNum);
            }

            break;

#endif // End of #if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)

#if(_USB2_HOST_EHCI_DB_DUMP_DATA_SUPPORT == _ON)
        case  _U2HOST_ADD_BULK_WRITE_QH:

            SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH);
            // DebugMessageU2HostEHCI("[BULK STATE]ADD_BULK_WRITE -> WRITE10_DATA_OUT1", 0);
            break;

        case _U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH:

            if(GET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG() == _FALSE)
            {
                SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH);

                // DebugMessageU2HostEHCI("[BULK STATE]WRITE10_DATA_OUT1 -> WRITE10_DATA_OUT2", 0);
            }
            else
            {
                CLR_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_IN_QH);
                // DebugMessageU2HostEHCI("[BULK STATE]WRITE10_DATA_OUT2 -> WRITE10_DATA_IN", 0);
            }
            break;

        case _U2HOST_BULK_SCSI_WRITE10_DATA_IN_QH:

#if(_U2HOST_DM_DUMP_DATA_ERR_HANDLER_OLD_MODE == _ON)

            g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcXferCntOnceShadow--;
            DebugMessageU2HostEHCI("[DM]How much is left to transmit", g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcXferCntOnceShadow);

            if(g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcXferCntOnceShadow > 0)
            {
                // Update Next Locgicl Block Addr For Mass Storge
                SET_U2HOST_FAT32_DB_FILE_DUMP_LBA((GET_U2HOST_FAT32_DB_FILE_DUMP_LBA() + (g_stUsbU2HostDBCurPath.usUsbU2HostDBCurXferLen / g_stUsbFileSysDbrTable.usBytePerSec)));

                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH);
            }
            else
            {
                // Reload DBCalcCrcXferCntOnce
                g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcXferCntOnceShadow = g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcXferCntOnce;

                // Calculate Crc Result
                ScalerUsbU2HostGetCurDMCrcAndXferEnResult();

                if(ScalerUsbU2HostCheckCrcResultSame() == _TRUE)
                {
                    DebugMessageU2HostEHCI("[DM] CRC Check Same", 0);
                    SET_U2HOST_DB_CUR_CRC_SAME_STATE(_U2HOST_DB_CRC_SAME);

                    // Update Next VH NO. to be transmitted only when the CRC is correct
                    g_stUsbU2HostDBCurPath.usUsbU2HostDBNextXferVHNO += g_stUsbU2HostDBCurPath.ucUsbU2HostDBXferVHNumCalcCrc;

                    // Update Next Locgicl Block Addr For Mass Storge
                    // "-50" is only for 1920 * 1080 case which xfer (140+20)KB each time confirming 16 vehight(135KB) crc pass, to make sure data stored in mass device is valid/correct and continuous
                    // "-50" means 50*usBytesPerSec = 50 * 512Byte = 25KB = [(140+20) - 135kB]
                    SET_U2HOST_FAT32_DB_FILE_DUMP_LBA((GET_U2HOST_FAT32_DB_FILE_DUMP_LBA() + (g_stUsbU2HostDBCurPath.usUsbU2HostDBCurXferLen / g_stUsbFileSysDbrTable.usBytePerSec) - 50));


                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH);

                    // Means this is Last CalcCrcXfer in cur path
                    if(g_stUsbU2HostDBCurPath.usUsbU2HostDBNextXferVHNO > g_stUsbU2HostDBCurPath.usUsbU2HostDBCurPathVehight)
                    {
                        g_stUsbU2HostDBCurPath.usUsbU2HostDBNextXferVHNO = 1;
                        SET_U2HOST_DB_CUR_PATH_FINISH_STATE();

                        DebugMessageU2HostEHCI("!!Diff Cnt!!", g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcDiffCnt);
                        g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcDiffCnt = 0;

                        switch(GET_MDOMAIN_INPUT_DATA_PATH())
                        {
                            case _INPUT_PATH_M1_M2:

                                if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M1)
                                {
                                    // Update Path = M2 for next Initial
                                    SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M2);

                                    DebugMessageU2HostEHCI("[DM]Cur Path Finish-Change Path", GET_U2HOST_DB_CUR_PATH());

                                    // Go Back for preparing to Search Next File Name
                                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                    DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                    // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                    ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_M2_INDEX);

                                    // CAITEST
                                    // ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_INDEX_NONE); // SERACH NONE  intentionally
                                }
                                else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M2)
                                {
                                    // Reset Path = M1 for next Initial
                                    SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M1);

                                    // Still need to execute more bulk to ensure that the data is written into the U disk even if Cur Bulk write finished
                                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                    DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                    if(GET_U2HOST_DDR_FRC_CLIENT_EN_STATUS() == _FALSE)
                                    {
                                        // u2 client not use for the time being, enable FRC Client preparing to load next frame data to DDR
                                        ScalerFRCEn(_FRC_ALL_ONOFF, GET_MDOMAIN_INPUT_DATA_PATH(), _ENABLE);
                                        SET_U2HOST_DDR_FRC_CLIENT_EN_STATUS();
                                    }

                                    // Cur frame finished, Search None intentionally until switch next frame(will be Operated by cychen2)
                                    ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_INDEX_NONE);

                                    // Still need to execute more bulk to ensure that the data is written into the U disk even if Cur Bulk write finished
                                    SET_U2HOST_DUMP_CUR_FRAME_FINISH();
                                }
                                else
                                {
                                    // Not define
                                }
                                break;

                            case _INPUT_PATH_M1_M2_S1_S2:

                                if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M1)
                                {
                                    // Update Path = M2 for next Initial
                                    SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M2);

                                    // Go Back for preparing to Search Next File Name
                                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                    DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                    // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                    ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_M2_INDEX);
                                }
                                else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M2)
                                {
                                    // Update Path = M1 for next Initial
                                    SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_S1);

                                    // Go Back for preparing to Search Next File Name
                                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                    DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                    // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                    ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_S1_INDEX);
                                }
                                else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_S1)
                                {
                                    // Update Path = S2 for next Initial
                                    SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_S2);

                                    // Go Back for preparing to Search Next File Name
                                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                    DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                    // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                    ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_S2_INDEX);
                                }
                                else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_S2)
                                {
                                    // Reset Path = M1 for next Initial
                                    SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M1);

                                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                    DebugMessageU2HostEHCI("[DM]To SCSI None For Cur Frame Finish", 0);

                                    if(GET_U2HOST_DDR_FRC_CLIENT_EN_STATUS() == _FALSE)
                                    {
                                        // u2 client not use for the time being, enable FRC Client preparing to load next frame data to DDR
                                        ScalerFRCEn(_FRC_ALL_ONOFF, GET_MDOMAIN_INPUT_DATA_PATH(), _ENABLE);
                                        SET_U2HOST_DDR_FRC_CLIENT_EN_STATUS();
                                    }

                                    // Cur frame finished, Search None intentionally until switch next frame(will be Operated by cychen2)
                                    ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_INDEX_NONE);

                                    // Still need to execute more bulk to ensure that the data is written into the U disk even if Cur Bulk write finished
                                    SET_U2HOST_DUMP_CUR_FRAME_FINISH();
                                }
                                else
                                {
                                    // Not Define
                                }
                                break;

                            default:
                                break;
                        }
                    }
                }
                else
                {
                    SET_U2HOST_DB_CUR_CRC_SAME_STATE(_U2HOST_DB_CRC_DIFF);
                    DebugMessageU2HostEHCI("[DM]CRC Check Diff", 0);

                    g_stUsbU2HostDBCurPath.ucUsbU2HostDBCalcCrcDiffCnt ++;

                    // Retry Block Addr For Cur CalcCrcXferCnt -
                    SET_U2HOST_FAT32_DB_FILE_DUMP_LBA(g_stUsbU2HostDBCurPath.ulUsbU2HostDBtoDeviceStartAddrCurCrcCalc);

                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH);
                }

                DebugMessageU2HostEHCI("[DM]DB Next Xfer VH NO", g_stUsbU2HostDBCurPath.usUsbU2HostDBNextXferVHNO);
            }
#else
            // Judge once after each Bluk Data Out Stage(ex.20KB) is completed
            if(ScalerUsbU2HostGetDMAddrErrFlag() == _TRUE) // Missing 60 Byte occured in cur Bluk Data Out Stage
            {
                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH);

                // 1. Not need to update Locgicl Block Addr For Mass Storge
                // 2. Only need to setting DM Client Related Reg, refer to the following -> Scaler_UsbU2Host_DMClient_Update()
            }
            else // NO missing 60 Byte in cur Bluk Data Out Stage
            {
                // How many times are left (to be transmitted)
                g_stUsbU2HostDBCurPath.usUsbU2HostDBCurPathXferCntShadow--;
                DebugMessageU2HostEHCI("[DM]How much is left to transmit", g_stUsbU2HostDBCurPath.usUsbU2HostDBCurPathXferCntShadow);

                if(g_stUsbU2HostDBCurPath.usUsbU2HostDBCurPathXferCntShadow > 0)
                {
                    SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_WRITE10_DATA_OUT_QH);

                    // Update Next Locgicl Block Addr For Mass Storge
                    SET_U2HOST_FAT32_DB_FILE_DUMP_LBA((GET_U2HOST_FAT32_DB_FILE_DUMP_LBA() + (g_stUsbU2HostDBCurPath.usUsbU2HostDBCurXferLen / g_stUsbFileSysDbrTable.usBytePerSec)));
                    DebugMessageU2HostEHCI("[FAT]DB File Dump Update LBA", GET_U2HOST_FAT32_DB_FILE_DUMP_LBA());
                }
                else // (g_stUsbU2HostDBCurPath.usUsbU2HostDBCurPathXferCntShadow == 0)   No data to transmit,(this is last data process)
                {
                    SET_U2HOST_DB_CUR_PATH_FINISH_STATE();

                    switch(GET_MDOMAIN_INPUT_DATA_PATH())
                    {
                        case _INPUT_PATH_M1_M2:

                            if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M1)
                            {
                                // Update Path = M2 for next Initial
                                SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M2);

                                DebugMessageU2HostEHCI("[DM]Cur Path Finish-Change Path", GET_U2HOST_DB_CUR_PATH());

                                // Go Back for preparing to Search Next File Name
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_M2_INDEX);

                                // CAITEST
                                /*
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_INDEX_NONE); // SERACH NONE  intentionally

                                ScalerUsbU2HostDebugReg();


                                DebugMessageU2HostEHCI("Cap & Disp EN", 0);
                                */
                                // CAITEST END
                            }
                            else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M2)
                            {
                                // Reset Path = M1 for next Initial
                                SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M1);

                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                DebugMessageU2HostEHCI("[DM]To SCSI None For Cur Frame Finish", 0);

                                if(GET_U2HOST_DDR_FRC_CLIENT_EN_STATUS() == _FALSE)
                                {
                                    // u2 client not use for the time being, enable FRC Client preparing to load next frame data to DDR
                                    ScalerFRCEn(_FRC_ALL_ONOFF, GET_MDOMAIN_INPUT_DATA_PATH(), _ENABLE);
                                    SET_U2HOST_DDR_FRC_CLIENT_EN_STATUS();
                                }

                                ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_INDEX_NONE); // SERACH NONE  intentionally

                                // Still need to execute more bulk to ensure that the data is written into the U disk even if Cur Bulk write finished
                                SET_U2HOST_DUMP_CUR_FRAME_FINISH();
                            }
                            else
                            {
                                // Not define
                            }
                            break;

                        case _INPUT_PATH_M1_M2_S1_S2:

                            if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M1)
                            {
                                // Update Path = M2 for next Initial
                                SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M2);

                                // Go Back for preparing to Search Next File Name
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_M2_INDEX);
                            }
                            else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_M2)
                            {
                                // Update Path = M1 for next Initial
                                SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_S1);

                                // Go Back for preparing to Search Next File Name
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_S1_INDEX);
                            }
                            else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_S1)
                            {
                                // Update Path = S2 for next Initial
                                SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_S2);

                                // Go Back for preparing to Search Next File Name
                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                // Update File name - for Test_xx_yy_z, only need to replace "z" in cur frame.[Test_Offset(46+48)_Offset(52+54)_Offset(60).txt]
                                ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_S2_INDEX);
                            }
                            else if(GET_U2HOST_DB_CUR_PATH() == _U2HOST_DB_S2)
                            {
                                // Reset Path = M1 for next Initial
                                SET_U2HOST_DB_CUR_PATH(_U2HOST_DB_M1);

                                SET_U2HOST_BULK_SCSI_STATE(_U2HOST_BULK_SCSI_READ10_MBR_OUT_QH);
                                DebugMessageU2HostEHCI("[DM]To SCSI MBR Prepare searching Next File Name", 0);

                                if(GET_U2HOST_DDR_FRC_CLIENT_EN_STATUS() == _FALSE)
                                {
                                    // u2 client not use for the time being, enable FRC Client preparing to load next frame data to DDR
                                    ScalerFRCEn(_FRC_ALL_ONOFF, GET_MDOMAIN_INPUT_DATA_PATH(), _ENABLE);
                                    SET_U2HOST_DDR_FRC_CLIENT_EN_STATUS();
                                }
                                // Cur frame finished, Search None intentionally until switch next frame(will be Operated by cychen2)
                                ScalerUsbU2HostDBDumpSubFrameNameUpdate(_U2HOST_DB_INDEX_NONE);

                                // Still need to execute more bulk to ensure that the data is written into the U disk even if Cur Bulk write finished
                                SET_U2HOST_DUMP_CUR_FRAME_FINISH();
                            }
                            else
                            {
                                // Not Define
                            }
                            break;

                        default:
                            break;
                    }
                }
            }

            // Update DM Client Setting
            ScalerUsbU2HostDMClientUpdate();
#endif
            break;
#endif
        case _U2HOST_CLEAR_HALT_DUR_BULK:

            SET_U2HOST_BULK_SCSI_STATE(GET_U2HOST_NEXT_STATE_AFTER_HALT());

            // Execute Csw After Clear_Halt
            SET_U2HOST_BULK_QH_1ST_QTD_PROCESS_FLAG();

            DebugMessageU2Host("[SCSI] NEXT_STATE_AFTER_HALT", GET_U2HOST_BULK_SCSI_STATE());
            break;

        default:

            break;
    }
}
#endif // End of #if(_USB2_HOST_EHCI_SUPPORT == _ON)
#endif // End of #if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_MAIN_LOOP)

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
#if(_USB2_HOST_EHCI_SUPPORT == _ON)
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host ISP Initial(For RTOS U2 Host)
// Input Value  : None
// Output Value : None
//----------------------------------------------------------------------------------------------------
void SysUsbU2HostIspInital(void)
{
    EnumUSB2HostEventChangeType enumUSB2HostEventChangeType = _U2HOST_OSD_FW_UPDATE_ENABLE;
    EnumUSB2HostEventType enumUSB2HostEventType = _U2HOST_FILE_NAME_SEARCH_EVENT;

    CLR_U2_HOST_FW_UPDATE_RATE();

    // Clear All Event Status and Event Change Marco
    for(enumUSB2HostEventType = _U2HOST_FILE_NAME_SEARCH_EVENT; enumUSB2HostEventType < _U2HOST_EVENT_COUNT; enumUSB2HostEventType++)
    {
        if(GET_U2HOST_EVENT_STATUS(enumUSB2HostEventType) == _U2HOST_EVENT_ON_GOING)
        {
            CLR_U2HOST_EVENT_STATUS(enumUSB2HostEventType);
        }
    }

    for(enumUSB2HostEventChangeType = _U2HOST_OSD_FW_UPDATE_ENABLE; enumUSB2HostEventChangeType < _U2HOST_EVENT_CHANGE_COUNT; enumUSB2HostEventChangeType++)
    {
        CLR_U2HOST_EVENT_CHANGE(enumUSB2HostEventChangeType);
        CLR_U2HOST_EVENT_CHANGE_STATUS(enumUSB2HostEventChangeType);
    }
}
#endif // End of #if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
#endif // End of #if(_USB2_HOST_EHCI_SUPPORT == _ON)
#endif // End of #if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)

#if(_USB2_HOST_EHCI_SUPPORT == _ON)
#if(_USB2_HOST_EHCI_MASS_STORGE_PROGRAM_SUPPORT == _ON)
//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host FW Update Progress Rate Percentage
// Input Value  : void
// Output Value : FW Update Progress Rate Percentage
//----------------------------------------------------------------------------------------------------
BYTE SysUsbU2HostFwUpdateProgressRate(void)
{
    return GET_U2_HOST_FW_UPDATE_RATE();
}

//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host Get Event Status
// Input Value  : EnumUSB2HostEventType
// Output Value : EnumUSB2HostEventResult
//----------------------------------------------------------------------------------------------------
EnumUSB2HostEventResult SysUsbU2HostGetEventStatus(EnumUSB2HostEventType enumUSB2HostEventType)
{
    return GET_U2HOST_EVENT_STATUS(enumUSB2HostEventType);
}

//-----------------------------------------------
// Description  : USB2 Host Clear Event Status
// Input Value  : EnumUSB2HostEventType
// Output Value : void
//-----------------------------------------------
void SysUsbU2HostClearEventStatus(EnumUSB2HostEventType enumUSB2HostEventType)
{
    if(GET_U2HOST_EVENT_STATUS(enumUSB2HostEventType) != _U2HOST_EVENT_ON_GOING)
    {
        CLR_U2HOST_EVENT_STATUS(enumUSB2HostEventType);
        DebugMessageU2Host("[U2 Host] User Clear Event Status", enumUSB2HostEventType);
    }
}

//--------------------------------------------------
// Description  : Set Event Change Flag For External Interface
// Input Value  : EnumUSB2HostEventChangeType , ucEnable
// Output Value : NONE
//--------------------------------------------------
void SysUsbU2HostSetEventChange(EnumUSB2HostEventChangeType enumUSB2HostEventChangeType, BYTE ucEnable)
{
    SET_U2HOST_EVENT_CHANGE(enumUSB2HostEventChangeType);
    SET_U2HOST_EVENT_CHANGE_STATUS(enumUSB2HostEventChangeType, ucEnable);

    DebugMessageU2Host("[U2 Host] User Set Event Change !! ", enumUSB2HostEventChangeType);
    DebugMessageU2Host("[U2 Host] User Set Event Status !! ", ucEnable);
}

//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host Get Event Change
// Input Value  : void
// Output Value : BYTE
//----------------------------------------------------------------------------------------------------
BYTE SysUsbU2HostGetEventChange(void)
{
    BYTE ucU2HostUserEventChange = _FALSE;
    EnumUSB2HostEventChangeType enumUSB2HostEventChangeType = _U2HOST_OSD_FW_UPDATE_ENABLE;

    // Check User or Other IP info U2 Host Event Change
    for(enumUSB2HostEventChangeType = _U2HOST_OSD_FW_UPDATE_ENABLE; enumUSB2HostEventChangeType < _U2HOST_EVENT_CHANGE_COUNT; enumUSB2HostEventChangeType++)
    {
        if(GET_U2HOST_EVENT_CHANGE(enumUSB2HostEventChangeType) == _TRUE)
        {
            ucU2HostUserEventChange = _TRUE;
            DebugMessageU2Host("[U2 Host] Event Change ID :", enumUSB2HostEventChangeType);
        }
    }

    return ucU2HostUserEventChange;
}

#endif
#endif

#if(_USB2_HOST_OHCI_COLOR_ANALYZER_SUPPORT == _ON)
//----------------------------------------------------------------------------------------------------
// Description  : External Interface get Valid Device Index from U2 Host
// Input Value  : None
// Output Value : ucValidDevIndex: a BitMap that indicates the status of up to 8 Devices. The status of Dev0 is represented by Bit0 of ucValidDevIndex.
//----------------------------------------------------------------------------------------------------
BYTE SysUsbU2HostGetValidDevIndex(void)
{
    return g_stUsbU2HostDevConnectInfo.ucValidDevIndex;
}

//----------------------------------------------------------------------------------------------------
// Description  : External Interface get VendorID from U2 Host
// Input Value  : ucDevIndex: The Device Index of the Device that the User is interested in.
// Output Value : VendorID of the indicated Device
//----------------------------------------------------------------------------------------------------
WORD SysUsbU2HostGetVendorID(BYTE ucDevIndex)
{
    ucDevIndex = ucDevIndex;

    // Transfer the ucDevIndex to BitMap
    BYTE ucTargetBit = (0x01 << ucDevIndex);

    if((ucTargetBit & g_stUsbU2HostDevConnectInfo.ucValidDevIndex) == ucTargetBit)
    {
        return g_stUsbU2HostDevConnectInfo.pusUsb2HostValidDevVID[ucDevIndex];
    }
    else
    {
        DebugMessageU2Host("[User] ucDevIndex is not valid !", ucDevIndex);
        return _U2HOST_VID_ERROR;
    }
}

//----------------------------------------------------------------------------------------------------
// Description  : External Interface get ProductID from U2 Host
// Input Value  : ucDevIndex: The Device Index of the Device that the User is interested in.
// Output Value : ProductID of the indicated Device
//----------------------------------------------------------------------------------------------------
WORD SysUsbU2HostGetProductID(BYTE ucDevIndex)
{
    ucDevIndex = ucDevIndex;

    // Transfer the ucDevIndex to BitMap
    BYTE ucTargetBit = (0x01 << ucDevIndex);

    if((ucTargetBit & g_stUsbU2HostDevConnectInfo.ucValidDevIndex) == ucTargetBit)
    {
        return g_stUsbU2HostDevConnectInfo.pusUsb2HostValidDevPID[ucDevIndex];
    }
    else
    {
        DebugMessageU2Host("[User] ucDevIndex is not valid !", ucDevIndex);
        return _U2HOST_VID_ERROR;
    }
}

//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host Set Initial Request Flag/Data from External Interface
// Input Value  : Dev VID, Dev PID, Transfer Type
// Output Value : bSetReqResult, indicate if Initial Request is set
//----------------------------------------------------------------------------------------------------
bit SysUsbU2HostSetColorInitial(WORD usVid, WORD usPid, EnumUsbU2HostTransferType enumTransferType)
{
    bit bSetInitialResult = _FAIL;
    usVid = usVid;
    usPid = usPid;

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
    // SCPU Flow

    // should be fill-in by Zhiahao

#else
    // KCPU Flow

    // Check REQ_STATUS is cleared and COLOR_STATE is in IDLE
    if((GET_U2HOST_COLOR_REQ_STATUS() != _U2HOST_COLOR_REQ_NONE) || (GET_U2HOST_COLOR_STATE() != _U2HOST_COLOR_IDLE))
    {
        DebugMessageU2HostOHCI("[COLOR] Initial Request asserted before Previous Cmd finishes !", GET_U2HOST_COLOR_REQ_STATUS());
    }
    // Set Initial Reqest to U2 Host
    else
    {
        switch(enumTransferType)
        {
            case _U2HOST_BULK_TRANSFER:

                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_BULK_INITIAL);
                break;

            case _U2HOST_INT_TRANSFER:

                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_INT_INITIAL);
                break;

            default:
                break;
        }

        bSetInitialResult = _SUCCESS;
    }
#endif

    return bSetInitialResult;
}

//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host Set Write Request Flag/Data from External Interface
// Input Value  : Dev VID, Dev PID, Transfer Type, External Write Data Pointer, Write Data Length
// Output Value : bSetReqResult, indicate if Write Request is set
//----------------------------------------------------------------------------------------------------
bit SysUsbU2HostSetColorWriteReq(WORD usVid, WORD usPid, EnumUsbU2HostTransferType enumTransferType, BYTE *pucWriteReqData, BYTE ucWriteReqLen)
{
    bit bSetReqResult = _FAIL;
    usVid = usVid;
    usPid = usPid;

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
    // SCPU Flow

    if(enumTransferType == _U2HOST_BULK_TRANSFER)
    {
        if((usVid == _U2HOST_VID_CA410) && (usPid == _U2HOST_PID_CA410))
        {
            // Check if ucBulkOutLen < 24, since the size of g_pucUsbU2HostColorWriteReqData is 24 Byte
            if(ucWriteReqLen > 24)
            {
                DebugMessageU2HostOHCI("[COLOR] ucWriteReqLen exceed Maximum!", ucWriteReqLen);
            }
            else
            {
                if((GET_U2HOST_COLOR_BULK_WRITE_PROCESSING() == _FALSE) && (GET_U2HOST_COLOR_BULK_READ_PROCESSING() == _FALSE))
                {
                    g_ucUsbU2HostColorWriteReqLen = ucWriteReqLen;
                    for(BYTE ucTmp = 0; ucTmp < ucWriteReqLen; ucTmp++)
                    {
                        g_pucUsbU2HostColorWriteReqData[ucTmp] = pucWriteReqData[ucTmp];
                    }

                    SET_U2HOST_COLOR_BULK_WRITE_REQ();

                    bSetReqResult = _SUCCESS;
                }
                else
                {
                    DebugMessageU2HostOHCI("[Bulk] New BulkOut Request asserted before Previous Cmd finishes !", 0x01);
                }
            }
        }
    }
    else if(enumTransferType == _U2HOST_INT_TRANSFER)
    {
        if((usVid == _U2HOST_VID_XRITE) && (usPid == _U2HOST_PID_XRITE))
        {
            // Check if ucIntOutLen < 24, since the size of g_pucUsbU2HostColorWriteReqData is 24 Byte
            if(ucWriteReqLen > 24)
            {
                DebugMessageU2HostOHCI("[COLOR] ucWriteReqLen exceed Maximum!", ucWriteReqLen);
            }
            else
            {
                if((GET_U2HOST_COLOR_INT_WRITE_PROCESSING() == _FALSE) && (GET_U2HOST_COLOR_INT_READ_PROCESSING() == _FALSE))
                {
                    g_ucUsbU2HostColorWriteReqLen = ucWriteReqLen;
                    for(BYTE ucTmp = 0; ucTmp < ucWriteReqLen; ucTmp++)
                    {
                        g_pucUsbU2HostColorWriteReqData[ucTmp] = pucWriteReqData[ucTmp];
                    }

                    SET_U2HOST_COLOR_INT_WRITE_REQ();

                    bSetReqResult = _SUCCESS;
                }
                else
                {
                    DebugMessageU2HostOHCI("[Int] New IntOut Request asserted before Previous Cmd finishes !", 0x01);
                }
            }
        }
    }
#else
    // KCPU Flow

    // Check if ucBulkOutLen < 24, since the size of g_pucUsbU2HostColorWriteReqData is 24 Byte
    if(ucWriteReqLen > 24)
    {
        DebugMessageU2HostOHCI("[COLOR] ucWriteReqLen exceed Maximum!", ucWriteReqLen);
    }
    // Check REQ_STATUS is cleared and COLOR_STATE is in IDLE
    else if((GET_U2HOST_COLOR_REQ_STATUS() != _U2HOST_COLOR_REQ_NONE) || (GET_U2HOST_COLOR_STATE() != _U2HOST_COLOR_IDLE))
    {
        DebugMessageU2HostOHCI("[COLOR] New Write Request asserted before Previous Cmd finishes !", GET_U2HOST_COLOR_REQ_STATUS());
    }
    // Set Write Reqest to U2 Host
    else
    {
        g_ucUsbU2HostColorWriteReqLen = ucWriteReqLen;

        for(BYTE ucTmp = 0; ucTmp < ucWriteReqLen; ucTmp++)
        {
            g_pucUsbU2HostColorWriteReqData[ucTmp] = pucWriteReqData[ucTmp];
        }

        if(GET_U2HOST_COLOR_RSP_STATUS() != _U2HOST_COLOR_RSP_NONE)
        {
            // clr previous RSP_STATUS since User not interested
            CLR_U2HOST_COLOR_RSP_STATUS();
        }

        switch(enumTransferType)
        {
            case _U2HOST_CONTROL_TRANSFER:

                DebugMessageU2HostOHCI("[COLOR][Warning] Control Transfer's functionality might need further testing !", 0);
                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_CONTROL_OUT);
                break;

            case _U2HOST_BULK_TRANSFER:

                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_BULK_OUT);
                break;

            case _U2HOST_INT_TRANSFER:

                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_INT_OUT);
                break;

            default:
                break;
        }

        bSetReqResult = _SUCCESS;
    }
#endif

    return bSetReqResult;
}

//----------------------------------------------------------------------------------------------------
// Description  : USB2 Host Set Read Request Flag from External Interface
// Input Value  : Dev VID, Dev PID, Transfer Type
// Output Value : bSetReqResult, indicate if Read Request is set
//----------------------------------------------------------------------------------------------------
bit SysUsbU2HostSetColorReadReq(WORD usVid, WORD usPid, EnumUsbU2HostTransferType enumTransferType)
{
    bit bSetReqResult = _FAIL;
    usVid = usVid;
    usPid = usPid;

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
    // SCPU Flow

    if(enumTransferType == _U2HOST_BULK_TRANSFER)
    {
        if((usVid == _U2HOST_VID_CA410) && (usPid == _U2HOST_PID_CA410))
        {
            if((GET_U2HOST_COLOR_BULK_WRITE_PROCESSING() == _FALSE) && (GET_U2HOST_COLOR_BULK_READ_PROCESSING() == _FALSE))
            {
                SET_U2HOST_COLOR_BULK_READ_REQ();
                bSetReqResult = _SUCCESS;
            }
            else
            {
                DebugMessageU2HostOHCI("[Bulk] New BulkIn Request asserted before Previous Cmd finishes !", 0x01);
            }
        }
    }
    else if(enumTransferType == _U2HOST_INT_TRANSFER)
    {
        if((usVid == _U2HOST_VID_XRITE) && (usPid == _U2HOST_PID_XRITE))
        {
            if((GET_U2HOST_COLOR_INT_WRITE_PROCESSING() == _FALSE) && (GET_U2HOST_COLOR_INT_READ_PROCESSING() == _FALSE))
            {
                SET_U2HOST_COLOR_INT_READ_REQ();
                bSetReqResult = _SUCCESS;
            }
            else
            {
                DebugMessageU2HostOHCI("[Int] New IntIn Request asserted before Previous Cmd finishes !", 0x01);
            }
        }
    }
#else
    // KCPU Flow

    // Check REQ_STATUS is cleared and COLOR_STATE is in IDLE
    if((GET_U2HOST_COLOR_REQ_STATUS() != _U2HOST_COLOR_REQ_NONE) || (GET_U2HOST_COLOR_STATE() != _U2HOST_COLOR_IDLE))
    {
        DebugMessageU2HostOHCI("[COLOR] New Read Request asserted before Previous Cmd finishes !", GET_U2HOST_COLOR_REQ_STATUS());
    }
    // Set Read Request to U2 Host
    else
    {
        if(GET_U2HOST_COLOR_RSP_STATUS() != _U2HOST_COLOR_RSP_NONE)
        {
            // clr previous RSP_STATUS since User not interested
            CLR_U2HOST_COLOR_RSP_STATUS();

            DebugMessageU2HostOHCI("[COLOR][Warning] New Read Request asserted before Previous being Read !", GET_U2HOST_COLOR_REQ_STATUS());
        }

        switch(enumTransferType)
        {
            case _U2HOST_CONTROL_TRANSFER:

                DebugMessageU2HostOHCI("[COLOR][Warning] Control Transfer's functionality might need further testing !", 0);
                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_CONTROL_IN);
                break;

            case _U2HOST_BULK_TRANSFER:

                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_BULK_IN);
                break;

            case _U2HOST_INT_TRANSFER:

                SET_U2HOST_COLOR_REQ_STATUS(_U2HOST_COLOR_REQ_INT_IN);
                break;

            default:
                break;
        }

        bSetReqResult = _SUCCESS;
    }
#endif

    return bSetReqResult;
}

//----------------------------------------------------------------------------------------------------
// Description  : External Interface Get Read Response Flag/DataLen from USB2 Host
// Input Value  : Dev VID, Dev PID, Transfer Type, External Read DataLength Pointer
// Output Value : bReadRspStatusDone, indicate if ReadRsp is received and DataLen is updated
//----------------------------------------------------------------------------------------------------
bit SysUsbU2HostGetColorReadRspStatus(WORD usVid, WORD usPid, EnumUsbU2HostTransferType enumTransferType, BYTE *pucReadGetDataLen)
{
    bit bReadRspStatusDone = _FALSE;
    usVid = usVid;
    usPid = usPid;

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
    // SCPU Flow

    if(enumTransferType == _U2HOST_BULK_TRANSFER)
    {
        if((usVid == _U2HOST_VID_CA410) && (usPid == _U2HOST_PID_CA410))
        {
            if((GET_U2HOST_COLOR_BULK_READ_DONE() == _TRUE) && (GET_U2HOST_COLOR_QUEUE_BUFFER_DONE() == _TRUE))
            {
                CLR_U2HOST_COLOR_QUEUE_BUFFER_DONE();
                bReadRspStatusDone = _TRUE;
                *pucReadGetDataLen = g_ucUsbU2HostColorReadRspLen;
                // DebugMessageU2Host("[User] Status:g_ucUsbU2HostColorReadRspLen", g_ucUsbU2HostColorReadRspLen);
            }
        }
    }
    else if(enumTransferType == _U2HOST_INT_TRANSFER)
    {
        if((usVid == _U2HOST_VID_XRITE) && (usPid == _U2HOST_PID_XRITE))
        {
            if((GET_U2HOST_COLOR_INT_READ_DONE() == _TRUE) && (GET_U2HOST_COLOR_QUEUE_BUFFER_DONE() == _TRUE))
            {
                CLR_U2HOST_COLOR_QUEUE_BUFFER_DONE();
                bReadRspStatusDone = _TRUE;
                *pucReadGetDataLen = g_ucUsbU2HostColorReadRspLen;
                // DebugMessageU2Host("[User] Status:g_ucUsbU2HostColorReadRspLen", g_ucUsbU2HostColorReadRspLen);
            }
        }
    }
#else
    // KCPU Flow

    switch(enumTransferType)
    {
        case _U2HOST_CONTROL_TRANSFER:

            if(GET_U2HOST_COLOR_RSP_STATUS() == _U2HOST_COLOR_RSP_CONTROL_IN)
            {
                bReadRspStatusDone = _TRUE;
                *pucReadGetDataLen = g_ucUsbU2HostColorReadRspLen;
            }

            break;

        case _U2HOST_BULK_TRANSFER:

            if(GET_U2HOST_COLOR_RSP_STATUS() == _U2HOST_COLOR_RSP_BULK_IN)
            {
                bReadRspStatusDone = _TRUE;
                *pucReadGetDataLen = g_ucUsbU2HostColorReadRspLen;
            }

            break;

        case _U2HOST_INT_TRANSFER:

            if(GET_U2HOST_COLOR_RSP_STATUS() == _U2HOST_COLOR_RSP_INT_IN)
            {
                bReadRspStatusDone = _TRUE;
                *pucReadGetDataLen = g_ucUsbU2HostColorReadRspLen;
            }

            break;

        default:
            break;
    }
#endif

    return bReadRspStatusDone;
}

//----------------------------------------------------------------------------------------------------
// Description  : External Interface Get Read Response DataContent from USB2 Host
// Input Value  : Dev VID, Dev PID, Transfer Type, External Read DataContent Pointer, Read Data Length to get
// Output Value : bReadRspDataDone, indicate if Read Rsp is received and DataContent is updated
//----------------------------------------------------------------------------------------------------
bit SysUsbU2HostGetColorReadRspData(WORD usVid, WORD usPid, EnumUsbU2HostTransferType enumTransferType, BYTE *pucReadData, BYTE ucReadReqLen)
{
    bit bReadRspDataDone = _FALSE;
    usVid = usVid;
    usPid = usPid;

#if(_USB2_HOST_FW_SUPPORT_TYPE == _FW_FREE_RTOS)
    // SCPU Flow

    if(enumTransferType == _U2HOST_BULK_TRANSFER)
    {
        if((usVid == _U2HOST_VID_CA410) && (usPid == _U2HOST_PID_CA410))
        {
            g_ucUsbU2HostColorReadDataLen = ucReadReqLen;
            SET_U2HOST_COLOR_START_READ_DATA();

            if(ucReadReqLen > 128)
            {
                DebugMessageU2HostOHCI("[COLOR] ucReadReqLen exceed 128 !", ucReadReqLen);
            }
            else if((GET_U2HOST_COLOR_BULK_READ_DONE() == _TRUE) && (GET_U2HOST_COLOR_DEQUEUE_BUFFER_DONE() == _TRUE))
            {
                // Clear Related Macro to ensure Next Loop "Bulk Write + Bulk Read" can be processed successfully!
                CLR_U2HOST_COLOR_BULK_READ_DONE();
                CLR_U2HOST_COLOR_DEQUEUE_BUFFER_DONE();
                CLR_U2HOST_COLOR_QUEUE_BUFFER_DONE();
                g_ucUsbU2HostColorReadDataLen = 0;

                bReadRspDataDone = _TRUE;

                for(int i = 0; i < ucReadReqLen; i ++)
                {
                    pucReadData[i] = g_pucUsbU2HostColorReadRspData[i];
                    // DebugMessageU2Host("[User] Inside pucReadData[i]", pucReadData[i]);
                }
            }
        }
    }
    else if(enumTransferType == _U2HOST_INT_TRANSFER)
    {
        if((usVid == _U2HOST_VID_XRITE) && (usPid == _U2HOST_PID_XRITE))
        {
            g_ucUsbU2HostColorReadDataLen = ucReadReqLen;
            SET_U2HOST_COLOR_START_READ_DATA();

            if(ucReadReqLen > 128)
            {
                DebugMessageU2HostOHCI("[COLOR] ucReadReqLen exceed 128 !", ucReadReqLen);
            }
            else if((GET_U2HOST_COLOR_INT_READ_DONE() == _TRUE) && (GET_U2HOST_COLOR_DEQUEUE_BUFFER_DONE() == _TRUE))
            {
                // Clear Related Macro to ensure Next Loop "Int Write + Int Read" can be processed successfully!
                CLR_U2HOST_COLOR_INT_READ_DONE();
                CLR_U2HOST_COLOR_DEQUEUE_BUFFER_DONE();
                CLR_U2HOST_COLOR_QUEUE_BUFFER_DONE();
                g_ucUsbU2HostColorReadDataLen = 0;

                bReadRspDataDone = _TRUE;

                for(int i = 0; i < ucReadReqLen; i ++)
                {
                    pucReadData[i] = g_pucUsbU2HostColorReadRspData[i];
                    // DebugMessageU2Host("[User] Inside pucReadData[i]", pucReadData[i]);
                }
            }
        }
    }
#else
    // KCPU Flow

    if(ucReadReqLen > 128)
    {
        DebugMessageU2HostOHCI("[COLOR] ucReadReqLen exceed 128 !", ucReadReqLen);
    }
    else
    {
        switch(enumTransferType)
        {
            case _U2HOST_CONTROL_TRANSFER:

                if(GET_U2HOST_COLOR_RSP_STATUS() == _U2HOST_COLOR_RSP_CONTROL_IN)
                {
                    bReadRspDataDone = _TRUE;
                    CLR_U2HOST_COLOR_RSP_STATUS();

                    // Get BulkIn data directly from OHCI Ctrl Buffer
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_OHCI_CTRL_BUFFER_ST_ADDR, 0x00, pucReadData, ucReadReqLen);
                }

                break;

            case _U2HOST_BULK_TRANSFER:

                if(GET_U2HOST_COLOR_RSP_STATUS() == _U2HOST_COLOR_RSP_BULK_IN)
                {
                    bReadRspDataDone = _TRUE;
                    CLR_U2HOST_COLOR_RSP_STATUS();

                    // Get BulkIn data directly from OHCI BulkIn Buffer
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_OHCI_BULK_IN_BUFFER_ST_ADDR, 0x00, pucReadData, ucReadReqLen);
                }

                break;

            case _U2HOST_INT_TRANSFER:

                if(GET_U2HOST_COLOR_RSP_STATUS() == _U2HOST_COLOR_RSP_INT_IN)
                {
                    bReadRspDataDone = _TRUE;
                    CLR_U2HOST_COLOR_RSP_STATUS();

                    // Get BulkIn data directly from OHCI Int1 Buffer
                    ScalerUsbU2HostGetBufferBulkData(_U2HOST_OHCI_INT0_BUFFER_ST_ADDR, 0x00, pucReadData, ucReadReqLen);
                }

                break;

            default:
                break;
        }
    }
#endif

    return bReadRspDataDone;
}

#endif // End of #if(_USB2_HOST_OHCI_COLOR_ANALYZER_SUPPORT == _ON)

#endif // End of #if(_USB2_HOST_SUPPORT == _ON)
#endif // End of #if(_USB_SUPPORT == _ON)

#if(_TYPE_C_GPIO_MODE_SUPPORT == _ON)
//--------------------------------------------------
// Description  : Return CC Pin Status
// Input Value  : enumEmbTypeCIndex (_EMB_TYPE_C_0, _EMB_TYPE_C_1), enumTypeCChannel (_TYPE_C_CC1, _TYPE_C_CC2)
// Output Value : EnumTypeCCcDetectStatus : _TYPE_C_CC_DETECT_HIGH (if CC Voltage >= 2.6V) / _TYPE_C_CC_DETECT_LOW (if CC Voltage < 2.6V)
//--------------------------------------------------
EnumTypeCCcDetectStatus SysUsbTypeCGetCcPinStatus(EnumTypeCEmbeddedList enumEmbTypeCIndex, EnumTypeCChannel enumTypeCChannel)
{
    return ScalerTypeCGetCcPinStatus(enumEmbTypeCIndex, enumTypeCChannel);
}
#endif  // End of #if(_TYPE_C_GPIO_MODE_SUPPORT == _ON)
